---
layout:  post
title:  算法图解心得
date:  2020-05-21 15:38:25
urlname: 算法图解心得
categories:
  -算法
tags:
  -算法
mathjax: true
---

## 1.二分查找

二分查找属于**分治法**，分治法基本都可以使用递归来实现。二分查找只能用于**有序的数组**，其时间复杂度为**$O(logn)$**。

```python
# 二分查找，非递归方式
def binary_search(arrays, low_index, high_index, target):
    while low_index <= high_index:
        mid_index = (low_index + high_index) // 2
        if arrays[mid_index] > target:
            high_index = mid_index - 1
        elif arrays[mid_index] < target:
            low_index = mid_index + 1
        else:
            return arrays[mid_index]
    return None

# 二分查找,递归方式
def binary_search_with_recursion(arrays, low_index, high_index, target):
    if low_index > high_index:
        return None
    mid_index = (low_index + high_index) // 2
    if arrays[mid_index] > target:
        return binary_search(arrays, low_index, mid_index - 1, target)
    elif arrays[mid_index] < target:
        return binary_search(arrays, low_index + 1, high_index, target)
    else:
        return arrays[mid_index]
    
numbers = [1, 2, 3, 3, 4, 5, 6, 7, 8, 8, 9, 10]

binary_search(numbers, 0, len(numbers), 9)
binary_search_with_recursion(numbers, 0, len(numbers), 9)
```

## 2.选择排序

选择排序的时间复杂度为：**$ O(n^2) $**，n是数组的长度。选择排序是一种比较灵巧的算法，但其速度不是很快。

```python
#找到数组中最小值 的索引
def find_min_index(arrays):
    min_value = arrays[0]
    min_value_index = 0
    for i in range(1, len(arrays)):
        if arrays[i] < min_value:
            min_value = arrays[i]
            min_value_index = i
    return min_value_index

def select_sort(arrays):
    #用于存储排序后的数
    sorted_array = []
    for i in range(0, len(arrays)):
        sorted_array.append(arrays.pop(find_min_index(arrays)))
    return sorted_array
```

## 3.快速排序

排序的时间复杂度为：**$O(n logn)$**,快速排序的性能高度依赖选取的基准值，所以在最糟的情况下快速排序和选择排序的时间复杂度是一样的，都是**$O(n^2)$**,在最佳情况下快速排序的时间复杂度是**$O(n logn)$**,**最佳情况也是平均情况**。

```python
def quick_sort(arrays):
    #递归的基线条件，当数组的长度小于等于1的时候不再需要排序，直接返回该数组
    if len(arrays) < 2:
        return arrays
    else:
        #取数组的第一个元素为基准值
        pivot = arrays[0]
        #找出数组中小于基准值的元素
        less = [i for i in arrays[1:] if i < pivot]
        #找出数组中大于等于基准值的元素
        greater = [i for i in arrays[1:] if i >= pivot]
        #递归调用快速排序
        return quick_sort(less) + [pivot] + quick_sort(greater)
```

## 4.广度优先搜索

广度优先搜索用于解决最短路径问题(shortest-path problem)，可帮助回答两个问题：

1. 从节点A出发，有到节点B的路径吗？
2. 从节点A出发，前往节点B的哪条路径最短？

**要达到这样的目的，搜索的顺序很重要，可以使用队列(queue)来实现**。

```python
from collections import deque
graph = {'you': ['Bob', 'Alice', 'Claire'], 'Bob': ['Anuj', 'Peggy'], 'Claire': ['Thom', 'Jonny'],
             'Alice': ['Peggy'], 'Peggy': [], 'Anuj': [], 'Thom': [], 'Jonny': []}
# 广度优先搜索，这里假设名字以字符'm'结尾的人就是我们要找的
def wide_first_search():
    # 用于标记已经搜索过的人，防止无限循环
    searched=[]
    search_queue = deque()
    # 将你的邻居加入到搜索队列中
    search_queue += graph['you']
    while search_queue:
        person = search_queue.popleft()
        # 判断person是否已经搜索过
        if person not in searched:
            # 满足条件，返回
            if person[-1] == 'm':
                return person
            else:
                # 不满足条件，将这个人的邻居加入到搜索队列中
                search_queue += graph[person]
                searched.append(person)
    # 搜索队列为空，搜索完毕，没有找到满足条件的人
    return None
```

## 5.狄克斯特拉算法

广度优先搜索适用于找出**非加权图**中前往某节点的最短路径，而狄克斯特拉算法(Dijkstra's algorithm)用于找出**加权图**中前往某节点的最短路径，。狄克斯特拉算法包含四个步骤：

1. 找出最便宜的节点，例如可在最短时间内前往的节点
2. 对于该节点的邻居，检查是否有前往它们的更短路径，如果有，则更新其开销
3. 重复这个过程，知道图中的所有的节点都这样做了
4. 计算最终路径

需要注意的是：**狄克斯特拉算法只使用于有向无环图，并且不能将该算法用于包含负权边的图。**（包含负权边的图，可使用贝尔曼-福德算法）

```python
# 记录所有节点的邻居
graph = {'start': {'a': 6, 'b': 2}, 'a': {'finish': 1}, 'b': {'a': 3, 'finish': 5}, 'finish': {}}
infinity = float('inf')
# 记录已知节点的开销
costs = {'a': 6, 'b': 2, 'finish': infinity}
# 记录已知节点的父节点
parents = {'a': 'start', 'b': 'start', 'finish': None}
# 记录处理过的节点
processed = []
 # 在costs中找到开销最小的节点
def find_lowest_cost_node(costs):
    lowest_cost = float('inf')
    lowest_node = None
    for node in costs:
        cost = costs[node]
        if cost < lowest_cost and node not in processed:
            lowest_cost = cost
            lowest_node = node
    return lowest_node

# 狄克斯特拉算法的实现,该算法不能用于包含负权边的图,且只适用于有向无环图
def dijkstra_algorithm():
    node = find_lowest_cost_node(costs,processed)
    while node is not None:
        cost = costs[node]
        neighbors = graph[node]
        for key in neighbors.keys():
            new_const = cost + neighbors[key]
            if costs[key] > new_const:
                costs[key] = new_const
                parents[key] = node
        processed.append(node)
        node = find_lowest_cost_node(costs,processed)
    print(parents)
```