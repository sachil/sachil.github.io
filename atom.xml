<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Sachil&#39;s Blog</title>
  
  <subtitle>为天地立心，为生民立命&lt;br&gt;为往圣继绝学，为天下安太平</subtitle>
  <link href="https://sachil.xyz/atom.xml" rel="self"/>
  
  <link href="https://sachil.xyz/"/>
  <updated>2023-06-20T15:46:03.207Z</updated>
  <id>https://sachil.xyz/</id>
  
  <author>
    <name>Sachil</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Kotlin中的泛型</title>
    <link href="https://sachil.xyz/posts/e6adb2c5/"/>
    <id>https://sachil.xyz/posts/e6adb2c5/</id>
    <published>2020-09-22T09:53:43.000Z</published>
    <updated>2023-06-20T15:46:03.207Z</updated>
    
    <content type="html"><![CDATA[<h1 id="kotlin中的泛型">Kotlin中的泛型</h1><p><code>Kotlin</code>和<code>Java</code>一样，也可以有类型参数，即<code>Kotlin</code>同样支持泛型，同样的和<code>Java</code>一样，<strong><code>Kotlin</code>中的泛型同样不直接支持型变</strong>。我们知道，在<code>Java</code>中我们可以使用上界通配符&lt;?extends T&gt;来支持<strong>协变</strong>，使用下界通配符&lt;? superT&gt;来支持<strong>逆变</strong>。在<code>Kotlin</code>的泛型中，没有通配符，而是使用<code>out</code>和<code>in</code>这两个关键字来实现同样的功能。另外不同于<code>Java</code>中在使用处型变，<code>Kotlin</code>也支持在声明处型变。下面我们就来仔细了解一下<code>Kotlin</code>中的泛型。</p><span id="more"></span><h2 id="关键字out和in">关键字out和in</h2><p>和<code>Java</code>一样，<code>Kotlin</code>中的泛型本身也不支持型变的，但是我们可以使用<code>out</code>和<code>in</code>这两个关键字来让泛型支持型变：</p><ul><li>关键字<code>out</code>使泛型支持协变，协变得以让泛型的父类引用持有泛型子类的实例，等同于<code>Java</code>中的上界通配符&lt;?extendsT&gt;，所以带来的限制也是一样的：只能读取不能修改(<em>修改指的是添加元素</em>)。</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> intList = mutableListOf&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line">    intList.add(<span class="number">1</span>)</span><br><span class="line">    <span class="comment">//使用out让泛型支持协变，从而让泛型父类的引用可以持有泛型子类的对象</span></span><br><span class="line">    <span class="keyword">val</span> numberList: MutableList&lt;<span class="keyword">out</span> Number&gt; = intList</span><br><span class="line">    <span class="comment">//可作为Number读取</span></span><br><span class="line">    <span class="keyword">val</span> number: Number = numberList[<span class="number">0</span>]</span><br><span class="line">    numberList.add(<span class="number">2</span>) <span class="comment">//编译错误，out带来的限制是只能读取不能修改(修改指的是添加)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>关键字<code>in</code>使泛型支持逆变，逆变使泛型的子类引用可以持有泛型父类的实例，等同于<code>Java</code>中的下界通配符&lt;?superT&gt;，所以限制也是一致的：只能修改(<em>只能添加T或者其子类</em>)不能读取(<em>可以按照<code>Any?</code>的方式读取，为什么是<code>Any?</code>而不是<code>Any</code>？因为<code>Any</code>不能表示<code>null</code>值</em>)。</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> anyList = mutableListOf&lt;Any&gt;()</span><br><span class="line">    anyList.add(<span class="number">1</span>)</span><br><span class="line">    anyList.add(<span class="number">2.0F</span>)</span><br><span class="line">    anyList.add(<span class="string">&quot;3&quot;</span>)</span><br><span class="line">    <span class="comment">//通过in让泛型支持逆变，逆变可以让泛型子类的引用持有泛型父类的对象</span></span><br><span class="line">    <span class="keyword">val</span> intList:MutableList&lt;<span class="keyword">in</span> <span class="built_in">Int</span>&gt; = anyList</span><br><span class="line">    <span class="comment">//可以添加Int及其子类</span></span><br><span class="line">    intList.add(<span class="number">4</span>)</span><br><span class="line">    intList.add(<span class="number">5L</span>) <span class="comment">//编译错误，只能添加Int及其子类</span></span><br><span class="line">    <span class="keyword">val</span> item: Any? = intList[<span class="number">1</span>] <span class="comment">//可以按照any的方式读取</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通常我们将只能读取的对象称为<strong>生产者</strong>，只能写入的对象称为<strong>消费者</strong>，在<code>Java</code>中上界通配符用于生产者，下界通配符用于消费者，这被称之为<strong><code>PECS</code>法则</strong>，<em>生产者-extends，消费者-super(Producerextends，Consumersuper)</em>。在<code>Kotlin</code>中<code>out</code>表示生产者，<code>in</code>表示消费者。这应该更好理解，<code>out</code>表示只能往外拿，和生产者身份符合，而<code>in</code>表示只能往里放，和消费者身份符合。</p><h2 id="声明处型变">声明处型变</h2><p><code>Kotlin</code>中的泛型和<code>Java</code>中的泛型一样可以在使用处型变，只是在<code>Kotlin</code>中使用处型变称之为<strong>类型投影</strong>。除了类型投影之外，<code>Kotlin</code>还支持在声明处进行型变。也就是在声明类或者接口的时候，给泛型符号加上关键字<code>out</code>或者<code>in</code>，这样表示泛型参数<code>T</code>只会用于输出或者只会用于输入：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Producer</span>&lt;<span class="type">out T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">next</span><span class="params">()</span></span>: T &#123;</span><br><span class="line">        TODO(<span class="string">&quot;Not yet implemented&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Consumer</span>&lt;<span class="type">in T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">consume</span><span class="params">(item: <span class="type">T</span>)</span></span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 可以不用写关键字out</span></span><br><span class="line">    <span class="keyword">val</span> producer: Producer&lt;Number&gt; = Producer&lt;<span class="built_in">Float</span>&gt;()</span><br><span class="line">    <span class="keyword">val</span> number: Number = producer.next()</span><br><span class="line">    <span class="comment">// 可以不用写关键字in</span></span><br><span class="line">    <span class="keyword">val</span> consumer: Consumer&lt;<span class="built_in">Int</span>&gt; = Consumer&lt;Number&gt;()</span><br><span class="line">    consumer.consume(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们仅从字面量就可以看到类型投影与声明处型变的不同：类型投影中关键字<code>out</code>或<code>in</code>后面紧跟的是一个具体的类型，如<code>MutableList&lt;out Number&gt;</code>，而声明处型变中关键字<code>out</code>或<code>in</code>后面紧跟的是泛型参数，例如<code>class Producer&lt;out T&gt;</code>。</p><p>类型投影的主要作用是为参数添加限定，避免不安全的操作，声明处型变给我们带来的好处就是，当使用的时候可以不用写关键字<code>out</code>或者<code>in</code>。</p><h2 id="星投影">星投影</h2><p>我们知道，在<code>Java</code>中使用无界通配符<code>&lt;?&gt;</code>来表示泛型实参是某一种特定的类型，但是却不知道具体的类型，在<code>Kotlin</code>中使用符号<code>*</code>来实现同样的功能。在<code>Java</code>中<code>&lt;?&gt;</code>实际上相当于<code>&lt;? extends Object&gt;</code>，而在<code>Kotlin</code>中<code>&lt;*&gt;</code>实际上相当于<code>&lt;* out Any?&gt;</code>。和<code>Java</code>不同的是，如果你使用声明处型变，并提供上界，那么这个上界在使用<code>&lt;*&gt;</code>的时候仍然存在，例如：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明处型变，并指定上界</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Producer</span>&lt;<span class="type">out T:Number</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">next</span><span class="params">()</span></span>: T &#123;</span><br><span class="line">        TODO(<span class="string">&quot;Not yet implemented&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> producer: Producer&lt;Number&gt; = Producer&lt;<span class="built_in">Float</span>&gt;()</span><br><span class="line">    <span class="comment">//使用星投影</span></span><br><span class="line">    <span class="keyword">val</span> starProducer:Producer&lt;*&gt; = producer</span><br><span class="line">    <span class="comment">//这里是以Number的方式读取，而不是Any？</span></span><br><span class="line">    <span class="keyword">val</span> number:Number = starProducer.next()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于<code>&lt;*&gt;</code>表示泛型实参是某一未知的特定类型，而进行写入操作的任何值都可能和这一特定的类型产生冲突，所以星投影不能写入，只能读取。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Consumer</span>&lt;<span class="type">in T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">consume</span><span class="params">(item: <span class="type">T</span>)</span></span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> consumer: Consumer&lt;<span class="built_in">Int</span>&gt; = Consumer&lt;Number&gt;()</span><br><span class="line">    consumer.consume(<span class="number">1</span>)</span><br><span class="line">    <span class="comment">//使用星投影</span></span><br><span class="line">    <span class="keyword">val</span> starConsumer: Consumer&lt;*&gt; = consumer</span><br><span class="line">    starConsumer.consume(<span class="number">2</span>) <span class="comment">//编译错误，不能写入</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="泛型约束">泛型约束</h2><p>当声明一个泛型的时候，<code>Kotlin</code>允许给这个泛型类型形参添加约束条件，也就是把泛型的类型形参可接受的类型实参限制在特定的类型范围内。最常见的约束类型就是使用<code>out</code>来指定泛型类型形参的上界。</p><p>一般情况下，当你有以下两种需求中的一种时，你就可以使用泛型约束：</p><ul><li>你需要在某个类型上访问特定的方法或属性时。</li><li>你需要让函数返回某个特定类型时。</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T : Number&gt;</span> <span class="title">printNumber</span><span class="params">(value: <span class="type">T</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// value被约束为上界为Number，所以value可以使用Number中的方法</span></span><br><span class="line">    println(value.toInt())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回特定的类型</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T : Number&gt;</span> <span class="title">getFirstNumber</span><span class="params">(list: <span class="type">List</span>&lt;<span class="type">T</span>&gt;)</span></span>: T &#123;</span><br><span class="line">    <span class="keyword">return</span> list[<span class="number">0</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    printNumber(<span class="number">4L</span>)</span><br><span class="line">    <span class="comment">//返回的是Int</span></span><br><span class="line">    <span class="keyword">val</span> firstInt: <span class="built_in">Int</span> = getFirstNumber(listOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>))</span><br><span class="line">    <span class="comment">//返回的是Float</span></span><br><span class="line">    <span class="keyword">val</span> firstFloat: <span class="built_in">Float</span> = getFirstNumber(listOf(<span class="number">1.0F</span>, <span class="number">2.0F</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当泛型约束同时有多个约束条件时，需要使用<code>where</code>关键字:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Sing</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">sing</span><span class="params">(song: <span class="type">String</span>)</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">Dancer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">dance</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用关键字where来同时约束过个约束条件</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">party</span><span class="params">(player: <span class="type">T</span>)</span></span> <span class="keyword">where</span> T : Sing, T : Dancer &#123;</span><br><span class="line">    player.sing(<span class="string">&quot;Hello world&quot;</span>)</span><br><span class="line">    player.dance()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实化类型参数reified">实化类型参数reified</h2><p><code>Java</code>中的泛型是使用类型擦除来得以实现的，在编译的过程中泛型类型的实参的类型信息将会丢失，所以在运行的时候，是不知道泛型实参的具体类型的。<code>Kotlin</code>为了兼容<code>Java</code>，其泛型同样采用类型擦除，但是<code>Kotlin</code>却为我们留下了一扇窗-<code>reified</code>。</p><p><code>reified</code>仅用于使用<code>inline</code>声明的内联函数，<code>reified</code>通常用于比较类型和获得一个类的<code>class</code>对象，例如我们可以这样使用：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;<span class="keyword">reified</span> T&gt;</span> Any.<span class="title">isInstance</span><span class="params">()</span></span>: <span class="built_in">Boolean</span> = <span class="keyword">this</span> <span class="keyword">is</span> T</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    println(<span class="number">1.</span>isInstance&lt;<span class="built_in">Int</span>&gt;()) <span class="comment">//输出为true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再例如在我们平时使用Gson来反序列法json字符串时，需要将class对象作为参数进行传递，目的是让Gson知道你想要的类型:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Response</span></span>(<span class="keyword">val</span> status: String) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> response = Gson().fromJson(<span class="string">&quot;&#123;\&quot;status\&quot;:\&quot;OK\&quot;&#125;&quot;</span>, Response::<span class="keyword">class</span>.java)</span><br><span class="line">    println(response.status)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，我们可以使用<code>reified</code>实化类型参数来简化我们的代码：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Response</span></span>(<span class="keyword">val</span> status: String) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;<span class="keyword">reified</span> T&gt;</span> Gson.<span class="title">fromJson</span><span class="params">(json: <span class="type">String</span>)</span></span>: T &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.fromJson(json, T::<span class="keyword">class</span>.java)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> response = Gson().fromJson&lt;Response&gt;(<span class="string">&quot;&#123;\&quot;status\&quot;:\&quot;OK\&quot;&#125;&quot;</span>)</span><br><span class="line">    println(response.status)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于<code>reified</code>的原理，可以参考我的另一篇文章：<ahref="https://sachil.xyz/posts/93d266b8/">Kotlin中的内联函数</a></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;kotlin中的泛型&quot;&gt;Kotlin中的泛型&lt;/h1&gt;
&lt;p&gt;&lt;code&gt;Kotlin&lt;/code&gt;和&lt;code&gt;Java&lt;/code&gt;一样，也可以有类型参数，即&lt;code&gt;Kotlin&lt;/code&gt;同样支持泛型，同样的和&lt;code&gt;Java&lt;/code&gt;一样，&lt;strong&gt;&lt;code&gt;Kotlin&lt;/code&gt;中的泛型同样不直接支持型变&lt;/strong&gt;。我们知道，在&lt;code&gt;Java&lt;/code&gt;中我们可以使用上界通配符&amp;lt;?
extends T&amp;gt;来支持&lt;strong&gt;协变&lt;/strong&gt;，使用下界通配符&amp;lt;? super
T&amp;gt;来支持&lt;strong&gt;逆变&lt;/strong&gt;。在&lt;code&gt;Kotlin&lt;/code&gt;的泛型中，没有通配符，而是使用&lt;code&gt;out&lt;/code&gt;和&lt;code&gt;in&lt;/code&gt;这两个关键字来实现同样的功能。另外不同于&lt;code&gt;Java&lt;/code&gt;中在使用处型变，&lt;code&gt;Kotlin&lt;/code&gt;也支持在声明处型变。下面我们就来仔细了解一下&lt;code&gt;Kotlin&lt;/code&gt;中的泛型。&lt;/p&gt;</summary>
    
    
    
    <category term="Kotlin" scheme="https://sachil.xyz/categories/Kotlin/"/>
    
    
    <category term="泛型" scheme="https://sachil.xyz/tags/Generics/"/>
    
    <category term="Kotlin" scheme="https://sachil.xyz/tags/Kotlin/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin中的let、with、run、apply和also</title>
    <link href="https://sachil.xyz/posts/14df605f/"/>
    <id>https://sachil.xyz/posts/14df605f/</id>
    <published>2020-08-02T12:17:40.000Z</published>
    <updated>2023-06-20T15:46:03.207Z</updated>
    
    <content type="html"><![CDATA[<h1id="kotlin中的letwithrunapply和also">Kotlin中的let、with、run、apply和also</h1><h2 id="作用域函数">作用域函数</h2><p>作用域函数在Kotlin中有比较重要的作用，它们的作用是在对象上下文中执行代码块，当对一个对象调用这样的函数并提供一个<code>Lambda</code>表达式时，会形成一个临时的作用域，在此作用域中可以访问对象而不予要名称。在<code>Kotlin</code>标准库中，为我们提供了<code>let</code>、<code>with</code>、<code>run</code>、<code>apply</code>以及<code>also</code>5个作用域函数。作用域函数是为了更方便的访问对象和操作，你可以进行空安全检查，更改属性等操作。</p><span id="more"></span><h2id="letwithrunapply和also之间的区别">let、with、run、apply和also之间的区别</h2><p>下面我们来逐一了解一下这5个作用域函数：</p><ul><li><code>let</code>，<code>let</code>的声明方式为：</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T, R&gt;</span> T.<span class="title">let</span><span class="params">(block: (<span class="type">T</span>) -&gt; <span class="type">R</span>)</span></span>: R &#123;&#125;</span><br></pre></td></tr></table></figure><p>它被声明为对象T的扩展函数，它的参数block的类型是一个参数为对象T并且返回值为R的函数类型，所以在block所代表的<code>Lambda</code>表达式中，使用<code>it</code>来代表对象T，并且将<code>Lambda</code>表达式的返回值作为<code>let</code>的返回值。</p><ul><li><code>with</code>，<code>with</code>的声明方式为：</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T, R&gt;</span> <span class="title">with</span><span class="params">(receiver: <span class="type">T</span>, block: <span class="type">T</span>.() -&gt; <span class="type">R</span>)</span></span>: R &#123;&#125;</span><br></pre></td></tr></table></figure><p>从声明方式可以看出，它是一个普通函数而不是扩展函数，receiver表示传入一个对象，block所代表的<code>Lambda</code>表达式被声明为这个对象上的扩展函数，我们注意到，block并没有参数，所以在<code>Lambda</code>表达式中不能使用<code>it</code>来引用对象T，而是应该通过<code>this</code>来引用。还需注意的是:<strong>it可以用其它的名字来代替，而this则不能</strong>。</p><ul><li><code>run</code>，<code>run</code>的声明方式有两种：</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;R&gt;</span> <span class="title">run</span><span class="params">(block: () -&gt; <span class="type">R</span>)</span></span>: R &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T, R&gt;</span> T.<span class="title">run</span><span class="params">(block: <span class="type">T</span>.() -&gt; <span class="type">R</span>)</span></span>: R &#123;&#125;</span><br></pre></td></tr></table></figure><p>第一种方式它被声明为一个普通函数，并且函数类型的参数block也没有传入参数，它的作用是当你需要需要表达式的地方就可以执行一个语句。</p><p>第二种方式它被声明为一个扩展函数，block代表的<code>Lambda</code>表达式也被声明为该对象的扩展函数，block仍然不携带参数，所以在<code>Lambda</code>中还是通过<code>this</code>来引用对象T本身。run使用<code>Lambda</code>的返回值作为自己的返回值。</p><ul><li><code>apply</code>，其声明方式为为：</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> T.<span class="title">apply</span><span class="params">(block: <span class="type">T</span>.() -&gt; <span class="type">Unit</span>)</span></span>: T &#123;&#125;</span><br></pre></td></tr></table></figure><p>它被声明为扩展函数，block所代表的<code>Lambda</code>表达式也被声明为该对象的扩展函数，block不携带参数，所以只能使用<code>this</code>引用对象T本身。apply的返回值并没有使用<code>Lambda</code>的返回值，而是是对象自己。</p><ul><li><code>also</code>，<code>also</code>的声明方式为：</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> T.<span class="title">also</span><span class="params">(block: (<span class="type">T</span>) -&gt; <span class="type">Unit</span>)</span></span>: T &#123;&#125;</span><br></pre></td></tr></table></figure><p>它也被声明为扩展函数，block参数的类型是函数类型，block携带一个参数，所以在block<code>Lambda</code>表达式中，使用<code>it</code>来引用对象T本身，also的返回值也是对象自己。</p><p>从上面的内容我们可以了解到：</p><ol type="1"><li><code>with</code>和<code>run</code>(第一种声明方式)为普通函数，而<code>let</code>、<code>run</code>（第二种声明方式）、<code>apply</code>和<code>also</code>被声明为扩展函数。</li><li>在<code>lambda</code>表达式的内部，<code>let</code>和<code>also</code>使用<code>it</code>来引用对象本身，<code>with</code>、<code>run</code>、<code>apply</code>则使用<code>this</code>来引用对象本身。</li><li><code>apply</code>和<code>also</code>的返回值是对象本身，而<code>let</code>、<code>with</code>和<code>run</code>的返回值是block所代表的<code>Lambda</code>表达式的返回值。</li></ol><p>以上三点就是这5个作用域函数在声明方式上的主要区别。</p><h2 id="如何选择">如何选择</h2><p>当我们使用它们的时候，首先判断是否需要返回对象本身，如果需要返回对象本身，就选择<code>apply</code>或者<code>also</code>，在这二者之间，若<code>Lambda</code>中需要使用<code>it</code>来引用对象本身则选择<code>also</code>，否则选择<code>apply</code>；如果不需要返回对象本身，则选择<code>let</code>、<code>with</code>或者<code>run</code>，在这三者中，如果不需要扩展函数，则选择<code>with</code>,否则选择<code>let</code>和<code>run</code>，在这两者中，若<code>Lambda</code>中需要<code>it</code>来引用对象本身则选择<code>let</code>否则选择<code>run</code>。</p><p>通常情况下，它们的使用场景是：</p><ul><li><code>apply</code>用于初始化对象或者更改对象属性。</li><li><code>also</code>用于将数据指派给对象属性之前检查对象。</li><li><code>let</code>用于将对象进行空检查或者访问、修改其属性。</li><li>如果是非null对象，需要调用对象的多个方法时，可以使用<code>with。</code></li><li>如果想要计算某个值，或者限制多个本地变量的范围，则使用<code>run</code>。</li></ul>]]></content>
    
    
    <summary type="html">&lt;h1
id=&quot;kotlin中的letwithrunapply和also&quot;&gt;Kotlin中的let、with、run、apply和also&lt;/h1&gt;
&lt;h2 id=&quot;作用域函数&quot;&gt;作用域函数&lt;/h2&gt;
&lt;p&gt;作用域函数在Kotlin中有比较重要的作用，它们的作用是在对象上下文中执行代码块，当对一个对象调用这样的函数并提供一个&lt;code&gt;Lambda&lt;/code&gt;表达式时，会形成一个临时的作用域，在此作用域中可以访问对象而不予要名称。在&lt;code&gt;Kotlin&lt;/code&gt;标准库中，为我们提供了&lt;code&gt;let&lt;/code&gt;、&lt;code&gt;with&lt;/code&gt;
、&lt;code&gt;run&lt;/code&gt;
、&lt;code&gt;apply&lt;/code&gt;以及&lt;code&gt;also&lt;/code&gt;5个作用域函数。
作用域函数是为了更方便的访问对象和操作，你可以进行空安全检查，更改属性等操作。&lt;/p&gt;</summary>
    
    
    
    <category term="Kotlin" scheme="https://sachil.xyz/categories/Kotlin/"/>
    
    
    <category term="Kotlin" scheme="https://sachil.xyz/tags/Kotlin/"/>
    
    <category term="作用域函数" scheme="https://sachil.xyz/tags/Scope-Functions/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin中的Sequence与Collection</title>
    <link href="https://sachil.xyz/posts/49c621ce/"/>
    <id>https://sachil.xyz/posts/49c621ce/</id>
    <published>2020-07-10T11:08:12.000Z</published>
    <updated>2023-06-20T15:46:03.207Z</updated>
    
    <content type="html"><![CDATA[<h1id="kotlin中的sequence与collection">Kotlin中的Sequence与Collection</h1><p><code>Kotlin</code>除了为我们提供了一般的集合类型(如<code>List</code>、<code>Set</code>、<code>Map</code>)之外，还为我们提供了另一种容器类型：<code>Sequence</code>(序列)。<strong>不同于<code>Collection</code>的立即执行，<code>Sequence</code>是延迟执行的</strong>，例如下面的例子：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> sequence = listOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>).asSequence()</span><br><span class="line">    <span class="comment">//这里不会有任何的打印信息，因为filter和map操作还没有被执行</span></span><br><span class="line">    sequence.filter &#123;</span><br><span class="line">        println(<span class="string">&quot;filter:<span class="variable">$it</span>&quot;</span>)</span><br><span class="line">        it % <span class="number">2</span> == <span class="number">0</span></span><br><span class="line">    &#125;.map &#123;</span><br><span class="line">        println(<span class="string">&quot;map:<span class="variable">$it</span>&quot;</span>)</span><br><span class="line">        <span class="string">&quot;<span class="variable">$it</span>&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正是由于这种延迟执行的特性，在对数据集中的元素进行链式操作时(例如<code>map</code>、<code>filter</code>等)，使用<code>Sequence</code>可以变得更加高效，因为在这种情况下，不需要像普通集合那样，每进行一次数据操作，都必须要开辟新的内存来存储中间结果，而实际上在大多数情况下，我们并不关心中间结果，而只需要最终的结果。</p><span id="more"></span><h2 id="sequence的中间操作和末端操作">Sequence的中间操作和末端操作</h2><p>对<code>Sequence</code>进行操作的操作可以分为两类：</p><ul><li>中间操作，中间操作是延迟执行的，它们只是被存储起来，仅当末端操作被调用的时候，才会按照顺序在每个元素上执行中间操作，中间操作会返回另一个<code>Sequence</code>。</li><li>末端操作，末端操作会执行原来中间操作的所有延迟计算，一次末端操作返回的是一个结果。</li></ul><p>判断一个操作符是属于中间操作还是末端操作，可以通过操作符的返回值来判断，如果返回的是<code>Sequence</code>则是中间操作，如果是一个具体的结果类型，则是末端操作。</p><p>通过下面的例子，我们可以更直观的观察到<code>Sequence</code>和<code>Collection</code>之间的不同：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">collectionTest</span><span class="params">()</span></span>: List&lt;<span class="built_in">Int</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">val</span> words = <span class="string">&quot;The quick brown fox jumps over the lazy dog&quot;</span>.split(<span class="string">&quot; &quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> result = words.filter &#123;</span><br><span class="line">        println(<span class="string">&quot;filter:<span class="variable">$it</span>&quot;</span>)</span><br><span class="line">        it.length &gt; <span class="number">3</span></span><br><span class="line">    &#125;.map &#123;</span><br><span class="line">        println(<span class="string">&quot;map:<span class="subst">$&#123;it.length&#125;</span>&quot;</span>)</span><br><span class="line">        it.length</span><br><span class="line">    &#125;.take(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">    println(<span class="string">&quot;Collection test...&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">sequenceTest</span><span class="params">()</span></span>: List&lt;<span class="built_in">Int</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">val</span> words = <span class="string">&quot;The quick brown fox jumps over the lazy dog&quot;</span>.split(<span class="string">&quot; &quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> wordSequence = words.asSequence()</span><br><span class="line">    <span class="keyword">val</span> result = wordSequence.filter &#123;</span><br><span class="line">        println(<span class="string">&quot;filter:<span class="variable">$it</span>&quot;</span>)</span><br><span class="line">        it.length &gt; <span class="number">3</span></span><br><span class="line">    &#125;.map &#123;</span><br><span class="line">        println(<span class="string">&quot;map:<span class="subst">$&#123;it.length&#125;</span>&quot;</span>)</span><br><span class="line">        it.length</span><br><span class="line">    &#125;.take(<span class="number">4</span>)</span><br><span class="line">    println(<span class="string">&quot;Sequence test...&quot;</span>)</span><br><span class="line">    <span class="comment">//toList是一个末端操作</span></span><br><span class="line">    <span class="keyword">return</span> result.toList()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 输出结果为：</span></span><br><span class="line"><span class="comment">     * filter:The</span></span><br><span class="line"><span class="comment">     * filter:quick</span></span><br><span class="line"><span class="comment">     * filter:brown</span></span><br><span class="line"><span class="comment">     * filter:fox</span></span><br><span class="line"><span class="comment">     * filter:jumps</span></span><br><span class="line"><span class="comment">     * filter:over</span></span><br><span class="line"><span class="comment">     * filter:the</span></span><br><span class="line"><span class="comment">     * filter:lazy</span></span><br><span class="line"><span class="comment">     * filter:dog</span></span><br><span class="line"><span class="comment">     * map:5</span></span><br><span class="line"><span class="comment">     * map:5</span></span><br><span class="line"><span class="comment">     * map:5</span></span><br><span class="line"><span class="comment">     * map:4</span></span><br><span class="line"><span class="comment">     * map:4</span></span><br><span class="line"><span class="comment">     * Collection test...</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    collectionTest()</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 输出结果为：</span></span><br><span class="line"><span class="comment">     * Sequence test...</span></span><br><span class="line"><span class="comment">     * filter:The</span></span><br><span class="line"><span class="comment">     * filter:quick</span></span><br><span class="line"><span class="comment">     * map:5</span></span><br><span class="line"><span class="comment">     * filter:brown</span></span><br><span class="line"><span class="comment">     * map:5</span></span><br><span class="line"><span class="comment">     * filter:fox</span></span><br><span class="line"><span class="comment">     * filter:jumps</span></span><br><span class="line"><span class="comment">     * map:5</span></span><br><span class="line"><span class="comment">     * filter:over</span></span><br><span class="line"><span class="comment">     * map:4</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    sequenceTest()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的代码中可以总结到：<strong><code>Collection</code>会执行每个操作步骤并返回并保存在中间集合，然后再根据中间集合执行下一个操作，而<code>Sequence</code>的多步处理在可能的情况下会延迟执行，仅当对整个处理链请求结果时才真正执行，并且<code>Sequence</code>是对每一个元素逐个执行所有的操作</strong>。<code>Sequence</code>的这种特性是通过共享同一个迭代器而实现的。</p><h2id="sequence与collection如何抉择">Sequence与Collection如何抉择？</h2><p>那么，在面对数据集的时候，是选择<code>Sequence</code>还是<code>Collection</code>？我们大致可以遵循下面的准则来进行抉择：</p><ol type="1"><li>是否包含<code>first&#123;&#125;</code>或者<code>last&#123;&#125;</code>操作，如果是则选择<code>Sequence</code>，否则请看下一条。</li><li>数据集中是否包含大量的元素，如果包含大量元素选择<code>Sequence</code>，否则请看下一条。</li><li>是否需要进行多次操作，如果需要则选择<code>Sequence</code>，否则选择<code>Collection</code>。</li></ol>]]></content>
    
    
    <summary type="html">&lt;h1
id=&quot;kotlin中的sequence与collection&quot;&gt;Kotlin中的Sequence与Collection&lt;/h1&gt;
&lt;p&gt;&lt;code&gt;Kotlin&lt;/code&gt;除了为我们提供了一般的集合类型(如&lt;code&gt;List&lt;/code&gt;、&lt;code&gt;Set&lt;/code&gt;、&lt;code&gt;Map&lt;/code&gt;)之外，还为我们提供了另一种容器类型：&lt;code&gt;Sequence&lt;/code&gt;(序列)。&lt;strong&gt;不同于&lt;code&gt;Collection&lt;/code&gt;的立即执行，&lt;code&gt;Sequence&lt;/code&gt;是延迟执行的&lt;/strong&gt;，例如下面的例子：&lt;/p&gt;
&lt;figure class=&quot;highlight kotlin&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;val&lt;/span&gt; sequence = listOf(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;).asSequence()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//这里不会有任何的打印信息，因为filter和map操作还没有被执行&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    sequence.filter &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        println(&lt;span class=&quot;string&quot;&gt;&amp;quot;filter:&lt;span class=&quot;variable&quot;&gt;$it&lt;/span&gt;&amp;quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        it % &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt; == &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;.map &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        println(&lt;span class=&quot;string&quot;&gt;&amp;quot;map:&lt;span class=&quot;variable&quot;&gt;$it&lt;/span&gt;&amp;quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;string&quot;&gt;&amp;quot;&lt;span class=&quot;variable&quot;&gt;$it&lt;/span&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;正是由于这种延迟执行的特性，在对数据集中的元素进行链式操作时(例如&lt;code&gt;map&lt;/code&gt;
、&lt;code&gt;filter&lt;/code&gt;等)，使用&lt;code&gt;Sequence&lt;/code&gt;可以变得更加高效，因为在这种情况下，不需要像普通集合那样，每进行一次数据操作，都必须要开辟新的内存来存储中间结果，而实际上在大多数情况下，我们并不关心中间结果，而只需要最终的结果。&lt;/p&gt;</summary>
    
    
    
    <category term="Kotlin" scheme="https://sachil.xyz/categories/Kotlin/"/>
    
    
    <category term="Kotlin" scheme="https://sachil.xyz/tags/Kotlin/"/>
    
    <category term="Sequence" scheme="https://sachil.xyz/tags/Sequence/"/>
    
    <category term="Collection" scheme="https://sachil.xyz/tags/Collection/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin中的密封类</title>
    <link href="https://sachil.xyz/posts/1ead3946/"/>
    <id>https://sachil.xyz/posts/1ead3946/</id>
    <published>2020-07-04T03:50:47.000Z</published>
    <updated>2023-06-20T15:46:03.207Z</updated>
    
    <content type="html"><![CDATA[<h1 id="kotlin中的密封类">Kotlin中的密封类</h1><p>密封类可以限制子类的类型，表示受限的继承结构，在某种意义上它是枚举类的扩展，但是相对于枚举类来说，密封类更加灵活：</p><ul><li>枚举类(Enumclass)，通常来说它代表意思是实例可数，每一个枚举常量都是枚举类的一个实例，可以直接使用，比如红、黄、蓝三种颜色</li><li>密封类(Sealedclass),通常来说它代表的意思是子类可数，你可以为不同的子类定义不同的属性和方法，并且你可以根据需要来对其动态实例化。</li></ul><span id="more"></span><h2 id="密封类对比枚举类">密封类对比枚举类</h2><p>在枚举类中，每一个枚举常量只能有一个实例：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">Colors</span></span>(<span class="keyword">var</span> alias:String)&#123;</span><br><span class="line">    RED(<span class="string">&quot;红&quot;</span>),</span><br><span class="line">    YELLOW(<span class="string">&quot;黄&quot;</span>),</span><br><span class="line">    BLUE(<span class="string">&quot;蓝&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> color1 = Colors.RED</span><br><span class="line">    <span class="comment">//编译器报错,不能创建多个实例</span></span><br><span class="line">    <span class="comment">//val color2 = Colors.RED(&quot;赤&quot;)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而密封类的子类可以有包含不同状态的多个实例：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sealed</span> <span class="class"><span class="keyword">class</span> <span class="title">Color</span></span>(<span class="keyword">var</span> alias: String)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Red</span></span>(alias: String=<span class="string">&quot;红&quot;</span>):Color(alias)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Yellow</span></span>(alias: String=<span class="string">&quot;黄&quot;</span>):Color(alias)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Blue</span></span>(alias: String=<span class="string">&quot;蓝&quot;</span>):Color(alias)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">//创建了密封类子类Red的多个实例</span></span><br><span class="line">    <span class="keyword">val</span> color1 = Red()</span><br><span class="line">    <span class="keyword">val</span> color2 = Red(<span class="string">&quot;赤&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>密封类相对于枚举类最大的不同是：密封类的子类可以拥有只属于自己的属性和方法，而枚举类却做不到，每一个枚举值都拥有相同的属性和方法：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用DeliveryState来表示快递的状态，</span></span><br><span class="line"><span class="comment"> * PREPARING表示正在准备，</span></span><br><span class="line"><span class="comment"> * DISPATCHED表示正在派送，</span></span><br><span class="line"><span class="comment"> * DELIVERED表示已送达</span></span><br><span class="line"><span class="comment"> * cancelOrder方法用来取消快递，并显示原因</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">DeliveryState</span></span>(<span class="keyword">val</span> trackId: String?) &#123;</span><br><span class="line">    PREPARING(<span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">cancelOrder</span><span class="params">()</span></span> &#123;</span><br><span class="line">            println(<span class="string">&quot;canceled successfully.&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    DISPATCHED(<span class="string">&quot;TI123456&quot;</span>) &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">cancelOrder</span><span class="params">()</span></span> &#123;</span><br><span class="line">            println(<span class="string">&quot;Delivery rejected.&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    DELIVERED(<span class="string">&quot;TI123456&quot;</span>) &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">cancelOrder</span><span class="params">()</span></span> &#123;</span><br><span class="line">            println(<span class="string">&quot;Return initialed.&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">abstract</span> <span class="function"><span class="keyword">fun</span> <span class="title">cancelOrder</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DeliveryManager</span></span>() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">cancelOrder</span><span class="params">(deliveryState: <span class="type">DeliveryState</span>)</span></span> &#123;</span><br><span class="line">        deliveryState.cancelOrder()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码中，<code>DeliveryState</code>的所有枚举值都拥有属性<code>trackId</code>，但是在PREPARING状态，<code>trackId</code>是没有作用的，但是我们不得不传递一个null给它。同样的，所有枚举值都拥有<code>cancelOrde</code>r方法，但是我们从这个方法的名称上无法直观的感受到cancel的原因。所以在枚举类型中不同的枚举值不能拥有各自的属性或者方法。</p><p>密封类可以用来打破这个限制，下面的代码是对上面例子的优化：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sealed</span> <span class="class"><span class="keyword">class</span> <span class="title">DeliveryState</span></span>()</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Preparing</span></span>() : DeliveryState() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">cancelOrder</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;canceled successfully.&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dispatched</span></span>(trackId: String) : DeliveryState() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">rejectDelivery</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;Delivery rejected.&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Delivered</span></span>(trackId: String, receiverName: String) : DeliveryState() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">returnItem</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;Return initialed.&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DeliveryManager</span></span>() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">cancelOrder</span><span class="params">(deliveryState: <span class="type">DeliveryState</span>)</span></span> = <span class="keyword">when</span> (deliveryState) &#123;</span><br><span class="line">        <span class="keyword">is</span> Preparing -&gt; deliveryState.cancelOrder()</span><br><span class="line">        <span class="keyword">is</span> Dispatched -&gt; deliveryState.rejectDelivery()</span><br><span class="line">        <span class="keyword">is</span> Delivered -&gt; deliveryState.returnItem()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们为密封类<code>DeliveryState</code>定义了不同的子类，并且每个子类都拥有不同的属性和方法，这样代码变得更加的清晰明了。</p><h2 id="总结">总结</h2><p>归纳一下，枚举类和密封类有以下这些地方的不同：</p><ul><li>枚举类通常表示实例可数；密封类通常表示子类可数。</li><li>枚举类的枚举值只能有一个实例；密封类的子类可以有多个实例。</li><li>枚举类的枚举值拥有相同的属性和方法；密封类的子类可以拥有不同的属性和方法。</li><li>枚举类的枚举值不能被继承，枚举类是隐式final的也不能被继承；密封类的子类是能被继承的，密封类当然也能被继承。</li><li>枚举类不能继承其它类，只能实现接口(原因是枚举类默认继承<code>Enum</code>类，单继承限制)；密封类既能继承其它类也能实现接口。</li><li>枚举类的枚举值会自动拥有<code>equals</code>、<code>hashCode</code>、<code>toString</code>、<code>Serializable</code>以及<code>Compareable</code>；而密封类的子类除非被声明为数据类，否则这些都需要手动实现。</li><li>枚举类在App生命周期期间常驻在内存，不会触发垃圾回收，所以在when表达式中，枚举类的性能高于密封类</li></ul><p>最后需要注意的是：密封类是抽象的，不能被实例化，在<code>Kotlin1.5</code>之前，密封类的子类必须和密封类在同一文件中(从<code>Kotlin1.1</code>开始)或者直接定义在密封类内部，从<code>Kotlin1.5</code>开始，密封类的子类需要和密封类在同一moudle中。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;kotlin中的密封类&quot;&gt;Kotlin中的密封类&lt;/h1&gt;
&lt;p&gt;密封类可以限制子类的类型，表示受限的继承结构，在某种意义上它是枚举类的扩展，但是相对于枚举类来说，密封类更加灵活：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;枚举类(Enum
class)，通常来说它代表意思是实例可数，每一个枚举常量都是枚举类的一个实例，可以直接使用，比如红、黄、蓝三种颜色&lt;/li&gt;
&lt;li&gt;密封类(Sealed
class),通常来说它代表的意思是子类可数，你可以为不同的子类定义不同的属性和方法，并且你可以根据需要来对其动态实例化。&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="Kotlin" scheme="https://sachil.xyz/categories/Kotlin/"/>
    
    
    <category term="Kotlin" scheme="https://sachil.xyz/tags/Kotlin/"/>
    
    <category term="密封类" scheme="https://sachil.xyz/tags/Sealed-Class/"/>
    
    <category term="枚举类" scheme="https://sachil.xyz/tags/Enum-Class/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin中的内联类</title>
    <link href="https://sachil.xyz/posts/8e647fe3/"/>
    <id>https://sachil.xyz/posts/8e647fe3/</id>
    <published>2020-06-20T03:31:26.000Z</published>
    <updated>2023-06-20T15:46:03.207Z</updated>
    
    <content type="html"><![CDATA[<h1 id="kotlin中的内联类">Kotlin中的内联类</h1><h2 id="内联类带来的好处">内联类带来的好处</h2><p>内联类通常被认为是某种类型的包装器，但是区别于普通的包装器，它避免了额外的堆内存分配，减少了运行时的性能开销。我们通过下面的例子可以更好的理解这段话：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">MailScheduler</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">sendEmail</span><span class="params">(email:<span class="type">Email</span>,delay:<span class="type">Int</span>)</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们定义了一个<code>MailScheduler</code>接口，用于在未来某个时间点发送一封Email，但是这儿有一个疑惑，我们不确定<code>delay</code>得单位，是天、小时还是分钟呢？或许我们可以将<code>sendEmail</code>的参数名称由<code>delay</code>更改为<code>delayDays</code>，由此来提醒接口的调用者，但是这仍然存在隐患。例如我们需要一天后发送Email，所以这样调用：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">send</span><span class="params">(email: <span class="type">Email</span>)</span></span> &#123;</span><br><span class="line">    mailScheduler.sendEmail(email, <span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但仍然可能有粗心的调用者，他并没有查看接口参数的名称，同时将它的单位认为是秒，所以他这样调用：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">send</span><span class="params">(email: <span class="type">Email</span>)</span></span> &#123;</span><br><span class="line">    mailScheduler.sendEmail(email, <span class="number">1</span>*<span class="number">24</span>*<span class="number">60</span>*<span class="number">60</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样和我们的预期就完全不同了。当然我们可以为<code>delay</code>定义一个包装器，就像这样：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Days</span></span>(<span class="keyword">val</span> value: <span class="built_in">Int</span>) </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">MailScheduler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">sendEmail</span><span class="params">(email: <span class="type">Email</span>, delay: <span class="type">Days</span>)</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是在通常情况下，我们并不会这样做。这是因为当我们创建一个基本类型的局部变量的时候，如Int、Float、Boolean，这些值被存放在JVM内存的栈中，所涉及的性能开销也是较小的，但是当我们实例化一个对象的时候，这个对象是存放在JVM内存的堆中，而在堆中分配空间，代价是比较昂贵的，会引起一定的性能损失。</p><p>为了在不损耗性能的同时又具有强类型检查，<code>Kotlin</code>为我们提供了内联类。</p><span id="more"></span><h2 id="内联类的声明和限制">内联类的声明和限制</h2><p>声明一个内联类非常简单：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在Kotlin 1.4.30及其以前的版本，使用inline class来声明</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">inline</span> <span class="class"><span class="keyword">class</span> <span class="title">Days</span></span>(<span class="keyword">private</span> <span class="keyword">val</span> value: <span class="built_in">Int</span>) &#123;</span><br><span class="line">    <span class="keyword">val</span> name: String</span><br><span class="line">        <span class="keyword">get</span>() = <span class="string">&quot;<span class="variable">$value</span> days&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">toHours</span><span class="params">()</span></span>: <span class="built_in">Int</span> = value * <span class="number">24</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从Kotlin 1.4.30开始，使用value class来声明</span></span><br><span class="line"><span class="comment"> * 同时对于JVM平台，<span class="doctag">@JvmInline</span>注解是必须的</span></span><br><span class="line"><span class="comment"> * 从Kotlin 1.5.0开始，inline class已经被废弃</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@JvmInline</span></span><br><span class="line">value <span class="class"><span class="keyword">class</span> <span class="title">Days</span></span>(<span class="keyword">private</span> <span class="keyword">val</span> value: <span class="built_in">Int</span>) &#123;</span><br><span class="line">    <span class="keyword">val</span> name: String</span><br><span class="line">        <span class="keyword">get</span>() = <span class="string">&quot;<span class="variable">$value</span> days&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">toHours</span><span class="params">()</span></span>: <span class="built_in">Int</span> = value * <span class="number">24</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>内联类有以下这些限制：</p><ul><li>内联类的主构造函数中有且只有一个val属性，不能是var属性</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@JvmInline</span> value <span class="class"><span class="keyword">class</span> <span class="title">Days</span></span>(value: <span class="built_in">Int</span>) <span class="comment">//错误，必须是属性</span></span><br><span class="line"><span class="meta">@JvmInline</span> value <span class="class"><span class="keyword">class</span> <span class="title">Days</span></span>(<span class="keyword">var</span> value: <span class="built_in">Int</span>) <span class="comment">//错误，必须是只读属性</span></span><br><span class="line"><span class="meta">@JvmInline</span> value <span class="class"><span class="keyword">class</span> <span class="title">Days</span></span>(<span class="keyword">val</span> value: <span class="built_in">Int</span>,<span class="keyword">val</span> name:String) <span class="comment">//错误，只能有一个属性</span></span><br></pre></td></tr></table></figure><ul><li>内联类不能含有幕后字段。</li><li>在<code>Kotlin</code>1.4.30以前，内联类不能含有init代码块，从<code>Kotlin</code>1.4.30开始则可以含有init代码块。</li><li>内联类只能实现接口，不能继承其它类，内联类也不能被继承。</li><li>内联类可以声明为嵌套类，但是不能声明为内部类，内联类也不能声明在函数内部。</li><li>由于内联类既可以表示为基础类型又可以表示为包装器，所以引用相等的判断毫无意义并不被允许。</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> days1 = Days(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">val</span> days2 = Days(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> isSameObject = days1 === days2 <span class="comment">//错误，没有意义</span></span><br></pre></td></tr></table></figure><ul><li>从<code>Kotlin</code>1.4.30开始，可以在Java中调用接受内联类参数的函数.</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@JvmInline</span></span><br><span class="line">value <span class="class"><span class="keyword">class</span> <span class="title">Days</span></span>(<span class="keyword">val</span> value: <span class="built_in">Int</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@JvmName(<span class="meta-string">&quot;Days&quot;</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">sendEmail</span><span class="params">(email: <span class="type">Email</span>, delay: <span class="type">Days</span>)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>初看起来，内联类和类型别名非常相似，两者似乎都引入了一种新的类型，并且在运行的时候表示为基础类型。但是，<strong>内联类相较于类型别名来说有一个巨大的优势：内联类将提供类型的安全性</strong>。例如请看下面的例子：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typealias</span> UserName = String</span><br><span class="line"><span class="keyword">typealias</span> Password = String</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">auth</span><span class="params">(userName: <span class="type">UserName</span>, password: <span class="type">Password</span>)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> userName: UserName = <span class="string">&quot;Sachil&quot;</span></span><br><span class="line">    <span class="keyword">val</span> password: Password = <span class="string">&quot;123456&quot;</span></span><br><span class="line">    <span class="comment">//userName和password位置进行了对调，但编译仍然通过，类型别名不能防止这样的错误调用</span></span><br><span class="line">    auth(password, userName)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们同样使用内联类来实现：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@JvmInline</span></span><br><span class="line">value <span class="class"><span class="keyword">class</span> <span class="title">UserName</span></span>(<span class="keyword">val</span> value: String)</span><br><span class="line"></span><br><span class="line"><span class="meta">@JvmInline</span></span><br><span class="line">value <span class="class"><span class="keyword">class</span> <span class="title">Password</span></span>(<span class="keyword">val</span> value: String)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">auth</span><span class="params">(userName: <span class="type">UserName</span>, password: <span class="type">Password</span>)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> userName: UserName = UserName(<span class="string">&quot;Sachil&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> password: Password = Password(<span class="string">&quot;123456&quot;</span>)</span><br><span class="line">    <span class="comment">//编译错误，内联类可以检查出这样的错误调用</span></span><br><span class="line">    auth(password, userName)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="内联类的自动装箱">内联类的自动装箱</h2><p><code>Kotlin</code>为每一个内联类保留一个包装器，内联类的实例在运行的时候可以表示为基础类型或者包装器，为了性能的最优化，<strong><code>Kotlin</code>尽可能的将内联类表示为基础类型，否则表示为包装器</strong>。一般以下几种情况下，内联类会表示为包装器并自动装箱：</p><ul><li>当被作为父类的引用时</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Score</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">@JvmInline</span></span><br><span class="line">value <span class="class"><span class="keyword">class</span> <span class="title">Points</span></span>(<span class="keyword">val</span> value: <span class="built_in">Int</span>) : Score</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">printScore</span><span class="params">(score: <span class="type">Score</span>)</span></span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> points = Points(<span class="number">1</span>)</span><br><span class="line">    printScore(points) <span class="comment">// Points表示为包装器，自动装箱</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>当用作泛型类型时</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@JvmInline</span></span><br><span class="line">value <span class="class"><span class="keyword">class</span> <span class="title">Points</span></span>(<span class="keyword">val</span> value: <span class="built_in">Int</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> points = Points(<span class="number">5</span>)</span><br><span class="line">    <span class="keyword">val</span> list = listOf(points) <span class="comment">// Points表示为包装器，自动装箱</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>当参与空检查时，空检查会在两个地方发生，一是在定义内联类的时候，基础类型是否为空，另一个地方是在使用内联类的时候，内联类其本身是否为空，例如：</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义内联类的时候，基础类型是否为空</span></span><br><span class="line"><span class="meta">@JvmInline</span></span><br><span class="line">value <span class="class"><span class="keyword">class</span> <span class="title">Points</span></span>(<span class="keyword">val</span> value: <span class="built_in">Int</span>?)</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用内联类的时候，其本身是否为空</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">printPoints</span><span class="params">(points: <span class="type">Points</span>?)</span></span> &#123;&#125;</span><br></pre></td></tr></table></figure><p>这两个地方的空检查组合起来一共可以分为4种情况，但是对于内联类的基础类型是引用类型还是基本类型，这4中情况又有一些区别：</p><ol type="1"><li>当内联类的基础类型为引用类型时：</li></ol><figure><imgsrc="https://gitee.com/sachil/blog-pictures/raw/master/image/inline_class_1.png"alt="inline_class_1" /><figcaption aria-hidden="true">inline_class_1</figcaption></figure><p>我们可以从上图观察到，当内联类的基础类型为引用类型时，只有当这两个地方都可能为空的时候，内联类才会表示为包装器，并自动装箱。</p><ol type="1"><li>当内联类的基础类型为基本类型时：</li></ol><figure><imgsrc="https://gitee.com/sachil/blog-pictures/raw/master/image/inline_class_2.png"alt="inline_class_2" /><figcaption aria-hidden="true">inline_class_2</figcaption></figure><p>从上图可以观察到，当内联类的基础类型为基本类型时，只有当内联类被使用时其本身为空的时候，内联类才会表示为包装器并自动装箱。</p><hr /><p>参考文章：</p><p><ahref="https://typealias.com/guides/introduction-to-inline-classes/">AnIntroduction to Inline Classes (Updated for Kotlin 1.5)</a></p><p><ahref="https://typealias.com/guides/inline-classes-and-autoboxing/">InlineClasses and Autoboxing (Updated for Kotlin 1.5)</a></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;kotlin中的内联类&quot;&gt;Kotlin中的内联类&lt;/h1&gt;
&lt;h2 id=&quot;内联类带来的好处&quot;&gt;内联类带来的好处&lt;/h2&gt;
&lt;p&gt;内联类通常被认为是某种类型的包装器，但是区别于普通的包装器，它避免了额外的堆内存分配，减少了运行时的性能开销。我们通过下面的例子可以更好的理解这段话：&lt;/p&gt;
&lt;figure class=&quot;highlight kotlin&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;MailScheduler&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;sendEmail&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(email:&lt;span class=&quot;type&quot;&gt;Email&lt;/span&gt;,delay:&lt;span class=&quot;type&quot;&gt;Int&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;我们定义了一个&lt;code&gt;MailScheduler&lt;/code&gt;接口，用于在未来某个时间点发送一封Email，但是这儿有一个疑惑，我们不确定&lt;code&gt;delay&lt;/code&gt;得单位，是天、小时还是分钟呢？或许我们可以将&lt;code&gt;sendEmail&lt;/code&gt;的参数名称由&lt;code&gt;delay&lt;/code&gt;更改为&lt;code&gt;delayDays&lt;/code&gt;，由此来提醒接口的调用者，但是这仍然存在隐患。例如我们需要一天后发送Email，所以这样调用：&lt;/p&gt;
&lt;figure class=&quot;highlight kotlin&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;send&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(email: &lt;span class=&quot;type&quot;&gt;Email&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    mailScheduler.sendEmail(email, &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;但仍然可能有粗心的调用者，他并没有查看接口参数的名称，同时将它的单位认为是秒，所以他这样调用：&lt;/p&gt;
&lt;figure class=&quot;highlight kotlin&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;send&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(email: &lt;span class=&quot;type&quot;&gt;Email&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    mailScheduler.sendEmail(email, &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;*&lt;span class=&quot;number&quot;&gt;24&lt;/span&gt;*&lt;span class=&quot;number&quot;&gt;60&lt;/span&gt;*&lt;span class=&quot;number&quot;&gt;60&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这样和我们的预期就完全不同了。当然我们可以为&lt;code&gt;delay&lt;/code&gt;定义一个包装器，就像这样：&lt;/p&gt;
&lt;figure class=&quot;highlight kotlin&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Days&lt;/span&gt;&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;val&lt;/span&gt; value: &lt;span class=&quot;built_in&quot;&gt;Int&lt;/span&gt;) &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;MailScheduler&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;sendEmail&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(email: &lt;span class=&quot;type&quot;&gt;Email&lt;/span&gt;, delay: &lt;span class=&quot;type&quot;&gt;Days&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;但是在通常情况下，我们并不会这样做。这是因为当我们创建一个基本类型的局部变量的时候，如Int、Float、Boolean，这些值被存放在JVM内存的栈中，所涉及的性能开销也是较小的，但是当我们实例化一个对象的时候，这个对象是存放在JVM内存的堆中，而在堆中分配空间，代价是比较昂贵的，会引起一定的性能损失。&lt;/p&gt;
&lt;p&gt;为了在不损耗性能的同时又具有强类型检查，&lt;code&gt;Kotlin&lt;/code&gt;为我们提供了内联类。&lt;/p&gt;</summary>
    
    
    
    <category term="Kotlin" scheme="https://sachil.xyz/categories/Kotlin/"/>
    
    
    <category term="Kotlin" scheme="https://sachil.xyz/tags/Kotlin/"/>
    
    <category term="内联类" scheme="https://sachil.xyz/tags/Inline-Class/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin的内联函数</title>
    <link href="https://sachil.xyz/posts/93d266b8/"/>
    <id>https://sachil.xyz/posts/93d266b8/</id>
    <published>2020-06-13T06:29:40.000Z</published>
    <updated>2023-06-20T15:46:03.207Z</updated>
    
    <content type="html"><![CDATA[<h1 id="kotlin的内联函数">Kotlin的内联函数</h1><p>众所周知，在<code>Java</code>中有一种被称之为<code>编译期常量</code>的变量，它是用来进行编译优化处理的，这种变量的类型只能是基本类型或者字符串类型，使用<code>static final</code>来进行声明，并且在声明的时候需要同时初始化，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> PI = <span class="number">3.145926F</span></span><br></pre></td></tr></table></figure><p>在编译的时候，编译器会将所有对<code>PI</code>的引用替换成实际的字面量(即3.145926)。在<code>Kotlin</code>中，同样存在<code>编译期常量</code>,限制条件也基本和<code>Java</code>相似，使用<code>const val</code>来进行声明，例如：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">val</span> PI:<span class="built_in">Float</span> = <span class="number">3.145926F</span></span><br></pre></td></tr></table></figure><p>这样，在调用<code>PI</code>的时候，编译器也会直接使用实际的值来进行替换。这种在调用的地方进行实际替换或者扩展的行为被称为<strong>内联</strong>，除了变量之外，函数也可以声明为内联的方式，这样就是内联函数，内联函数在函数被调用的地方会直接进行展开，从而不用像调用普通函数那样进行压栈出栈。</p><p>在<code>Java</code>中不支持直接声明内联函数，但是你可以使用<code>final</code>修饰符来声明一个函数，从而向编译期来请求让这个函数成为内联函数，最后结果是由编译器决定的。在<code>Koltin</code>中有了对内联函数的直接支持，那就是使用<code>inline</code>修饰符。</p><span id="more"></span><h2 id="内联函数的作用">内联函数的作用</h2><p>声明一个函数为内联函数非常简单，使用<code>inline</code>关键字就可以了。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明为内联函数</span></span><br><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="title">sayHello</span><span class="params">()</span></span> &#123;</span><br><span class="line">    println(<span class="string">&quot;Hello world!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">//内联函数会在调用的时候展开</span></span><br><span class="line">    <span class="comment">//这里就相当于println(&quot;Hello world!&quot;)</span></span><br><span class="line">    sayHello()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>内联函数在被调用的时候，会被直接展开，从而省去出入栈的操作，效率会有所提升，但是不要过分夸大这种提升，其实像上面代码那样，提升的程度是微乎其微的。同时它可能还会带来副作用，比如在你的程序中存在很多内联函数的调用，这些内联函数扩展之后，必然会让程序的字节码增多，从而让程序体积变得臃肿，这样就成了负优化了。所以在什么时候，才真正的需要使用内联函数呢？</p><h2 id="使用内联函数的时机">使用内联函数的时机</h2><p>在<code>Kotlin</code>中有一种<code>Java</code>中没有的概念：<strong>高阶函数</strong>（也就是函数的参数类型或者返回值类型为函数的函数），我们也知道，在对高阶函数进行传递参数或者返回的时候，实际传递或者返回的是一个函数类型的对象，但是在<code>Java</code>中并没有对函数类型变量的原生支持，所以<code>Kotlin</code>为了让这个新引入的概念在<code>JVM</code>中能够使用，它会创建一个<code>JVM</code>的对象来作为函数类型变量的载体，让这个对象去执行实际的代码。例如：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Kotlin</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">sayHello</span><span class="params">(sayBye:()-&gt;<span class="type">Unit</span>)</span></span>&#123;</span><br><span class="line">    println(<span class="string">&quot;Hello...&quot;</span>)</span><br><span class="line">    sayBye()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    sayHello &#123;</span><br><span class="line">        println(<span class="string">&quot;Bye bye...&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的<code>Kotlin</code>代码反编译成<code>Java</code>代码为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">KotlinTestKt</span> </span>&#123;</span><br><span class="line">    <span class="comment">//可以看到，这里的参数是一个Function0类型的对象</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(<span class="meta">@NotNull</span> Function0 sayBye)</span> </span>&#123;</span><br><span class="line">      Intrinsics.checkNotNullParameter(sayBye, <span class="string">&quot;sayBye&quot;</span>);</span><br><span class="line">      String var1 = <span class="string">&quot;Hello...&quot;</span>;</span><br><span class="line">      <span class="keyword">boolean</span> var2 = <span class="keyword">false</span>;</span><br><span class="line">      System.out.println(var1);</span><br><span class="line">      sayBye.invoke();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      sayHello((Function0)<span class="keyword">null</span>.INSTANCE);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// $FF: synthetic method</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] var0)</span> </span>&#123;</span><br><span class="line">      main();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到在代码中<code>sayHello</code>方法传入的是一个<code>Function0</code>类型的对象，然后再调用这个对象的<code>invoke</code>方法去执行实际的操作。创建一个对象这本就是一个稀松平常的事，并不会引起性能问题，但是如果我们多次调用这个高阶函数呢，例如：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">sayHello</span><span class="params">(sayBye: () -&gt; <span class="type">Unit</span>)</span></span> &#123;</span><br><span class="line">    println(<span class="string">&quot;Hello...&quot;</span>)</span><br><span class="line">    sayBye()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    repeat(<span class="number">1000</span>) &#123;</span><br><span class="line">        sayHello &#123;</span><br><span class="line">            println(<span class="string">&quot;Bye bye...&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的代码中，需要创建1000个这样的临时对象，这样就会引起性能问题了，但是我们又不能限制<code>sayHello</code>函数应该以何种方式来被使用。这样，高阶函数就可能存在性能隐患了。在这种情况下，内联函数就可以起到很大的作用了。<strong><code>inline</code>关键字不仅可以内联函数本身，也可以内联函数本身的函数类型参数</strong>，例如：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明为内联函数</span></span><br><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="title">sayHello</span><span class="params">(sayBye: () -&gt; <span class="type">Unit</span>)</span></span> &#123;</span><br><span class="line">    println(<span class="string">&quot;Hello...&quot;</span>)</span><br><span class="line">    sayBye()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    repeat(<span class="number">1000</span>) &#123;</span><br><span class="line">        sayHello &#123;</span><br><span class="line">            println(<span class="string">&quot;Bye bye...&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//在sayHello被声明为内联函数之后，</span></span><br><span class="line">    <span class="comment">//上面的循环调用，其实就相当于下面这样调用了</span></span><br><span class="line">    repeat(<span class="number">1000</span>) &#123;</span><br><span class="line">        println(<span class="string">&quot;Hello...&quot;</span>)</span><br><span class="line">        println(<span class="string">&quot;Bye bye...&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上面代码所示，这样一展开，就避免了函数类型参数的临时对象的创建，就不存在性能隐患了。所以我们可以轻松的得出一个结论：<strong>在你声明一个高阶函数的时候，为了避免该函数的性能隐患，请加上<code>inline</code>关键字，让其成为内联函数</strong>。当然，如果对包大小有严格要求的话，可以酌情使用<code>inline</code>，比如只让会被高频调用的高阶函数称为内联函数。</p><h2 id="noinline和crossinline">noinline和crossinline</h2><p><code>inline</code>关键字是内联的意思，<code>noinline</code>就是禁止内联的意思，不过<code>noinline</code>不是用来修饰函数的，而是用来修饰函数类型的参数的。那么<code>noinlie</code>到底有什么用呢？当我们在一个内联的高阶函数内，如果把一个函数类型的参数当做对象来使用的话，编译器会报错，例如在<code>return</code>中返回：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="title">sayHello</span><span class="params">(sayBye: () -&gt; <span class="type">Unit</span>)</span></span>: () -&gt; <span class="built_in">Unit</span> &#123;</span><br><span class="line">    println(<span class="string">&quot;Hello...&quot;</span>)</span><br><span class="line">    <span class="comment">//这里编译器会报错，提示我们不能这样使用</span></span><br><span class="line">    <span class="keyword">return</span> sayBye</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为当我们把函数进行内联的时候，这些函数类型的参数就不再是对象了，它们会被编译器在调用处直接展开，所以并不会为函数类型的参数创建对象，所以在内联函数内把函数类型的参数作为对象使用，因为这个对象根本就不存在。</p><p>但是如果真的有这种需求呢，那么就可以使用<code>noinline</code>关键字，来让函数类型的参数禁止内联，例如：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用noinlie修饰参数sayBye</span></span><br><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="title">sayHello</span><span class="params">(getName: () -&gt; <span class="type">String</span>, <span class="keyword">noinline</span> sayBye: () -&gt; <span class="type">Unit</span>)</span></span>: () -&gt; <span class="built_in">Unit</span> &#123;</span><br><span class="line">    println(<span class="string">&quot;<span class="subst">$&#123;getName()&#125;</span> say:Hello...&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> sayBye</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    sayHello(&#123;</span><br><span class="line">        <span class="string">&quot;Sachil&quot;</span></span><br><span class="line">    &#125;, &#123;</span><br><span class="line">        println(<span class="string">&quot;Goodbye...&quot;</span>)</span><br><span class="line">    &#125;)()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="非局部返回和局部返回">非局部返回和局部返回</h3><p>还有一个关键字<code>crossinline</code>可以用来修饰函数类型的参数，它是加强内联的意思。想要更深层的理解它的作用，我们需要先了解<strong>局部返回</strong>和<strong>非局部返回</strong>，先看下面的代码：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sachil</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="title">saySomething</span><span class="params">(something: () -&gt; <span class="type">Unit</span>)</span></span> &#123;</span><br><span class="line">    something()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">    saySomething &#123;</span><br><span class="line">        println(<span class="string">&quot;Hello world!&quot;</span>)</span><br><span class="line">        <span class="comment">//这里的lambda表达式中，加上了一个return</span></span><br><span class="line">        <span class="comment">//那么这个return，返回的是哪一个函数呢？</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    println(<span class="string">&quot;Test id done.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">//输出：Hello world！</span></span><br><span class="line">    test()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码在<code>test</code>函数中调用过了<code>saySomething</code>函数，并给它传递了一个<code>Lambda表达式</code>，在这个表达式中，我们在其结束的时候加上了一个裸的<code>return</code>，这个<code>return</code>返回的是哪一个函数呢，是<code>saySomething</code>函数，还是<code>test</code>函数？按照通常的理解，这个<code>return</code>应该返回的是<code>saySomething</code>函数，但是其实并不是这样的，它会返回<code>test</code>函数，也就是说这个<code>Lambda表达式</code>中的<code>return</code>返回的是调用这个内联函数的函数，像这样的返回行为就被称之为<strong>非局部返回</strong>。造成这样结果的原因其实也很简单，因为在调用内联函数的时候函数类型参数也会被展开，在<code>saySomething</code>函数被展开后，<code>test</code>函数看起来就像是这样：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="title">saySomething</span><span class="params">(something: () -&gt; <span class="type">Unit</span>)</span></span> &#123;</span><br><span class="line">    something()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">//saySomething被展开后</span></span><br><span class="line">    println(<span class="string">&quot;Hello world!&quot;</span>)</span><br><span class="line">    <span class="comment">//可以轻易的知道这个return返回的是test函数</span></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    println(<span class="string">&quot;Test id done.&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>所以对于内联函数，它的参数中的<code>Lambda表达式</code>中的<code>return</code>返回的不是这个内联函数，而是调用这个内联函数的函数，也就是非局部返回。</strong>但这就造成了一个问题，我们想要知道一个<code>return</code>在一个<code>Lambda表达式</code>中的具体返回行为还得去看使用这个<code>Lambda表达式</code>作为参数的函数是不是内联函数，这样就变得很困惑。所以为了解决这个问题，<code>Kotlin</code>规定：<strong>只有在以<code>Labmda表达式</code>为参数的函数是内联函数的时候，才能在<code>Lambda表达式</code>中使用非局部返回的行为(也就是使用裸的return)。</strong>像这样的代码是无法编译的：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这不是一个内联函数</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">saySomething</span><span class="params">(something: () -&gt; <span class="type">Unit</span>)</span></span> &#123;</span><br><span class="line">    something()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">    saySomething &#123;</span><br><span class="line">        println(<span class="string">&quot;Hello world!&quot;</span>)</span><br><span class="line">        <span class="comment">//这里编译器会报错，因为saySomething不是内联函数</span></span><br><span class="line">        <span class="comment">//所以return无法实现非局部返回</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    println(<span class="string">&quot;Test id done.&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，与<code>非局部返回</code>对应的就是<code>局部返回</code>，在<code>Lambda表达式</code>中可以使用带标签的返回来结束该表达式，这样的返回行为就被称为<strong>局部返回</strong>，也可以通过匿名函数加默认不带标签的返回来实现局部返回。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">saySomething</span><span class="params">(something: () -&gt; <span class="type">Unit</span>)</span></span> &#123;</span><br><span class="line">    something()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">//Labmda表达式，使用标签来局部返回</span></span><br><span class="line">    saySomething &#123;</span><br><span class="line">        println(<span class="string">&quot;Hello world!&quot;</span>)</span><br><span class="line">        <span class="comment">//使用标签来从saySomething返回</span></span><br><span class="line">        <span class="keyword">return</span><span class="symbol">@saySomething</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//使用匿名函数+默认return的方式来实现局部返回</span></span><br><span class="line">    saySomething(<span class="function"><span class="title">fun</span><span class="params">()</span></span>&#123;</span><br><span class="line">        println(<span class="string">&quot;Hello world!&quot;</span>)</span><br><span class="line">        <span class="comment">//从saySomething返回</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">//这句代码会被执行</span></span><br><span class="line">    println(<span class="string">&quot;Test id done.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">//输出：Hello world!</span></span><br><span class="line">    <span class="comment">//Hello world!</span></span><br><span class="line">   <span class="comment">// Test id done.</span></span><br><span class="line">    test()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在理解了<code>局部返回</code>和<code>非局部返回</code>所代表的含义之后，我们就可以来看一看<code>crossinline</code>关键字了，先看一下下面的代码：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="title">say</span><span class="params">(bye:()-&gt;<span class="type">Unit</span>)</span></span>&#123;</span><br><span class="line">        <span class="comment">//报错，这里尝试在主线程调用bye</span></span><br><span class="line">        <span class="comment">//但是编译器会报错，编译器提示bye可能包含非局部返回</span></span><br><span class="line">        activity.runOnUiThread &#123;</span><br><span class="line">            bye()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        say &#123;</span><br><span class="line">            println(<span class="string">&quot;Goodbye...&quot;</span>)</span><br><span class="line">            <span class="comment">//这里使用非局部返回，从test返回</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        println(<span class="string">&quot;Test done.&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    test()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上面的代码会编译错误，原因是我们在内联函数<code>say</code>中，间接的调用了其函数类型的参数<code>bye</code>（也就是让<code>bye</code>在主线程上运行）。在这种情况下，在<code>test</code>函数中调用<code>say</code>的时候，其<code>Lambda表达式</code>中的<code>return</code>试图实现非局部返回，但是这段<code>Lambda表达式</code>却被包裹在<code>activity.runOnUiThread</code>中，也就是在其所在内联函数<code>say</code>中，它是被间接调用的，和内联函数本身失去了直接的联系，这样的非局部返回是无法实现的，所以编译器提示了编译错误。<strong><code>Kotlin</code>规定，默认情况下，内联函数的内部不能间接调用其函数类型参数(因为这个函数类型的参数可能包含非局部返回)。</strong></p><p>但是，在实际开发过程中，我们在内联函数内部可能真的需要间接调用其函数类型的参数，这该怎么办呢？使用<code>crossinline</code>来修饰这个函数类型的参数就可以了，但是使用了<code>crossinlie</code>之后，这个函数类型的参数就不能有非局部返回了。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="title">say</span><span class="params">(<span class="keyword">crossinline</span> bye:()-&gt;<span class="type">Unit</span>)</span></span>&#123;</span><br><span class="line">        <span class="comment">//编译器将不再会报错</span></span><br><span class="line">        activity.runOnUiThread &#123;</span><br><span class="line">            bye()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        say &#123;</span><br><span class="line">            println(<span class="string">&quot;Goodbye...&quot;</span>)</span><br><span class="line">            <span class="comment">//这里将不能再有非局部返回</span></span><br><span class="line">            <span class="comment">//return</span></span><br><span class="line">        &#125;</span><br><span class="line">        println(<span class="string">&quot;Test done.&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    test()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以使用<code>crossinlie</code>的时机就是：<strong>当你的内联函数内部需要间接调用其函数类型的参数的时候，用<code>crossinline</code>对该函数类型的参数进行修饰就可以了。</strong></p><h2 id="reified关键字">reified关键字</h2><p><code>reified</code>字面意思就是具体化，我们知道在<code>Java</code>中，泛型由于存在类型擦除的缘故，所以在运行时是不知道泛型的具体类型信息的，在<code>Kotlin</code>中也是同样如此。<code>Java</code>中的解决方案通常是额外传递一个<code>class&lt;T&gt;</code>的参数，然后通过<code>isInstance</code>方法来检查。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">checkType</span><span class="params">(Object obj, Class&lt;T&gt; type)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (type.isInstance(obj)) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Type is right.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        checkType(<span class="number">1</span>, Integer.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>Kotlin</code>同样可以这样来使用，不过还有一种更加简便的方法，那就是使用<code>reified</code>关键字+内联函数的方式，例如：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;<span class="keyword">reified</span> T&gt;</span> <span class="title">checkType</span><span class="params">(obj:<span class="type">Any</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(obj <span class="keyword">is</span> T)&#123;</span><br><span class="line">        println(<span class="string">&quot;Type is right&quot;</span>)</span><br><span class="line">    &#125;<span class="keyword">else</span></span><br><span class="line">        println(<span class="string">&quot;Type is wrong&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">//输出：Type is right</span></span><br><span class="line">    checkType&lt;<span class="built_in">Int</span>&gt;(<span class="number">1</span>)</span><br><span class="line">    <span class="comment">//输出：Type is wrong</span></span><br><span class="line">    checkType&lt;<span class="built_in">Int</span>&gt;(<span class="number">1.0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>reified</code>关键字搭配内联函数，可以让泛型类型的类型实参在运行时得以保留而不被擦除，这种行为在<code>Kotlin</code>中被称之为<strong>实化</strong>。我们已经知道了内联函数的原理，就是编译器会把实现内联函数的字节码动态的插入到其调用的地方，实化的原理正是基于内联函数的原理。<strong>每次调用带实化类型参数的函数时，编译器都知道此次调用中作为泛型类型实参的具体类型。所以编译器只要在每次调用时生成对应不同类型实参调用的字节码插入到调用点即可。</strong>例如下面的代码：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;<span class="keyword">reified</span> T : Number&gt;</span> <span class="title">printClass</span><span class="params">(param1: <span class="type">T</span>)</span></span> &#123;</span><br><span class="line">    println(<span class="string">&quot;<span class="subst">$&#123;T::class.java&#125;</span>&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    printClass(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在反编译为<code>Java</code>代码时，它大概是这样的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">printClass</span><span class="params">(Number param1)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">int</span> $i$f$printClass = <span class="number">0</span>;</span><br><span class="line">   Intrinsics.checkNotNullParameter(param1, <span class="string">&quot;param1&quot;</span>);</span><br><span class="line">   Intrinsics.reifiedOperationMarker(<span class="number">4</span>, <span class="string">&quot;T&quot;</span>);</span><br><span class="line">    <span class="comment">//这里使用了形参的上界约束Number</span></span><br><span class="line">   String var2 = String.valueOf(Number.class);</span><br><span class="line">   <span class="keyword">boolean</span> var3 = <span class="keyword">false</span>;</span><br><span class="line">   System.out.println(var2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">int</span> param1$iv = <span class="keyword">true</span>;</span><br><span class="line">   <span class="keyword">int</span> $i$f$printClass = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">//在实际调用的时候，根据此次调用的明确类型实参Integer.class替换了定义时的Number.class</span></span><br><span class="line">   String var2 = String.valueOf(Integer.class);</span><br><span class="line">   <span class="keyword">boolean</span> var3 = <span class="keyword">false</span>;</span><br><span class="line">   System.out.println(var2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在实际调用的时候，编译器根据此次调用的明确的类型实参(<code>Integer.class</code>)替换掉定义时的参数(<code>Number.class</code>)，这就解释了为什么<code>reified</code>必须搭配内联函数使用的原因了。所以当<code>Java</code>与<code>Kotlin</code>交互时，<strong><code>Java</code>不能调用<code>Kotlin</code>中的实化类型参数函数</strong>，这是因为在<code>Java</code>中调用<code>Koltin</code>中的普通内联函数的时候，会失去内联的功能。</p><hr /><p>参考文章：</p><p><ahref="https://juejin.cn/post/6844903701174288391">Kotlin的独门秘籍Reified实化类型参数(下篇)</a></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;kotlin的内联函数&quot;&gt;Kotlin的内联函数&lt;/h1&gt;
&lt;p&gt;众所周知，在&lt;code&gt;Java&lt;/code&gt;中有一种被称之为&lt;code&gt;编译期常量&lt;/code&gt;的变量，它是用来进行编译优化处理的，这种变量的类型只能是基本类型或者字符串类型，使用&lt;code&gt;static final&lt;/code&gt;来进行声明，并且在声明的时候需要同时初始化，例如：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//Java&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;float&lt;/span&gt; PI = &lt;span class=&quot;number&quot;&gt;3.145926F&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在编译的时候，编译器会将所有对&lt;code&gt;PI&lt;/code&gt;的引用替换成实际的字面量(即
3.145926)。在&lt;code&gt;Kotlin&lt;/code&gt;中，同样存在&lt;code&gt;编译期常量&lt;/code&gt;,限制条件也基本和&lt;code&gt;Java&lt;/code&gt;相似，使用&lt;code&gt;const val&lt;/code&gt;来进行声明，例如：&lt;/p&gt;
&lt;figure class=&quot;highlight kotlin&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;val&lt;/span&gt; PI:&lt;span class=&quot;built_in&quot;&gt;Float&lt;/span&gt; = &lt;span class=&quot;number&quot;&gt;3.145926F&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这样，在调用&lt;code&gt;PI&lt;/code&gt;的时候，编译器也会直接使用实际的值来进行替换。这种在调用的地方进行实际替换或者扩展的行为被称为&lt;strong&gt;内联&lt;/strong&gt;，除了变量之外，函数也可以声明为内联的方式，这样就是内联函数，内联函数在函数被调用的地方会直接进行展开，从而不用像调用普通函数那样进行压栈出栈。&lt;/p&gt;
&lt;p&gt;在&lt;code&gt;Java&lt;/code&gt;中不支持直接声明内联函数，但是你可以使用&lt;code&gt;final&lt;/code&gt;修饰符来声明一个函数，从而向编译期来请求让这个函数成为内联函数，最后结果是由编译器决定的。在&lt;code&gt;Koltin&lt;/code&gt;中有了对内联函数的直接支持，那就是使用&lt;code&gt;inline&lt;/code&gt;修饰符。&lt;/p&gt;</summary>
    
    
    
    <category term="Kotlin" scheme="https://sachil.xyz/categories/Kotlin/"/>
    
    
    <category term="Kotlin" scheme="https://sachil.xyz/tags/Kotlin/"/>
    
    <category term="Lambda表达式" scheme="https://sachil.xyz/tags/Lambda/"/>
    
    <category term="高阶函数" scheme="https://sachil.xyz/tags/High-Order-Function/"/>
    
    <category term="内联函数" scheme="https://sachil.xyz/tags/Inline-Functions/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin中的扩展函数与扩展属性</title>
    <link href="https://sachil.xyz/posts/4df1dcac/"/>
    <id>https://sachil.xyz/posts/4df1dcac/</id>
    <published>2020-06-07T07:26:07.000Z</published>
    <updated>2023-06-20T15:46:03.207Z</updated>
    
    <content type="html"><![CDATA[<h1 id="kotlin中的扩展函数与扩展属性">Kotlin中的扩展函数与扩展属性</h1><p>通常情况下，如果我们需要为一个已存在的类添加新的功能，但是在不能直接修改这个类的源码的时候，我们会选择创建一个这个类的子类来添加我们需要增加的功能。这种方式在我们写<code>Java</code>代码的时候经常使用，可以说是轻车熟路。在<code>Kotlin</code>中，我们有了一种更方便的方式：扩展。<code>Kotlin</code>可以扩展一个类的新功能而无需继承这个类，新增的这些功能就像是原始类本来就有的一样，可以用普通的方法调用。在<code>kotlin</code>中的扩展分为<strong>扩展函数(ExtensionFunctions)</strong>和<strong>扩展属性(ExtensionProperties)</strong>。</p><span id="more"></span><h2 id="扩展函数">扩展函数</h2><p>声明一个扩展函数，我们需要一个被扩展的类型来作为前缀，也就是在写个类名再加上个点，这样你就能对这个类的对象调用这个函数了，例如：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> String.<span class="title">sayHello</span><span class="params">()</span></span>&#123;</span><br><span class="line">    println(<span class="string">&quot;<span class="variable">$this</span> say: hello!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">//输出Sachil say: hello!</span></span><br><span class="line">    <span class="string">&quot;Sachil&quot;</span>.sayHello()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>是不是挺简单的，但是这个扩展函数写在什么地方是有区别的。扩展函数按照声明位置的不同，可以分为<strong>顶层(TopLevel)扩展函数</strong>和<strong>成员扩展函数</strong>。</p><h3 id="顶层扩展函数">顶层扩展函数</h3><p>顾名思义，就是将扩展函数声明在文件的顶层，让它不属于任何一个类，这样你就可以在任何类中调用它。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sachil</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> String.<span class="title">sayBye</span><span class="params">()</span></span>:String&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;<span class="variable">$this</span> say bye bye...&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    println(<span class="string">&quot;sachil&quot;</span>.sayBye())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是，这个扩展函数属于谁呢？属于函数名左边的类(String)吗？其实不是，这个函数是TopLevel的，它谁也不属于，或者说它属于它所在的package。</p><h3 id="成员扩展函数">成员扩展函数</h3><p>除了在文件顶层声明扩展函数之外，也可以在一个类中声明扩展函数，这样的扩展函数就是成员扩展函数。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sachil</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">KotlinTest</span> </span>&#123;</span><br><span class="line">    <span class="comment">//将扩展函数写在类里</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> String.<span class="title">sayBye</span><span class="params">()</span></span>:String&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;<span class="variable">$this</span> say bye bye...&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">printer</span><span class="params">(name:<span class="type">String</span>)</span></span>&#123;</span><br><span class="line">        println(name.sayBye())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">//成员扩展函数只能在其声明的类里调用，在外面是无法调用的</span></span><br><span class="line">    <span class="comment">//println(&quot;sachil&quot;.sayBye())</span></span><br><span class="line">    KotlinTest().printer(<span class="string">&quot;sachil&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样声明之后，这个扩展函数又是属于谁呢？答案显而易见，当然是属于它声明时所在的类(<code>KotlinTest</code>)，因为它是这个类的成员函数嘛。<strong>需要注意的是：成员扩展函数只能在其声明的类里面被调用，在外面是无法调用的。</strong>成员扩展函数的好处是可以防止被外界看到，从而造成不必要的困惑。</p><p>如果一个类定义有一个成员函数和一个扩展函数，而两个函数又有相同的接收者类型，相同的名字，相同的参数，这种情况总是取成员函数。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Example</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">printFunctionType</span><span class="params">()</span></span> &#123; println(<span class="string">&quot;Class method&quot;</span>) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> Example.<span class="title">printFunctionType</span><span class="params">()</span></span> &#123; println(<span class="string">&quot;Extension function&quot;</span>) &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">//输出 Class method</span></span><br><span class="line">    Example().printFunctionType()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="扩展函数是静态解析的">扩展函数是静态解析的</h4><p>扩展不能真正修改它所扩展的类，而且<strong>扩展函数是静态解析的</strong>。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> : <span class="type">Animal</span></span>()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> Animal.<span class="title">getName</span><span class="params">()</span></span>: String = <span class="string">&quot;Animal&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> Dog.<span class="title">getName</span><span class="params">()</span></span>: String = <span class="string">&quot;Dog&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//这里声明函数的时候，参数类型是Animal，所以就只会调用Animal的扩展函数getName</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">printName</span><span class="params">(animal: <span class="type">Animal</span>)</span></span> &#123;</span><br><span class="line">    println(<span class="string">&quot;The name is <span class="subst">$&#123;animal.getName()&#125;</span>&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">//输出The name is Animal</span></span><br><span class="line">    printName(Animal())</span><br><span class="line">    <span class="comment">//传入一个子类对象，输出还是The name is Animal</span></span><br><span class="line">    printName(Dog())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为扩展函数是静态解析的，所以不存在多态的行为，在声明<code>printName</code>的时候，参数使用的是<code>Animal</code>类型，所以在<code>printName</code>内部调用的是<code>Animal</code>类的扩展函数，即使你在调用<code>printName</code>的时候传入的是<code>Animal</code>类子类(<code>Dog</code>)的对象。</p><h4 id="分发接收者与扩展接收者">分发接收者与扩展接收者</h4><p>成员扩展函数的出现带来了两个新的概念：</p><ul><li><strong>分发接收者【dispatchreceiver】</strong>，所谓分发接收者，就是声明成员扩展函数的类的对象。就是在哪个类中声明，那个类的对象就是分发接收者。</li><li><strong>扩展接收者【extensionreceiver】</strong>，所谓扩展接收者，就是实际扩展的那个类的对象。</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//KotlinTest的实例就是分发接受者，String的实例就是扩展接收者</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">KotlinTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> String.<span class="title">sayBye</span><span class="params">()</span></span>:String&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;<span class="variable">$this</span> say bye bye...&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="两者之间出现冲突时">两者之间出现冲突时</h5><p>当分发接收者与扩展接收者的成员出现冲突的时候，扩展接收者优先，如果要使用分发接收者的成员，可以使用this@分发接收者类型的方式来调用。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">KotlinTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> String.<span class="title">sayHello</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">//这里调用的是String的tostring</span></span><br><span class="line">        println(toString())</span><br><span class="line">        <span class="comment">//这里调用的是KotlinTest的toString</span></span><br><span class="line">        println(<span class="keyword">this</span><span class="symbol">@KotlinTest</span>.toString())</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">printer</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="string">&quot;Sachil&quot;</span>.sayHello()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">toString</span><span class="params">()</span></span>: String &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;KotlinTest&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">//输出：Sachil</span></span><br><span class="line"><span class="comment">// KotlinTest</span></span><br><span class="line">    KotlinTest().printer()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="两者的解析方式">两者的解析方式</h5><p>成员扩展函数可以被声明为<code>open</code>的并且可以在子类中覆盖，这种行为将会带来新的疑惑：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">Base</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> : <span class="type">Base</span></span>() &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseCaller</span> </span>&#123;</span><br><span class="line">    <span class="keyword">open</span> <span class="function"><span class="keyword">fun</span> Base.<span class="title">printFunctionInfo</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;Base extension function in BaseCaller&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">open</span> <span class="function"><span class="keyword">fun</span> Derived.<span class="title">printFunctionInfo</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;Derived extension function in BaseCaller&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">call</span><span class="params">(b: <span class="type">Base</span>)</span></span> &#123;</span><br><span class="line">        b.printFunctionInfo()   <span class="comment">// 调用扩展函数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DerivedCaller</span>: <span class="type">BaseCaller</span></span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> Base.<span class="title">printFunctionInfo</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;Base extension function in DerivedCaller&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> Derived.<span class="title">printFunctionInfo</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;Derived extension function in DerivedCaller&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">//这里输出Base extension function in BaseCaller很容易理解</span></span><br><span class="line">    BaseCaller().call(Base())</span><br><span class="line">    <span class="comment">//这里输出Base extension function in BaseCaller也比较容易理解</span></span><br><span class="line">    BaseCaller().call(Derived())</span><br><span class="line">    <span class="comment">//这里输出Base extension function in DerivedCaller</span></span><br><span class="line">    DerivedCaller().call(Base())</span><br><span class="line">    <span class="comment">//这里输出的也是Base extension function in DerivedCaller</span></span><br><span class="line">    DerivedCaller().call(Derived())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码的行为比较怪异，其实要理解这种行为，我们只需要记住这两条规则就可以了</p><table><thead><tr class="header"><th style="text-align: center;">-</th><th style="text-align: center;">分发接收者</th><th style="text-align: center;">扩展接收者</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">概念</td><td style="text-align: center;">声明成员扩展函数的类的对象</td><td style="text-align: center;">实际扩展的那个类的对象</td></tr><tr class="even"><td style="text-align: center;">解析方式</td><td style="text-align: center;">动态解析</td><td style="text-align: center;">静态解析</td></tr></tbody></table><p>由于分发接收者是动态解析的，上面的代码在<code>DerivedCaller</code>类中重写了<code>Base</code>的<code>printFunctionInfo</code>扩展函数，所以代码第35行和第37行会执行<code>DerivedCaller</code>类中的扩展函数，而扩展接收者是静态解析的，在<code>call</code>函数声明的时候，使用的<code>Base</code>类型，所以无论传递给它的是<code>Base</code>对象还是<code>Base</code>的子类对象，<code>call</code>都只会调用<code>Base</code>的扩展函数。这样就可以理解上面代码的行为了。</p><h2 id="扩展函数的引用">扩展函数的引用</h2><p>我们都知道，函数可以通过双冒号来引用，也知道引用的其实本不是函数本身，而是一个和函数功能相同的对象，例如：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">KotlinTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">sayHello</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;Hello world&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">//通常用法的调用</span></span><br><span class="line">    KotlinTest().sayHello()</span><br><span class="line">    <span class="comment">//使用函数引用的方式调用</span></span><br><span class="line">    (KotlinTest::sayHello)(KotlinTest())</span><br><span class="line">    <span class="comment">//使用该对象的invoke方法来调用</span></span><br><span class="line">    KotlinTest::sayHello.invoke(KotlinTest())</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和普通函数一样，扩展函数也可以使用双引号来引用，不过有个限制条件：这个扩展函数必须是顶层扩展函数。原因很简单，普通的成员函数通过类名+双冒号+函数名来引用，扩展函数也是一样，如果扩展函数是成员扩展函数的话，这个类名是用谁的类名呢？是分发接收者的类名还是扩展接收者的类名？这就造成了歧义，所以<code>Kotlin</code>做出了这样的限制。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sachil</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> String.<span class="title">sayBye</span><span class="params">(to: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">    println(<span class="string">&quot;<span class="variable">$this</span> say:Bye bye... to <span class="variable">$to</span>&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">//这三种方式是等价的</span></span><br><span class="line">    <span class="string">&quot;Sachil&quot;</span>.sayBye(<span class="string">&quot;Tom&quot;</span>)</span><br><span class="line">    (String::sayBye)(<span class="string">&quot;Sachil&quot;</span>, <span class="string">&quot;Tom&quot;</span>)</span><br><span class="line">    (String::sayBye).invoke(<span class="string">&quot;Sachil&quot;</span>, <span class="string">&quot;Tom&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//将扩展函数的引用赋值给变量(有Receiver的方式)</span></span><br><span class="line">    <span class="keyword">val</span> methodA: String.(String) -&gt; <span class="built_in">Unit</span> = String::sayBye</span><br><span class="line">    <span class="string">&quot;Sachil&quot;</span>.methodA(<span class="string">&quot;Tom&quot;</span>)</span><br><span class="line">    <span class="comment">//有Receiver的函数可以通过无Receiver的方式来调用</span></span><br><span class="line">    methodA(<span class="string">&quot;Sachil&quot;</span>,<span class="string">&quot;Tom&quot;</span>)</span><br><span class="line">    methodA.invoke(<span class="string">&quot;Sachil&quot;</span>,<span class="string">&quot;Tom&quot;</span>)</span><br><span class="line">    <span class="comment">// 将扩展函数的引用赋值给变量(无Receiver的方式)</span></span><br><span class="line">    <span class="keyword">val</span> methodB: (String, String) -&gt; <span class="built_in">Unit</span> = String::sayBye</span><br><span class="line">    methodB(<span class="string">&quot;Sachil&quot;</span>, <span class="string">&quot;Tom&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//无Receiver的函数不能通过有Receiver的方式来调用</span></span><br><span class="line">    <span class="comment">//&quot;Sachil&quot;.methodB(&quot;Tom&quot;)</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//两者之间互换</span></span><br><span class="line">    <span class="keyword">val</span> methodC:(String,String)-&gt;<span class="built_in">Unit</span> = methodA</span><br><span class="line">    <span class="keyword">val</span> methodD:String.(String)-&gt;<span class="built_in">Unit</span> = methodB</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然也可以将扩展函数的引用赋值给变量来使用(如上面代码的15-18行)，甚至在赋值的时候，还可以将其声明为无Receiver的方式(如上面代码20-21行)，还有你还能在它们之间互换(如代码23-24行)。同时还可以发现，有Receiver的函数可以通过无Receiver的方式来调用(代码18行)，但是无Receiver的函数不能通过有Receiver的方式来调用(代码24-25行)。</p><p>最后你还可以将普通函数赋值给有Receiver的变量,也可以将扩展函数赋值给无Receiver的变量，感觉太灵活了。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sachil</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">sayBye</span><span class="params">(from: <span class="type">String</span>, to: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">    println(<span class="string">&quot;<span class="variable">$from</span> say:Bye bye... to <span class="variable">$to</span>&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> String.<span class="title">sayHello</span><span class="params">(to: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">    println(<span class="string">&quot;<span class="variable">$this</span> say:Hello... to <span class="variable">$to</span>&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">//普通调用</span></span><br><span class="line">    sayBye(<span class="string">&quot;Sachil&quot;</span>,<span class="string">&quot;Tom&quot;</span>)</span><br><span class="line">    <span class="comment">//报错，不能这样调用</span></span><br><span class="line">   <span class="comment">// &quot;Sachil&quot;.sayBye(&quot;Tom&quot;)</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//赋值给有Receiver的变量</span></span><br><span class="line">    <span class="keyword">val</span> method: String.(String) -&gt; <span class="built_in">Unit</span> = ::sayBye</span><br><span class="line">    <span class="comment">//和扩展函数一样的调用方式</span></span><br><span class="line">    <span class="string">&quot;Sachil&quot;</span>.method(<span class="string">&quot;Tom&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//普通调用</span></span><br><span class="line">    <span class="string">&quot;Sachil&quot;</span>.sayHello(<span class="string">&quot;Tom&quot;</span>)</span><br><span class="line">   <span class="comment">//将扩展函数赋值给无Receiver的变量</span></span><br><span class="line">    <span class="keyword">val</span> methodB:(String,String)-&gt;<span class="built_in">Unit</span> = String::sayHello</span><br><span class="line">    methodB(<span class="string">&quot;Sachil&quot;</span>,<span class="string">&quot;Tom&quot;</span>)</span><br><span class="line">    <span class="comment">//报错，不能这样调用</span></span><br><span class="line">    <span class="comment">//&quot;Sachil&quot;.methodB(&quot;Tom&quot;)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="扩展属性">扩展属性</h2><p><code>Kotlin</code>中除了扩展函数之外，还有扩展属性，其声明方式和扩展函数类似，就是类型+点+属性名称。用法也和扩展函数差不多。<strong>但是需要注意的是，由于扩展没有将成员真正插入到类里面，所以对于扩展属性来说<code>幕后字段</code>是无效的，也就是说扩展属性不能有初始化器，必须实现访问器方法</strong>。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sachil</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name = <span class="string">&quot;Sachil&quot;</span></span><br><span class="line">    <span class="keyword">var</span> age = <span class="number">10</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> Student.<span class="title">homeTown</span><span class="params">()</span></span>: String &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Chengdu&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//报错，不能有初始化器</span></span><br><span class="line"><span class="comment">//val Student.homeTown:String = &quot;Chengdu&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Student.grade: <span class="built_in">Int</span></span><br><span class="line">    <span class="keyword">get</span>() = age - <span class="number">7</span></span><br><span class="line">    <span class="keyword">set</span>(value) &#123;</span><br><span class="line">        age = <span class="number">7</span> + value</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> Student.information: String</span><br><span class="line">    <span class="comment">//可以调用成员属性、成员函数、扩展函数、其它扩展属性</span></span><br><span class="line">    <span class="keyword">get</span>() = <span class="string">&quot;name:<span class="variable">$name</span>,age:<span class="variable">$age</span>,grade:<span class="variable">$grade</span>,homeTown:<span class="subst">$&#123;homeTown()&#125;</span>&quot;</span></span><br><span class="line">    <span class="comment">//不能调用扩展属性本身，否则会栈溢出</span></span><br><span class="line">    <span class="comment">//get() = &quot;$information&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> student = Student()</span><br><span class="line">    println(<span class="string">&quot;grade is:<span class="subst">$&#123;student.grade&#125;</span>&quot;</span>)</span><br><span class="line">    student.grade = <span class="number">5</span></span><br><span class="line">    println(<span class="string">&quot;new grade is:<span class="subst">$&#123;student.grade&#125;</span>&quot;</span>)</span><br><span class="line">    println(<span class="string">&quot;age:<span class="subst">$&#123;student.age&#125;</span>&quot;</span>)</span><br><span class="line">    println(student.information)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>扩展属性本质其实还是扩展函数，它扩展的是<code>setter</code>和<code>getter</code>两个访问器，所以扩展属性没有在内存中分配空间来保存该属性。扩展属性中的访问器可以使用成员属性、成员方法、扩展方法、其它扩展属性，但是不能使用扩展属性本身，否则会栈溢出。</p><hr /><p>参考文章：</p><p><ahref="https://kaixue.io/kotlin-extensions/">会写「18.dp」只是个入门——Kotlin的扩展函数和扩展属性（Extension Functions / Properties）</a></p><p><ahref="https://www.jianshu.com/p/068297d246e2">Kotlin难点解析：extension和this指针</a></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;kotlin中的扩展函数与扩展属性&quot;&gt;Kotlin中的扩展函数与扩展属性&lt;/h1&gt;
&lt;p&gt;通常情况下，如果我们需要为一个已存在的类添加新的功能，但是在不能直接修改这个类的源码的时候，我们会选择创建一个这个类的子类来添加我们需要增加的功能。这种方式在我们写&lt;code&gt;Java&lt;/code&gt;代码的时候经常使用，可以说是轻车熟路。在&lt;code&gt;Kotlin&lt;/code&gt;中，我们有了一种更方便的方式：扩展。&lt;code&gt;Kotlin&lt;/code&gt;可以扩展一个类的新功能而无需继承这个类，新增的这些功能就像是原始类本来就有的一样，可以用普通的方法调用。在&lt;code&gt;kotlin&lt;/code&gt;中的扩展分为&lt;strong&gt;扩展函数(Extension
Functions)&lt;/strong&gt;和&lt;strong&gt;扩展属性(Extension
Properties)&lt;/strong&gt;。&lt;/p&gt;</summary>
    
    
    
    <category term="Kotlin" scheme="https://sachil.xyz/categories/Kotlin/"/>
    
    
    <category term="Kotlin" scheme="https://sachil.xyz/tags/Kotlin/"/>
    
    <category term="扩展函数" scheme="https://sachil.xyz/tags/Extension-Functions/"/>
    
    <category term="扩展属性" scheme="https://sachil.xyz/tags/Extension-Properties/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin中的Lambda表达式</title>
    <link href="https://sachil.xyz/posts/c6661a47/"/>
    <id>https://sachil.xyz/posts/c6661a47/</id>
    <published>2020-05-23T06:38:39.000Z</published>
    <updated>2023-06-20T15:46:03.207Z</updated>
    
    <content type="html"><![CDATA[<h1 id="kotlin中的lambda表达式">Kotlin中的Lambda表达式</h1><p>在<code>Kotlin</code>中是支持<code>Lambda表达式</code>的，使用起来也比较简单和方便，但是很多时候我们还是对它有很多疑惑，比如我们在调用它的时候觉得很顺手，但是让我们自己去定义的时候却不是那么容易上手，还有就是<code>Lambda表达式</code>到底是什么，以及<code>Kotlin</code>中的<code>Lambda表达式</code>和<code>Java8</code>中的<code>Lambda</code>有什么本质上的区别？这些我们需要通过学习来一一解答。</p><h2 id="高阶函数">高阶函数</h2><h3 id="java中的限制">Java中的限制</h3><p>在了解<code>Lambda表达式</code>之前，我们需要先理解另一个重要的概念：<strong>高阶函数</strong>。什么是高阶函数？它的定义就是：将函数作为参数或者返回值的函数。感觉不太明白是吧，没关系，听我娓娓道来，首先我们先看一个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">functionX</span><span class="params">(<span class="keyword">int</span> params)</span> </span>&#123;</span><br><span class="line">    functionY(params);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">functionY</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Value is:&quot;</span> + value);</span><br><span class="line">&#125;</span><br><span class="line">functionX(<span class="number">100</span>);</span><br></pre></td></tr></table></figure><span id="more"></span><p>在<code>Java</code>代码中，你有一个<code>functionX</code>方法需要调用另一个<code>functionY</code>方法，并且动态的设置<code>functionY</code>方法的参数，你就需要先把参数传递给<code>functionX</code>，然后再在该方法的内部将参数传递给<code>functionY</code>,就像上面的代码一样。但是如果我们想动态设置的不是函数参数，而是方法本身呢？比如在<code>functionX</code>中动态的设置调用哪个方法，或者说我们可以将方法作为参数传递到另一个方法中吗？很遗憾，<code>Java</code>中并不支持将方法作为参数来传递。但是<code>Java</code>中有一个折中的方案，那就是接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Say</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">sayHello</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">implements</span> <span class="title">Say</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Wang..Wang&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">implements</span> <span class="title">Say</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Miao...&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">String <span class="title">function</span><span class="params">(Say who)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> who.sayHello();</span><br><span class="line">&#125;</span><br><span class="line">function(<span class="keyword">new</span> Dog());</span><br><span class="line">function(<span class="keyword">new</span> Cat());</span><br></pre></td></tr></table></figure><p>在上面的代码中，<code>function</code>方法接受一个<code>Say</code>接口类型的参数，其实这里<code>Say</code>只是一个壳，其本质是传递进来一个可以调用的<code>sayHello</code>方法，而这个方法可以有不同的实现(就像Dog类和Cat类那样)，只不过<code>Java</code>中不允许传递方法，而我们将它包裹在一个对象中进行传递，这样就达到了我们的目的。</p><h3 id="kotlin中的使用">Kotlin中的使用</h3><p>在<code>Kotlin</code>中，不用这么麻烦，可以直接将函数作为参数进行传递，或者作为返回值返回，这就是高阶函数，<code>Kotlin</code>是直接支持的：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HighOrderFunction</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">functionA</span><span class="params">(value: <span class="type">Int</span>)</span></span>: String &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Value:<span class="variable">$value</span>&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">functionB</span><span class="params">(value: <span class="type">Int</span>)</span></span>: String &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Value*10:<span class="subst">$&#123;value * <span class="number">10</span>&#125;</span>&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//高阶函数</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">functionC</span><span class="params">(value: <span class="type">Int</span>, method: (<span class="type">Int</span>) -&gt; <span class="type">String</span>)</span></span>: String &#123;</span><br><span class="line">        <span class="keyword">return</span> method(value)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//高阶函数</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">functionD</span><span class="params">(mode: <span class="type">Int</span>)</span></span>: (<span class="built_in">Int</span>) -&gt; String &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">if</span> (mode % <span class="number">2</span> == <span class="number">0</span>) ::functionA <span class="keyword">else</span> ::functionB</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> test = HighOrderFunction()</span><br><span class="line">    <span class="comment">//这里新建了一个函数传递给functionC，也就是匿名函数</span></span><br><span class="line">    test.functionC(<span class="number">1</span>,<span class="function"><span class="title">fun</span><span class="params">(value:<span class="type">Int</span>)</span></span>:String&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Input value is <span class="variable">$value</span>&quot;</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">//这里将functionA作为参数传递给functionC</span></span><br><span class="line">    println(test.functionC(<span class="number">1</span>, test::functionA))</span><br><span class="line">    <span class="comment">//这里将functionB作为参数传递给functionC</span></span><br><span class="line">    println(test.functionC(<span class="number">1</span>, test::functionB))</span><br><span class="line">    <span class="comment">//这里functionD返回的是functionB</span></span><br><span class="line">    println(test.functionD(<span class="number">1</span>)(<span class="number">2</span>))</span><br><span class="line">    <span class="comment">//这里functionD返回的是functionA</span></span><br><span class="line">    println(test.functionD(<span class="number">2</span>)(<span class="number">2</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的代码中，<code>functionC</code>和<code>functionD</code>都是高阶函数，<code>functionC</code>的<code>method</code>参数是一个函数类型的参数，其具体类型是一个接受一个Int参数并返回一个String的函数，<code>functionA</code>和<code>functionB</code>就是这样类型的函数，所以我们可以将<code>functionA</code>和<code>functionB</code>作为<code>functionC</code>的参数。而<code>functionD</code>返回的是一个类型为接受一个Int参数并返回一个String的函数，所以我们也可以将<code>functionA</code>和<code>functionB</code>作为<code>functionD</code>的返回值。</p><h3 id="双冒号的作用">双冒号::的作用</h3><p>对于一个声明好的函数，在作为参数进行传递时或者要把它赋值给一个变量时，都得在函数名左边加上双冒号(::)。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">functionA</span><span class="params">()</span></span> &#123;</span><br><span class="line">    println(<span class="string">&quot;In functionA&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">functionB</span><span class="params">(method: () -&gt; <span class="type">Unit</span>)</span></span> &#123;</span><br><span class="line">    method()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">//直接调用functionA</span></span><br><span class="line">    functionA()</span><br><span class="line">     <span class="comment">//这里其实调用的是function的invoke()方法</span></span><br><span class="line">    (::functionA)()</span><br><span class="line">    <span class="comment">//将函数赋值给变量function</span></span><br><span class="line">    <span class="keyword">val</span> function = ::functionA</span><br><span class="line">    <span class="comment">//这里其实调用的是function的invoke()方法</span></span><br><span class="line">    function()</span><br><span class="line">    <span class="comment">//作为参数传递</span></span><br><span class="line">    functionB(::functionA)</span><br><span class="line">    <span class="comment">//将变量function传递给functionB，与上面等价</span></span><br><span class="line">    functionB(function)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>为什么需要加双冒号呢？因为只有加上了双冒号，函数才能转变为一个对象。</strong>在<code>Kotlin</code>中，函数可以作为参数或者返回值的本质就是，函数可以作为对象存在，只有对象才能作为参数或者返回值，将函数赋值给变量也是同样的道理。但是函数的性质决定了它不是一个对象，所以在<code>Kotlin</code>中加上双冒号，就创建了一个和函数功能相同的对象。</p><h2 id="匿名函数">匿名函数</h2><p>将函数作为参数进行传递，或者将函数对象赋值给变量，除了使用双冒号+已声明的函数来使用之外，还可以直接把函数实现拿来使用：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">functionA</span><span class="params">()</span></span> &#123;</span><br><span class="line">    println(<span class="string">&quot;Hello World&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">functionB</span><span class="params">(method: () -&gt; <span class="type">Unit</span>)</span></span> &#123;</span><br><span class="line">    method()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">//直接挪用了functionA的函数体，functionB的参数是一个匿名函数</span></span><br><span class="line">    functionB(<span class="function"><span class="title">fun</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;Hello World&quot;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">//新建了一个函数，并赋值给变量method，等号的右边是一个匿名函数</span></span><br><span class="line">    <span class="keyword">val</span> method = <span class="function"><span class="title">fun</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;Hello Kotlin&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    functionB(method)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种写法就叫<code>匿名函数</code>，其实很好理解，因为函数有函数实现，但是没有函数名。</p><h2 id="lambda表达式">Lambda表达式</h2><p><code>Lambda表达式</code>和<code>匿名函数</code>一样，没有先声明函数，而是作为表达式立即被使用。<code>Lambda 表达式</code>总是括在花括号中，完整语法形式的参数声明放在花括号内，并有可选的类型标注， 函数体跟在一个<code>-&gt;</code> 符号之后。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">functionA</span><span class="params">(method: (<span class="type">Int</span>) -&gt; <span class="type">Unit</span>, value: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">    method(value)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">functionB</span><span class="params">(value: <span class="type">Int</span>, method: (<span class="type">Int</span>) -&gt; <span class="type">Unit</span>)</span></span> &#123;</span><br><span class="line">    method(value)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">functionV</span><span class="params">(method: () -&gt; <span class="type">Unit</span>)</span></span> &#123;</span><br><span class="line">    method()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">//使用Lambda表达式，并自定义了参数名为value</span></span><br><span class="line">    functionA(&#123; value: <span class="built_in">Int</span> -&gt; println(<span class="string">&quot;Hey,<span class="variable">$value</span>&quot;</span>) &#125;, <span class="number">1</span>)</span><br><span class="line">    <span class="comment">//使用匿名函数的方式</span></span><br><span class="line">    functionB(<span class="number">1</span>, <span class="function"><span class="title">fun</span><span class="params">(value: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;<span class="variable">$value</span>&quot;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">//使用Lambda表达式，函数类型的参数在最后，所以可以将花括号写在括号之外</span></span><br><span class="line">    functionB(<span class="number">100</span>) &#123;</span><br><span class="line">        println(<span class="string">&quot;The value is:<span class="variable">$it</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//参数只有一个，并且为函数类型，所以括号都可以省略</span></span><br><span class="line">    functionV &#123;</span><br><span class="line">        println(<span class="string">&quot;Hello world.&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将Lambda表达式赋值给method</span></span><br><span class="line">    <span class="keyword">val</span> method = &#123; value: <span class="built_in">Int</span> -&gt;</span><br><span class="line">        println(<span class="string">&quot;Method value:<span class="variable">$value</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    functionB(<span class="number">1</span>, method)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实感觉<code>Lambda表达式</code>就是<code>匿名函数</code>的简便写法。<code>Lambda表达式</code>这样的简便写法可以省略很多东西，但是它又是这样知道自己的参数类型和返回值类型的呢(例如上面代码第21行,<code>functionB</code>的调用)，其实它是从上下文中推导出来的，因为我们在声明<code>functionB</code>的时候(代码第5行)已经定义了参数<code>method</code>的类型。如果无法从上下文中推导出来，我们就需要显示指定，例如在将<code>lambda表达式</code>赋值给变量时(代码第29行)。</p><h2 id="匿名函数与lambda表达式的本质">匿名函数与Lambda表达式的本质</h2><p><code>匿名函数</code>可以作为参数传递或者赋值给变量，而我们知道函数是不能直接作为参数传递或者赋值给变量的，匿名函数为什么这么特殊？其实在<code>Kotlin</code>中<code>匿名函数</code>不是函数，而是对象，虽然它的名字中有函数两个字，但其实它是一个对象。同样，<code>Lambda表达式</code>也是对象，所以它们才能被直接用于参数传递或者变量赋值。</p><h2 id="与java中lambda的差异">与Java中Lambda的差异</h2><p><code>Java</code>从<code>Java8</code>开始支持<code>Lambda表达式</code>，对于单抽象方法的接口(SAM:SingleAbstractMethod)，<code>Java8</code>允许你使用<code>Lambda表达式</code>来创建匿名类对象，是一种简化写法而已，本质上还是在创建匿名类对象，而<code>Kotlin</code>中<code>Lambda表达式</code>的本质是函数对象，功能更强大，写法也更灵活。</p><p>还有就是在<code>Kotlin</code>中不允许用<code>Lambda表达式</code>来简写匿名类对象，因为已经有高阶函数，所以不再需要这样的折中方案，但是在与<code>Java</code>的交互中却是可以的，当你的函数参数是一个<code>Java</code>的单抽象方法接口对象时，是可以使用<code>Lambda表达式的</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Java代码，接口中只有一个方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">method</span><span class="params">(<span class="keyword">int</span> value)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Kotlin代码</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">method</span><span class="params">(value: <span class="type">Int</span>)</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">testA</span><span class="params">(a: <span class="type">A</span>)</span></span> &#123;</span><br><span class="line">    a.method(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">testB</span><span class="params">(b: <span class="type">B</span>)</span></span> &#123;</span><br><span class="line">    b.method(<span class="number">2</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">//Kotlin中不允许使用Lambda表达式来简写匿名类对象</span></span><br><span class="line"><span class="comment">//    testA &#123; value: Int -&gt;</span></span><br><span class="line"><span class="comment">//        println(&quot;$value&quot;)</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line">    <span class="comment">//只能像这样调用</span></span><br><span class="line">    testA(<span class="keyword">object</span> : A &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">method</span><span class="params">(value: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">            println(<span class="string">&quot;<span class="variable">$value</span>&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">//在与Java交互的时候，可以这样写</span></span><br><span class="line">    testB &#123; value: <span class="built_in">Int</span> -&gt;</span><br><span class="line">        println(<span class="string">&quot;<span class="variable">$value</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是在<code>Kotlin</code>中对于单抽象方法的接口，可以使用关键字<code>fun</code>来修饰，这样就可以使用<code>Lambda表达式</code>来使代码更简洁和更有可读性。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用fun修饰单抽象方法的接口</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="keyword">interface</span> A &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">method</span><span class="params">(value: <span class="type">Int</span>)</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">//普通的调用方式，比较繁琐</span></span><br><span class="line">    <span class="keyword">val</span> normal = <span class="keyword">object</span> : A &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">method</span><span class="params">(value: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">            println(<span class="string">&quot;The value is <span class="variable">$it</span>&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    normal.method(<span class="number">100</span>)</span><br><span class="line">    <span class="comment">//使用Lambda表达式来简化调用</span></span><br><span class="line">    <span class="keyword">val</span> lambda = A &#123;</span><br><span class="line">        println(<span class="string">&quot;The value is <span class="variable">$it</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    lambda.method(<span class="number">100</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考文章：</p><p><a href="https://kaixue.io/kotlin-lambda/">Kotlin 的 Lambda表达式，大多数人学得连皮毛都不算</a></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;kotlin中的lambda表达式&quot;&gt;Kotlin中的Lambda表达式&lt;/h1&gt;
&lt;p&gt;在&lt;code&gt;Kotlin&lt;/code&gt;中是支持&lt;code&gt;Lambda表达式&lt;/code&gt;的，使用起来也比较简单和方便，但是很多时候我们还是对它有很多疑惑，比如我们在调用它的时候觉得很顺手，但是让我们自己去定义的时候却不是那么容易上手，还有就是&lt;code&gt;Lambda表达式&lt;/code&gt;到底是什么，以及&lt;code&gt;Kotlin&lt;/code&gt;中的&lt;code&gt;Lambda表达式&lt;/code&gt;和&lt;code&gt;Java8&lt;/code&gt;中的&lt;code&gt;Lambda&lt;/code&gt;有什么本质上的区别？这些我们需要通过学习来一一解答。&lt;/p&gt;
&lt;h2 id=&quot;高阶函数&quot;&gt;高阶函数&lt;/h2&gt;
&lt;h3 id=&quot;java中的限制&quot;&gt;Java中的限制&lt;/h3&gt;
&lt;p&gt;在了解&lt;code&gt;Lambda表达式&lt;/code&gt;之前，我们需要先理解另一个重要的概念：&lt;strong&gt;高阶函数&lt;/strong&gt;。什么是高阶函数？它的定义就是：将函数作为参数或者返回值的函数。感觉不太明白是吧，没关系，听我娓娓道来，首先我们先看一个例子：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;functionX&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; params)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    functionY(params);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;functionY&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; value)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    System.out.println(&lt;span class=&quot;string&quot;&gt;&amp;quot;Value is:&amp;quot;&lt;/span&gt; + value);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;functionX(&lt;span class=&quot;number&quot;&gt;100&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="Kotlin" scheme="https://sachil.xyz/categories/Kotlin/"/>
    
    
    <category term="Kotlin" scheme="https://sachil.xyz/tags/Kotlin/"/>
    
    <category term="Lambda表达式" scheme="https://sachil.xyz/tags/Lambda/"/>
    
    <category term="高阶函数" scheme="https://sachil.xyz/tags/High-Order-Function/"/>
    
    <category term="匿名函数" scheme="https://sachil.xyz/tags/Anonymous-Function/"/>
    
  </entry>
  
  <entry>
    <title>算法图解心得</title>
    <link href="https://sachil.xyz/posts/539438d6/"/>
    <id>https://sachil.xyz/posts/539438d6/</id>
    <published>2020-05-21T07:38:25.000Z</published>
    <updated>2023-06-20T15:46:03.207Z</updated>
    
    <content type="html"><![CDATA[<h2 id="二分查找">1.二分查找</h2><p>二分查找属于<strong>分治法</strong>，分治法基本都可以使用递归来实现。<strong>二分查找只能用于有序的数组</strong>，其时间复杂度为：<strong><spanclass="math inline">\(O(logn)\)</span></strong>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 二分查找，非递归方式</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">binary_search</span>(<span class="params">arrays, low_index, high_index, target</span>):</span></span><br><span class="line">    <span class="keyword">while</span> low_index &lt;= high_index:</span><br><span class="line">        mid_index = (low_index + high_index) // <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> arrays[mid_index] &gt; target:</span><br><span class="line">            high_index = mid_index - <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> arrays[mid_index] &lt; target:</span><br><span class="line">            low_index = mid_index + <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> arrays[mid_index]</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 二分查找,递归方式</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">binary_search_with_recursion</span>(<span class="params">arrays, low_index, high_index, target</span>):</span></span><br><span class="line">    <span class="keyword">if</span> low_index &gt; high_index:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    mid_index = (low_index + high_index) // <span class="number">2</span></span><br><span class="line">    <span class="keyword">if</span> arrays[mid_index] &gt; target:</span><br><span class="line">        <span class="keyword">return</span> binary_search(arrays, low_index, mid_index - <span class="number">1</span>, target)</span><br><span class="line">    <span class="keyword">elif</span> arrays[mid_index] &lt; target:</span><br><span class="line">        <span class="keyword">return</span> binary_search(arrays, low_index + <span class="number">1</span>, high_index, target)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> arrays[mid_index]</span><br><span class="line">    </span><br><span class="line">numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>]</span><br><span class="line"></span><br><span class="line">binary_search(numbers, <span class="number">0</span>, <span class="built_in">len</span>(numbers), <span class="number">9</span>)</span><br><span class="line">binary_search_with_recursion(numbers, <span class="number">0</span>, <span class="built_in">len</span>(numbers), <span class="number">9</span>)</span><br></pre></td></tr></table></figure><span id="more"></span><h2 id="选择排序">2.选择排序</h2><p>选择排序的时间复杂度为：<strong>$ O(n^2)$</strong>，n是数组的长度。选择排序是一种比较灵巧的算法，但其速度不是很快。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#找到数组中最小值 的索引</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_min_index</span>(<span class="params">arrays</span>):</span></span><br><span class="line">    min_value = arrays[<span class="number">0</span>]</span><br><span class="line">    min_value_index = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(arrays)):</span><br><span class="line">        <span class="keyword">if</span> arrays[i] &lt; min_value:</span><br><span class="line">            min_value = arrays[i]</span><br><span class="line">            min_value_index = i</span><br><span class="line">    <span class="keyword">return</span> min_value_index</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">select_sort</span>(<span class="params">arrays</span>):</span></span><br><span class="line">    <span class="comment">#用于存储排序后的数</span></span><br><span class="line">    sorted_array = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(arrays)):</span><br><span class="line">        sorted_array.append(arrays.pop(find_min_index(arrays)))</span><br><span class="line">    <span class="keyword">return</span> sorted_array</span><br></pre></td></tr></table></figure><h2 id="快速排序">3.快速排序</h2><p>排序的时间复杂度为：<strong><span class="math inline">\(O(nlogn)\)</span></strong>,快速排序的性能高度依赖选取的基准值，所以在最糟的情况下快速排序和选择排序的时间复杂度是一样的，都是<spanclass="math inline">\(O(n^2)\)</span>,<strong>在最佳情况下快速排序的时间复杂度是<spanclass="math inline">\(O(nlogn)\)</span>,最佳情况也是平均情况</strong>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quick_sort</span>(<span class="params">arrays</span>):</span></span><br><span class="line">    <span class="comment">#递归的基线条件，当数组的长度小于等于1的时候不再需要排序，直接返回该数组</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(arrays) &lt; <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> arrays</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment">#取数组的第一个元素为基准值</span></span><br><span class="line">        pivot = arrays[<span class="number">0</span>]</span><br><span class="line">        <span class="comment">#找出数组中小于基准值的元素</span></span><br><span class="line">        less = [i <span class="keyword">for</span> i <span class="keyword">in</span> arrays[<span class="number">1</span>:] <span class="keyword">if</span> i &lt; pivot]</span><br><span class="line">        <span class="comment">#找出数组中大于等于基准值的元素</span></span><br><span class="line">        greater = [i <span class="keyword">for</span> i <span class="keyword">in</span> arrays[<span class="number">1</span>:] <span class="keyword">if</span> i &gt;= pivot]</span><br><span class="line">        <span class="comment">#递归调用快速排序</span></span><br><span class="line">        <span class="keyword">return</span> quick_sort(less) + [pivot] + quick_sort(greater)</span><br></pre></td></tr></table></figure><h2 id="广度优先搜索">4.广度优先搜索</h2><p>广度优先搜索用于解决最短路径问题(shortest-pathproblem)，可帮助回答两个问题：</p><ol type="1"><li>从节点A出发，有到节点B的路径吗？</li><li>从节点A出发，前往节点B的哪条路径最短？</li></ol><p><strong>要达到这样的目的，搜索的顺序很重要，可以使用队列(queue)来实现</strong>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line">graph = &#123;<span class="string">&#x27;you&#x27;</span>: [<span class="string">&#x27;Bob&#x27;</span>, <span class="string">&#x27;Alice&#x27;</span>, <span class="string">&#x27;Claire&#x27;</span>], <span class="string">&#x27;Bob&#x27;</span>: [<span class="string">&#x27;Anuj&#x27;</span>, <span class="string">&#x27;Peggy&#x27;</span>], <span class="string">&#x27;Claire&#x27;</span>: [<span class="string">&#x27;Thom&#x27;</span>, <span class="string">&#x27;Jonny&#x27;</span>],</span><br><span class="line">             <span class="string">&#x27;Alice&#x27;</span>: [<span class="string">&#x27;Peggy&#x27;</span>], <span class="string">&#x27;Peggy&#x27;</span>: [], <span class="string">&#x27;Anuj&#x27;</span>: [], <span class="string">&#x27;Thom&#x27;</span>: [], <span class="string">&#x27;Jonny&#x27;</span>: []&#125;</span><br><span class="line"><span class="comment"># 广度优先搜索，这里假设名字以字符&#x27;m&#x27;结尾的人就是我们要找的</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">wide_first_search</span>():</span></span><br><span class="line">    <span class="comment"># 用于标记已经搜索过的人，防止无限循环</span></span><br><span class="line">    searched=[]</span><br><span class="line">    search_queue = deque()</span><br><span class="line">    <span class="comment"># 将你的邻居加入到搜索队列中</span></span><br><span class="line">    search_queue += graph[<span class="string">&#x27;you&#x27;</span>]</span><br><span class="line">    <span class="keyword">while</span> search_queue:</span><br><span class="line">        person = search_queue.popleft()</span><br><span class="line">        <span class="comment"># 判断person是否已经搜索过</span></span><br><span class="line">        <span class="keyword">if</span> person <span class="keyword">not</span> <span class="keyword">in</span> searched:</span><br><span class="line">            <span class="comment"># 满足条件，返回</span></span><br><span class="line">            <span class="keyword">if</span> person[-<span class="number">1</span>] == <span class="string">&#x27;m&#x27;</span>:</span><br><span class="line">                <span class="keyword">return</span> person</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 不满足条件，将这个人的邻居加入到搜索队列中</span></span><br><span class="line">                search_queue += graph[person]</span><br><span class="line">                searched.append(person)</span><br><span class="line">    <span class="comment"># 搜索队列为空，搜索完毕，没有找到满足条件的人</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure><h2 id="狄克斯特拉算法">5.狄克斯特拉算法</h2><p>广度优先搜索适用于找出<strong>非加权图</strong>中前往某节点的最短路径，而狄克斯特拉算法(Dijkstra'salgorithm)用于找出<strong>加权图</strong>中前往某节点的最短路径，。狄克斯特拉算法包含四个步骤：</p><ol type="1"><li>找出最便宜的节点，例如可在最短时间内前往的节点</li><li>对于该节点的邻居，检查是否有前往它们的更短路径，如果有，则更新其开销</li><li>重复这个过程，知道图中的所有的节点都这样做了</li><li>计算最终路径</li></ol><p>需要注意的是：<strong>狄克斯特拉算法只使用于有向无环图，并且不能将该算法用于包含负权边的图。</strong>（包含负权边的图，可使用贝尔曼-福德算法）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 记录所有节点的邻居</span></span><br><span class="line">graph = &#123;<span class="string">&#x27;start&#x27;</span>: &#123;<span class="string">&#x27;a&#x27;</span>: <span class="number">6</span>, <span class="string">&#x27;b&#x27;</span>: <span class="number">2</span>&#125;, <span class="string">&#x27;a&#x27;</span>: &#123;<span class="string">&#x27;finish&#x27;</span>: <span class="number">1</span>&#125;, <span class="string">&#x27;b&#x27;</span>: &#123;<span class="string">&#x27;a&#x27;</span>: <span class="number">3</span>, <span class="string">&#x27;finish&#x27;</span>: <span class="number">5</span>&#125;, <span class="string">&#x27;finish&#x27;</span>: &#123;&#125;&#125;</span><br><span class="line">infinity = <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)</span><br><span class="line"><span class="comment"># 记录已知节点的开销</span></span><br><span class="line">costs = &#123;<span class="string">&#x27;a&#x27;</span>: <span class="number">6</span>, <span class="string">&#x27;b&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;finish&#x27;</span>: infinity&#125;</span><br><span class="line"><span class="comment"># 记录已知节点的父节点</span></span><br><span class="line">parents = &#123;<span class="string">&#x27;a&#x27;</span>: <span class="string">&#x27;start&#x27;</span>, <span class="string">&#x27;b&#x27;</span>: <span class="string">&#x27;start&#x27;</span>, <span class="string">&#x27;finish&#x27;</span>: <span class="literal">None</span>&#125;</span><br><span class="line"><span class="comment"># 记录处理过的节点</span></span><br><span class="line">processed = []</span><br><span class="line"> <span class="comment"># 在costs中找到开销最小的节点</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_lowest_cost_node</span>(<span class="params">costs</span>):</span></span><br><span class="line">    lowest_cost = <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)</span><br><span class="line">    lowest_node = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">for</span> node <span class="keyword">in</span> costs:</span><br><span class="line">        cost = costs[node]</span><br><span class="line">        <span class="keyword">if</span> cost &lt; lowest_cost <span class="keyword">and</span> node <span class="keyword">not</span> <span class="keyword">in</span> processed:</span><br><span class="line">            lowest_cost = cost</span><br><span class="line">            lowest_node = node</span><br><span class="line">    <span class="keyword">return</span> lowest_node</span><br><span class="line"></span><br><span class="line"><span class="comment"># 狄克斯特拉算法的实现,该算法不能用于包含负权边的图,且只适用于有向无环图</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dijkstra_algorithm</span>():</span></span><br><span class="line">    node = find_lowest_cost_node(costs,processed)</span><br><span class="line">    <span class="keyword">while</span> node <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        cost = costs[node]</span><br><span class="line">        neighbors = graph[node]</span><br><span class="line">        <span class="keyword">for</span> key <span class="keyword">in</span> neighbors.keys():</span><br><span class="line">            new_const = cost + neighbors[key]</span><br><span class="line">            <span class="keyword">if</span> costs[key] &gt; new_const:</span><br><span class="line">                costs[key] = new_const</span><br><span class="line">                parents[key] = node</span><br><span class="line">        processed.append(node)</span><br><span class="line">        node = find_lowest_cost_node(costs,processed)</span><br><span class="line">    print(parents)</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;二分查找&quot;&gt;1.二分查找&lt;/h2&gt;
&lt;p&gt;二分查找属于&lt;strong&gt;分治法&lt;/strong&gt;，分治法基本都可以使用递归来实现。&lt;strong&gt;二分查找只能用于有序的数组&lt;/strong&gt;，其时间复杂度为：&lt;strong&gt;&lt;span
class=&quot;math inline&quot;&gt;\(O(logn)\)&lt;/span&gt;&lt;/strong&gt;。&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 二分查找，非递归方式&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;binary_search&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;arrays, low_index, high_index, target&lt;/span&gt;):&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; low_index &amp;lt;= high_index:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        mid_index = (low_index + high_index) // &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; arrays[mid_index] &amp;gt; target:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            high_index = mid_index - &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;elif&lt;/span&gt; arrays[mid_index] &amp;lt; target:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            low_index = mid_index + &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; arrays[mid_index]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;None&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 二分查找,递归方式&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;binary_search_with_recursion&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;arrays, low_index, high_index, target&lt;/span&gt;):&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; low_index &amp;gt; high_index:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;None&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    mid_index = (low_index + high_index) // &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; arrays[mid_index] &amp;gt; target:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; binary_search(arrays, low_index, mid_index - &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, target)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;elif&lt;/span&gt; arrays[mid_index] &amp;lt; target:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; binary_search(arrays, low_index + &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, high_index, target)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; arrays[mid_index]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;numbers = [&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;7&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;8&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;8&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;9&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;binary_search(numbers, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;built_in&quot;&gt;len&lt;/span&gt;(numbers), &lt;span class=&quot;number&quot;&gt;9&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;binary_search_with_recursion(numbers, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;built_in&quot;&gt;len&lt;/span&gt;(numbers), &lt;span class=&quot;number&quot;&gt;9&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="算法" scheme="https://sachil.xyz/categories/algorithm/"/>
    
    
    <category term="算法" scheme="https://sachil.xyz/tags/algorithm/"/>
    
    <category term="Python" scheme="https://sachil.xyz/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin中的委托</title>
    <link href="https://sachil.xyz/posts/2e419a6e/"/>
    <id>https://sachil.xyz/posts/2e419a6e/</id>
    <published>2020-03-22T02:20:35.000Z</published>
    <updated>2023-06-20T15:46:03.207Z</updated>
    
    <content type="html"><![CDATA[<h1 id="kotlin中的委托">Kotlin中的委托</h1><p>我们都知道委托也就是<code>委托模式</code>，也可以称为<code>代理模式</code>,是23种经典设计模式中的一种。在委托模式中，有两个对象参与对同一个请求的处理，接受请求的对象将请求委托给另一个对象来处理。在委托模式中，有三个角色：业务约束，委托者和被委托者。</p><ul><li>业务约束，通常它是一个接口或者抽象类，其定义了通用的业务类型，也就是需要被委托的业务。</li><li>被委托者，业务逻辑的执行者，也就是真正实际上处理业务的。</li><li>委托者，接受业务逻辑，然后将业务转交给被委托者来执行。</li></ul><span id="more"></span><h2 id="类委托">类委托</h2><p>在<code>Java</code>中，我们可以比较容易的通过手动的方式来实现委托：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义业务约束</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Printer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//被委托者</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">XiaoMiPrinter</span> <span class="keyword">implements</span> <span class="title">Printer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;XiaoMi printer...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//委托者</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPrinter</span> <span class="keyword">implements</span> <span class="title">Printer</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建了一个被委托者的对象</span></span><br><span class="line">    <span class="keyword">private</span> Printer realPrinter = <span class="keyword">new</span> XiaoMiPrinter();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//调用被委托者来处理业务</span></span><br><span class="line">        realPrinter.print();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> MyPrinter().print();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码中，我们声明了一个<code>Printer</code>接口，它定义了需要处理的业务，然后我们又定义了两个它的实现类：<code>XiaoMiPrinter</code>和<code>MyPrinter</code>，在<code>XiaoMiPrinter</code>类中，我们实现了具体的<code>print</code>方法，而在<code>MyPrinter</code>类中，我们创建了一个<code>XiaoMiPrinter</code>对象，并在其<code>print</code>方法实现的时候，将其具体实现逻辑委托给了这个<code>XiaoMiPrinter</code>对象来实现。这样我们就自己手动实现了一个委托模式。</p><p>像上面的代码那样，在<code>Java</code>中实现委托模式，代码实现起来的时候会比较冗余，例如，如果在<code>Printer</code>中有很多个抽象方法，那么在<code>MyPrinter</code>类中就都要一一实现。<code>Kotlin</code>为我们提供了一个方便快捷的关键字<code>by</code>,通过它，我们可以快速的实现委托模式。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Printer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//被委托者</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">XiaoMiPrinter</span> : <span class="type">Printer &#123;</span></span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">print</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;XiaoMi printer...&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//委托者，通过by关键字实现</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPrinter</span></span>(realPrinter: Printer) : Printer <span class="keyword">by</span> realPrinter</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    MyPrinter(XiaoMiPrinter()).print()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以在<code>Kotlin</code>中，委托可以通过关键字<code>by</code>来实现，它的后面就是被委托的对象。如果我们对上面的<code>Kotlin</code>代码进行反编译的话，你会发现，其底层的实现和我们手动的实现并没有什么区别。另外需要注意的是：覆盖(override)在委托中符合预期的，但是被委托者只能访问其自身对接口成员的实现。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Printer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">val</span> name: String</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">printMessage</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">XiaoMiPrinter</span> : <span class="type">Printer &#123;</span></span></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> name: String = <span class="string">&quot;XiaoMiPrinter&quot;</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">print</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;<span class="variable">$name</span> print...&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">printMessage</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;XiaoMiPrinter print message.&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPrinter</span></span>(realPrinter: Printer) : Printer <span class="keyword">by</span> realPrinter &#123;</span><br><span class="line">    <span class="comment">//在realPrinter的print实现中，不会访问到这个属性</span></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> name: String = <span class="string">&quot;MyPrinter&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//这里对printMessage进行了重载</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">printMessage</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;MyPrinter print Message.&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> printer = MyPrinter(XiaoMiPrinter())</span><br><span class="line">    <span class="comment">//输出：MyPrinter print Message.</span></span><br><span class="line">    printer.printMessage()</span><br><span class="line">    <span class="comment">//输出：XiaoMiPrinter print...</span></span><br><span class="line">    printer.print()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="属性委托">属性委托</h2><p>在<code>Kotlin</code>中不仅支持一个类的委托，同时也支持一个属性的委托。<code>属性委托</code>的语法为:<code>val/var &lt;属性名&gt;:&lt;类型&gt; by &lt;表达式&gt;</code>，我们已经知道在委托中有一个委托约束来定义被委托的业务，委托属性就是将属性的getter/setter访问器委托给被委托对象的<code>getValue</code>/<code>setValue</code>方法，因此被委托对象需要实现这两个方法，当然对于<code>val</code>属性，只需要实现<code>getValue</code>方法即可。这两个方法的签名是有具体规定的，其方法签名为：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">getValue</span><span class="params">(thisRef: <span class="type">Any</span>?, property: <span class="type">KProperty</span>&lt;*&gt;)</span></span>:T</span><br><span class="line"><span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">setValue</span><span class="params">(thisRef: <span class="type">Any</span>?, property: <span class="type">KProperty</span>&lt;*&gt;, value: <span class="type">T</span>)</span></span></span><br></pre></td></tr></table></figure><ul><li><code>operator</code>,表示重载运算符</li><li><code>thisRef</code>,表示包含该属性的对象，其类型必须与属性所有者的类型相同或者是其超类。它可以调用对象本身，目的是可以检查对象的其它属性或者调用对象的其它函数。</li><li><code>property</code>,必须是类型 <code>KProperty&lt;*&gt;</code>或其超类型。</li><li><code>value</code>,对于<code>val</code>属性，<code>getValue</code>必须返回与属性相同的类型或者其子类型。对于<code>var</code>属性，<code>setValue</code>中其类型必须是和属性相同或者其超类型。</li></ul><p>明白了<code>属性委托</code>的语法规则之后，我们可以使用<code>属性委托</code>来方便快捷的来实现一些功能扩展，例如当我们需要在不同的属性之间复用getter/setter逻辑时。如果我们又这样一个类：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name: String=<span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">var</span> lastName: String=<span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">var</span> updateCount: <span class="built_in">Int</span> = <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，我们对<code>name</code>有一定的格式要求：当<code>name</code>被赋值时，除了首字母为大写之外，其余字母都为小写，同时再扩展以下：每当<code>name</code>被赋值，<code>updateCount</code>都需要自动增加。当然，我们可以通过自定义setter访问器来实现：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>() &#123;</span><br><span class="line">    <span class="keyword">var</span> name: String = <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="keyword">set</span>(value) &#123;</span><br><span class="line">            field = value.toLowerCase().capitalize()</span><br><span class="line">            updateCount++</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">var</span> lastName: String = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">var</span> updateCount: <span class="built_in">Int</span> = <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们修改一下需求：要求当<code>lastName</code>被赋值的时候做同样的处理。当然，你可以按照同样的方式为<code>lastName</code>添加同样的setter访问器，就像这样:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name: String = <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="keyword">set</span>(value) &#123;</span><br><span class="line">            field = value.toLowerCase().capitalize()</span><br><span class="line">            updateCount++</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">var</span> lastName: String = <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="keyword">set</span>(value) &#123;</span><br><span class="line">            field = value.toLowerCase().capitalize()</span><br><span class="line">            updateCount++</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">var</span> updateCount: <span class="built_in">Int</span> = <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是你会发现，这样的代码存在很大的冗余，像这种情况，我们可以通过<code>委托属性</code>来进行优化：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="comment">//这里使用了委托属性</span></span><br><span class="line">    <span class="keyword">var</span> name: String <span class="keyword">by</span> NameDelegate()</span><br><span class="line">    <span class="comment">//这里使用了委托属性</span></span><br><span class="line">    <span class="keyword">var</span> lastName: String <span class="keyword">by</span> NameDelegate()</span><br><span class="line">    <span class="keyword">var</span> updateCount: <span class="built_in">Int</span> = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个类来接受委托</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NameDelegate</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> formatedValue = <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">getValue</span><span class="params">(thisRef: <span class="type">Any</span>?, property: <span class="type">KProperty</span>&lt;*&gt;)</span></span>: String &#123;</span><br><span class="line">        <span class="keyword">return</span> formatedValue</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">setValue</span><span class="params">(thisRef: <span class="type">Any</span>?, property: <span class="type">KProperty</span>&lt;*&gt;, value: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (thisRef <span class="keyword">is</span> Person) &#123;</span><br><span class="line">            formatedValue = value.toLowerCase().capitalize()</span><br><span class="line">            thisRef.updateCount++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> person = Person()</span><br><span class="line">    <span class="comment">//输出：person.updateCount=0</span></span><br><span class="line">    println(<span class="string">&quot;person.updateCount=<span class="subst">$&#123;person.updateCount&#125;</span>&quot;</span>)</span><br><span class="line">    person.name = <span class="string">&quot;sAchil&quot;</span></span><br><span class="line">    <span class="comment">//输出：person.name=Sachil,person.updateCount=1</span></span><br><span class="line">    println(<span class="string">&quot;person.name=<span class="subst">$&#123;person.name&#125;</span>,person.updateCount=<span class="subst">$&#123;person.updateCount&#125;</span>&quot;</span>)</span><br><span class="line">    person.lastName = <span class="string">&quot;TOM&quot;</span></span><br><span class="line">    <span class="comment">//输出：person.lastName=Tom,person.updateCount=2</span></span><br><span class="line">    println(<span class="string">&quot;person.lastName=<span class="subst">$&#123;person.lastName&#125;</span>,person.updateCount=<span class="subst">$&#123;person.updateCount&#125;</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于手动实现<code>getValue</code>和<code>setValue</code>方法来说，它们的参数还是比较复杂的，不太容易记住，为了方便起见，<code>Kotlin</code>为我们提供了两个接口:<code>ReadOnlyProperty</code>(用于<code>val</code>属性)和<code>ReadWriteProperty</code>(用于<code>var</code>属性),我们可以通过实现接口的方式来实现被委托的类。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过实现ReadWriteProperty接口来实现被委托类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NameDelegate</span> : <span class="type">ReadWriteProperty</span>&lt;<span class="type">Any?, String</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> formatedValue = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getValue</span><span class="params">(thisRef: <span class="type">Any</span>?, property: <span class="type">KProperty</span>&lt;*&gt;)</span></span>: String &#123;</span><br><span class="line">        <span class="keyword">return</span> formatedValue</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">setValue</span><span class="params">(thisRef: <span class="type">Any</span>?, property: <span class="type">KProperty</span>&lt;*&gt;, value: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (thisRef <span class="keyword">is</span> Person) &#123;</span><br><span class="line">            formatedValue = value.toLowerCase().capitalize()</span><br><span class="line">            thisRef.updateCount++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>甚至我们可以不用定义一个新的类，可以直接使用<code>匿名对象</code>的方式来实现被委托对象</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这里使用匿名对象来实现被委托对象</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getNameDelegate</span><span class="params">()</span></span>: ReadWriteProperty&lt;Any?, String&gt; = <span class="keyword">object</span> : ReadWriteProperty&lt;Any?, String&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> formatedValue = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getValue</span><span class="params">(thisRef: <span class="type">Any</span>?, property: <span class="type">KProperty</span>&lt;*&gt;)</span></span>: String &#123;</span><br><span class="line">        <span class="keyword">return</span> formatedValue</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">setValue</span><span class="params">(thisRef: <span class="type">Any</span>?, property: <span class="type">KProperty</span>&lt;*&gt;, value: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (thisRef <span class="keyword">is</span> Person) &#123;</span><br><span class="line">            formatedValue = value.toLowerCase().capitalize()</span><br><span class="line">            thisRef.updateCount++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name: String <span class="keyword">by</span> getNameDelegate()</span><br><span class="line">    <span class="keyword">var</span> lastName: String <span class="keyword">by</span> getNameDelegate()</span><br><span class="line">    <span class="keyword">var</span> updateCount: <span class="built_in">Int</span> = <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="标准属性委托">标准属性委托</h3><p>在<code>Kotlin</code>的标准库中为我们提供了几种常用的委托方式：</p><h4 id="lazy">lazy</h4><p><code>lazy()</code>接受一个<code>Lambda表达式</code>为参数并返回一个<code>Lazy&lt;T&gt;</code>实例，返回<code>Lazy&lt;T&gt;</code>实例可以实现延迟属性的委托：在第一次调用getter访问器时会执行<code>Lambda表达式</code>的内容并记录其结果，后续调用getter访问器时只会返回已记录的结果，不再执行<code>Lambda表达式</code>的内容。它只能用用于<code>val</code>属性，因为<code>Lazy&lt;T&gt;</code>中声明的<code>value</code>属性是<code>val</code>，所以<code>value</code>只有getter访问器而没有setter访问器。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> name: String <span class="keyword">by</span> lazy &#123;</span><br><span class="line">    println(<span class="string">&quot;Get name by lazy.&quot;</span>)</span><br><span class="line">    <span class="string">&quot;Sachil&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">//输出：Get name by lazy.</span></span><br><span class="line">    <span class="comment">//Sachil</span></span><br><span class="line">    println(name)</span><br><span class="line">    <span class="comment">//输出：Sachil</span></span><br><span class="line">    println(name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>lazy()</code>还可以接受一个<code>LazyThreadSafetyMode</code>类型的参数，这个参数是和多线程有关的，毕竟<code>Labmda表达式</code>并不是一个原子操作，在多线程环境下，<code>lazy()</code>会不会出现多线程同步的问题呢？这个参数就是用来解决这个问题的，它是一个<code>枚举类</code>，有3个枚举对象：</p><ul><li><code>LazyThreadSafetyMode.SYNCHRONIZED</code>,默认方式，在这种模式下，<code>Lambda表达式</code>是加了锁的，以确保只有一个线程能够执行初始化。</li><li><code>LazyThreadSafetyMode.PUBLICATION</code>，在这种模式下，允许多个线程同时访问<code>Lambda表达式</code>，但是这当中只有第一个返回的值作为初始化的结果。</li><li><code>LazyThreadSafetyMode.NONE</code>，这种模式是线程不安全的，不应该在多线程的环境中使用。但是如果你能确定你只在单个线程的环境中使用，这种模式可以避免因为锁而带来的额外开销。</li></ul><h4 id="observablevetoable">observable/vetoable</h4><p><code>observable()</code>和<code>vetoable()</code>可以让属性变为可观察属性，也就是可以对属性值的变化进行监听。它们接受两个参数：一个初始值和一个函数类型的处理程序，处理程序接受三个参数，被赋值的属性，旧的属性值和新的属性值。<code>observable()</code>和<code>vetoable()</code>的区别就是，前者是先赋值再执行处理程序，而后者是先执行处理程序，并使用处理程序的<code>Boolean</code>类型的返回值来判断此次赋值操作是否继续，然后再进行赋值操作。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name: String <span class="keyword">by</span> Delegates.observable(<span class="string">&quot;&quot;</span>) &#123; property, oldValue, newValue -&gt;</span><br><span class="line">    println(<span class="string">&quot;<span class="subst">$&#123;property.name&#125;</span> has been changed from <span class="variable">$oldValue</span> to <span class="variable">$newValue</span> &quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> lastName: String <span class="keyword">by</span> Delegates.vetoable(<span class="string">&quot;Tom&quot;</span>) &#123; property, oldValue, newValue -&gt;</span><br><span class="line">    println(<span class="string">&quot;<span class="subst">$&#123;property.name&#125;</span> try to be changed from <span class="variable">$oldValue</span> to <span class="variable">$newValue</span> &quot;</span>)</span><br><span class="line">    newValue.startsWith(<span class="string">&quot;S&quot;</span>, <span class="literal">true</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">//输出：name has been changed from  to Sachil</span></span><br><span class="line">    name = <span class="string">&quot;Sachil&quot;</span></span><br><span class="line">    <span class="comment">//输出：lastName has been changed from Tom to Jerry</span></span><br><span class="line">    lastName = <span class="string">&quot;Jerry&quot;</span></span><br><span class="line">     <span class="comment">//输出：Tom</span></span><br><span class="line">    println(lastName)</span><br><span class="line">     <span class="comment">//输出：lastName has been changed from Tom to sachil</span></span><br><span class="line">    lastName = <span class="string">&quot;sachil&quot;</span></span><br><span class="line">     <span class="comment">//输出：sachil</span></span><br><span class="line">    println(lastName)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="map">map</h4><p>对于属性的访问，可以委托给一个map对象，但是map对象的key必须和属性的名称相同，例如：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>(map: Map&lt;String, Any&gt;) &#123;</span><br><span class="line">    <span class="keyword">val</span> name: String <span class="keyword">by</span> map</span><br><span class="line">    <span class="keyword">val</span> age: <span class="built_in">Int</span> <span class="keyword">by</span> map</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> person = Person(mapOf(<span class="string">&quot;name&quot;</span> to <span class="string">&quot;Sachil&quot;</span>, <span class="string">&quot;age&quot;</span> to <span class="number">18</span>))</span><br><span class="line">    <span class="comment">//输出：name:Sachil,age:18</span></span><br><span class="line">    println(<span class="string">&quot;name:<span class="subst">$&#123;person.name&#125;</span>,age:<span class="subst">$&#123;person.age&#125;</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于<code>var</code>属性则使用<code>MutableMap</code>即可，同时需要注意的是对<code>MutableMap</code>中的value进行修改会同步到属性值，对属性值得修改也会同步到<code>MutableMap</code>：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>(map: MutableMap&lt;String, Any&gt;) &#123;</span><br><span class="line">    <span class="keyword">var</span> name: String <span class="keyword">by</span> map</span><br><span class="line">    <span class="keyword">var</span> age: <span class="built_in">Int</span> <span class="keyword">by</span> map</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> person = Person(mutableMapOf(<span class="string">&quot;name&quot;</span> to <span class="string">&quot;Sachil&quot;</span>, <span class="string">&quot;age&quot;</span> to <span class="number">18</span>))</span><br><span class="line">    <span class="comment">//输出：name:Sachil,age:18</span></span><br><span class="line">    println(<span class="string">&quot;name:<span class="subst">$&#123;person.name&#125;</span>,age:<span class="subst">$&#123;person.age&#125;</span>&quot;</span>)</span><br><span class="line">    person.name = <span class="string">&quot;Tom&quot;</span></span><br><span class="line">    person.age = <span class="number">6</span></span><br><span class="line">    <span class="comment">//输出：name:Tom,age:6</span></span><br><span class="line">    println(<span class="string">&quot;name:<span class="subst">$&#123;person.name&#125;</span>,age:<span class="subst">$&#123;person.age&#125;</span>&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> map:MutableMap&lt;String,Any&gt; = mutableMapOf(<span class="string">&quot;name&quot;</span> to <span class="string">&quot;Sachil&quot;</span>, <span class="string">&quot;age&quot;</span> to <span class="number">18</span>)</span><br><span class="line">    <span class="keyword">val</span> person = Person(map)</span><br><span class="line">     <span class="comment">//输出：name:Sachil,age:18</span></span><br><span class="line">    println(<span class="string">&quot;name:<span class="subst">$&#123;person.name&#125;</span>,age:<span class="subst">$&#123;person.age&#125;</span>&quot;</span>)</span><br><span class="line">    person.name = <span class="string">&quot;Tom&quot;</span></span><br><span class="line">    person.age = <span class="number">6</span></span><br><span class="line">    <span class="comment">//输出：name:Tom,age:6</span></span><br><span class="line">    println(<span class="string">&quot;name:<span class="subst">$&#123;person.name&#125;</span>,age:<span class="subst">$&#123;person.age&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="comment">//输出：name:Tom</span></span><br><span class="line">    <span class="comment">//age:6</span></span><br><span class="line">    <span class="keyword">for</span> ((key, value) <span class="keyword">in</span> map) &#123;</span><br><span class="line">        println(<span class="string">&quot;<span class="variable">$key</span>:<span class="variable">$value</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;kotlin中的委托&quot;&gt;Kotlin中的委托&lt;/h1&gt;
&lt;p&gt;我们都知道委托也就是&lt;code&gt;委托模式&lt;/code&gt;，也可以称为&lt;code&gt;代理模式&lt;/code&gt;,是23种经典设计模式中的一种。在委托模式中，有两个对象参与对同一个请求的处理，接受请求的对象将请求委托给另一个对象来处理。在委托模式中，有三个角色：业务约束，委托者和被委托者。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;业务约束，通常它是一个接口或者抽象类，其定义了通用的业务类型，也就是需要被委托的业务。&lt;/li&gt;
&lt;li&gt;被委托者，业务逻辑的执行者，也就是真正实际上处理业务的。&lt;/li&gt;
&lt;li&gt;委托者，接受业务逻辑，然后将业务转交给被委托者来执行。&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="Kotlin" scheme="https://sachil.xyz/categories/Kotlin/"/>
    
    
    <category term="Kotlin" scheme="https://sachil.xyz/tags/Kotlin/"/>
    
    <category term="委托" scheme="https://sachil.xyz/tags/Delegate/"/>
    
    <category term="属性委托" scheme="https://sachil.xyz/tags/Properties-Delegate/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin基础知识</title>
    <link href="https://sachil.xyz/posts/5498e339/"/>
    <id>https://sachil.xyz/posts/5498e339/</id>
    <published>2019-11-05T13:20:56.000Z</published>
    <updated>2023-06-20T15:46:03.207Z</updated>
    
    <content type="html"><![CDATA[<h1 id="kotlin基础知识">Kotlin基础知识</h1><h2 id="gettersetter访问器">getter、setter访问器</h2><p>getter称为读访问器，setter称为写访问器，val修饰的属性只有getter访问器，var修饰的属性包含getter和setter两种访问器，Kotlin中访问一个属性的本质就是调用getter和setter访问器。<strong>getter的可见性必须和属性声明的可见性一致，setter的可见性不能大于属性声明的可见性(属性可见性为public，setter的可见性可以是private)。</strong></p><span id="more"></span><h2 id="幕后字段和幕后声明">幕后字段和幕后声明</h2><p><strong>在Kotlin中，如果属性至少一个访问器使用默认实现，那么Kotlin将会自动提供幕后字段，用关键字<code>field</code>表示，幕后字段的主要作用是用于自定义getter和setter，并且只能在getter和setter中使用。</strong>在Kotlin中，并不是所有的属性都有幕后字段，一个属性拥有幕后字段需要满足以下两个条件之一：</p><ul><li>使用默认getter/setter访问器的属性，一定拥有幕后字段。对于var属性，getter和setter其中之一使用默认实现，就会生成幕后字段。</li><li>在自定义getter/setter中使用了<code>field</code>。</li></ul><p>下面这个例子就没有幕后字段：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NoField</span></span>&#123;</span><br><span class="line">    <span class="keyword">val</span> size = <span class="number">0</span></span><br><span class="line">    <span class="comment">//isEmpty没有幕后字段</span></span><br><span class="line">    <span class="keyword">val</span> isEmpty: <span class="built_in">Boolean</span></span><br><span class="line">        <span class="keyword">get</span>() = size == <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>有幕后字段的属性在转为Java代码时一定会生成一个对应的Java变量，否则将只会生成对应的get或者set方法而没有成员变量。</strong></p><p>幕后属性一般在这种情况下使用：<strong>我们期望一个属性对外表现为只读，对内表现为可读可写</strong>，这样我们可以使用幕后属性来实现：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这里_table可见性为private，只能在内部访问，而外部可访问的table属性的值取决于_table</span></span><br><span class="line"><span class="comment">//所以_table就是一个幕后属性</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">KotlinTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> _table: Map&lt;String, <span class="built_in">Int</span>&gt;? = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">val</span> table: Map&lt;String, <span class="built_in">Int</span>&gt;</span><br><span class="line">        <span class="keyword">get</span>() &#123;</span><br><span class="line">            <span class="keyword">if</span> (_table == <span class="literal">null</span>)</span><br><span class="line">                _table = HashMap()</span><br><span class="line">            <span class="keyword">return</span> _table ?: <span class="keyword">throw</span> AssertionError(<span class="string">&quot;table为空&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="当const遇到val时的细节">当const遇到val时的细节</h2><p><code>val</code>用来声明只读变量，<code>const</code>用来声明编译期的常量，<code>const</code>修饰的常量需要同时满足以下三个条件：</p><ul><li>只能是字符串和基础类型</li><li>只能是全局常量【toplevel】、object成员、companion对象【伴生对象】的成员</li><li>const不能单独修饰某个变量，必须和val同时修饰一个变量</li></ul><p>constval修饰的变量，一定是编译时的常量，在编译期就知道它的值，不需要依赖运行时的任何变量。而val修饰的变量，是只读变量，只能赋值一次，可以是运行期间赋值，编译期常量属于只读变量的一种特殊情况。</p><p>const的好处是：<strong>在Java代码中引用Kotlin变量时，不能直接使用val的变量，但可以直接使用<code>const val</code>修饰的变量。</strong>例如：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">KotlinTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span>&#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">val</span> NAME = <span class="string">&quot;Perry&quot;</span></span><br><span class="line">        <span class="keyword">val</span> age = <span class="number">30</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> static void main(String[] args) &#123;</span><br><span class="line">        <span class="comment">//可直接访问const val修饰的变量</span></span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">&quot;JavaTest:&quot;</span>+KotlinTest.NAME);</span><br><span class="line">        <span class="comment">//不能直接访问没有const修饰的变量，并且会自动生成getAge()方法</span></span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">&quot;JavaTest:&quot;</span>+KotlinTest.Companion.getAge());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以能用<code>const val</code>声明的变量就不要只用<code>val</code>来声明，因为这样不优雅，编译性能也更低。<code>const val</code>不会生成相应的<code>getXXX()</code>方法，具体原因可以通过转换为Java代码来查看：</p><p>Kotlin代码：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">KotlinTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span>&#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">val</span> NAME = <span class="string">&quot;Perry&quot;</span></span><br><span class="line">        <span class="keyword">val</span> age = <span class="number">30</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应的Java代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">KotlinTest</span> </span>&#123;</span><br><span class="line">   <span class="meta">@NotNull</span></span><br><span class="line">    <span class="comment">//companion中的const val变量，生成了public static final静态常量</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String NAME = <span class="string">&quot;Perry&quot;</span>;</span><br><span class="line">    <span class="comment">//companion中的val变量，生成了private static final静态常量</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> age = <span class="number">30</span>;</span><br><span class="line">   <span class="meta">@NotNull</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> KotlinTest.Companion Companion = <span class="keyword">new</span> KotlinTest.Companion((DefaultConstructorMarker)<span class="keyword">null</span>);</span><br><span class="line">    </span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Companion</span> </span>&#123;</span><br><span class="line">       <span class="comment">//生成对应的get方法</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> KotlinTest.age;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">private</span> <span class="title">Companion</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// $FF: synthetic method</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="title">Companion</span><span class="params">(DefaultConstructorMarker $constructor_marker)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">this</span>();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过转换为Java代码可以知道，<strong>constval声明的变量，生成了<code>public static final</code>静态常量，而val声明的变量，生成了<code>private static final</code>静态常量，同时还生成了对应的getXXX()方法。</strong></p><h2 id="interface接口">interface【接口】</h2><p>Kotlin中的接口即可以包含抽象方法也可以包含具体的方法实现，接口与抽象类不同，它不能保存状态，接口中可以包含属性，但它必须声明为抽象的或者提供访问器实现，<strong>接口中的属性不能包含幕后字段</strong>。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="comment">//抽象的属性</span></span><br><span class="line">    <span class="keyword">var</span> name: String</span><br><span class="line"></span><br><span class="line">    <span class="comment">//提供访问器</span></span><br><span class="line">    <span class="keyword">val</span> age: <span class="built_in">Int</span></span><br><span class="line">        <span class="keyword">get</span>() = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//Error:不能在接口中初始化属性</span></span><br><span class="line">    <span class="keyword">val</span> weight: <span class="built_in">Float</span> = <span class="number">60F</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//抽象的方法，子类必须实现</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">eat</span><span class="params">()</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//具体的方法，子类可以不用实现</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">sleep</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;Sleeping...&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在主构造器中覆盖属性</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student1</span></span>(<span class="keyword">override</span> <span class="keyword">var</span> name: String, <span class="keyword">override</span> <span class="keyword">val</span> age: <span class="built_in">Int</span> = <span class="number">32</span>) : Person &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">eat</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;Eat...&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在子类的内部覆盖属性</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student2</span></span>() : Person &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">var</span> name: String = <span class="string">&quot;Perry&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//可以用var覆盖val属性，反之不行</span></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">var</span> age: <span class="built_in">Int</span> = <span class="number">0</span></span><br><span class="line">        <span class="keyword">get</span>() = <span class="number">32</span></span><br><span class="line">        <span class="keyword">set</span>(value) &#123;</span><br><span class="line">            println(<span class="string">&quot;Setting age.&quot;</span>)</span><br><span class="line">            field = value</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">eat</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;Not bad...&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当子类在实现的过程中出现覆盖冲突的时候，可以使用<code>super&lt;Parent&gt;.function()</code>的方式来指明具体调用哪一个父类的实现。</p><h2 id="可见性修饰符">可见性修饰符</h2><p>Kotlin中有四种可见性修饰符：</p><ul><li><strong>public</strong>:公开的，可见性最大，哪儿都能引用</li><li><strong>private</strong>:私有的，可见性最小，根据声明位置的不同分为类中可见和文件中可见</li><li><strong>protected</strong>:保护的，相当于private+子类可见</li><li><strong>internal</strong>:内部的，同一个module可见，这里的module可以就是AndroidStudio中的module，这在写library时非常有用</li></ul><p>Kotlin中少了Java中的default【包内可见】，多了internal【module内可见】。这些可见性修饰符可以用于修饰类、接口、构造函数、方法、属性以及属性的getter和setter访问器。<strong>如果没有显示指定，默认的可见性是public。</strong></p><p>还有就是需要注意的是：<strong>在Kotlin中，外部类无法访问内部类的protected和private成员，而这在Java中则是可以的。</strong></p><h2 id="kotlin的初始化顺序">Kotlin的初始化顺序</h2><ol type="1"><li>父类的伴生对象</li><li>子类的伴生对象</li><li>父类的普通成员变量和init初始化代码块，按照书写顺序</li><li>父类的次构造方法</li><li>子类的普通成员变量和init初始化代码块，按照书写顺序</li><li>子类的次构造方法</li></ol><p>通过下面的例子可以更加容易理解：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">Parent</span></span>(name: String) &#123;</span><br><span class="line">    <span class="keyword">init</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> initBlock = <span class="string">&quot;Parent的初始化代码块&quot;</span>.also &#123; println(it) &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> normalField = <span class="string">&quot;Parent的普通成员变量&quot;</span>.also &#123; println(it) &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">val</span> staticField = <span class="string">&quot;Parent的伴生对象&quot;</span>.also &#123; println(it) &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">constructor</span>(name: String, age: <span class="built_in">Int</span>) : <span class="keyword">this</span>(name) &#123;</span><br><span class="line">        <span class="keyword">val</span> field = <span class="string">&quot;Parent的次构造函数&quot;</span>.also &#123; println(it) &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span></span>(name: String, age: <span class="built_in">Int</span>) : Parent(name, age) &#123;</span><br><span class="line">    <span class="keyword">val</span> normalField = <span class="string">&quot;Child的普通成员变量&quot;</span>.also &#123; println(it) &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> initBlock = <span class="string">&quot;Child的初始化代码块&quot;</span>.also &#123; println(it) &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>(name: String, age: <span class="built_in">Int</span>, address: String) : <span class="keyword">this</span>(name, age) &#123;</span><br><span class="line">        <span class="keyword">val</span> field = <span class="string">&quot;Child的次构造函数&quot;</span>.also &#123; println(it) &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">val</span> staticField = <span class="string">&quot;Child的伴生对象&quot;</span>.also &#123; println(it) &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">/**最终输出结果为：</span></span><br><span class="line"><span class="comment">     * Parent的伴生对象</span></span><br><span class="line"><span class="comment">     * Child的伴生对象</span></span><br><span class="line"><span class="comment">     * Parent的初始化代码块</span></span><br><span class="line"><span class="comment">     * Parent的普通成员变量</span></span><br><span class="line"><span class="comment">     * Parent的次构造函数</span></span><br><span class="line"><span class="comment">     * Child的普通成员变量</span></span><br><span class="line"><span class="comment">     * Child的初始化代码块</span></span><br><span class="line"><span class="comment">     * Child的次构造函数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">val</span> child = Child(<span class="string">&quot;Sky&quot;</span>, <span class="number">22</span>, <span class="string">&quot;China&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;kotlin基础知识&quot;&gt;Kotlin基础知识&lt;/h1&gt;
&lt;h2 id=&quot;gettersetter访问器&quot;&gt;getter、setter访问器&lt;/h2&gt;
&lt;p&gt;getter称为读访问器，setter称为写访问器，val修饰的属性只有getter访问器，var修饰的属性包含getter和setter两种访问器，Kotlin中访问一个属性的本质就是调用getter和setter访问器。&lt;strong&gt;getter的可见性必须和属性声明的可见性一致，setter的可见性不能大于属性声明的可见性(属性可见性为public，setter的可见性可以是private)。&lt;/strong&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Kotlin" scheme="https://sachil.xyz/categories/Kotlin/"/>
    
    
    <category term="Kotlin" scheme="https://sachil.xyz/tags/Kotlin/"/>
    
  </entry>
  
  <entry>
    <title>Jetpack之ViewModel</title>
    <link href="https://sachil.xyz/posts/633e61d5/"/>
    <id>https://sachil.xyz/posts/633e61d5/</id>
    <published>2019-04-27T11:23:50.000Z</published>
    <updated>2023-06-20T15:46:03.207Z</updated>
    
    <content type="html"><![CDATA[<h1 id="jetpack之viewmodel">Jetpack之ViewModel</h1><p><imgsrc="https://gitee.com/sachil/blog-pictures/raw/master/image/ViewModel.png" /></p><p>在上一篇文章：<ahref="https://sachil.xyz/posts/7f4751ab/">Jetpack之LiveData</a>中，我们已经学习到<code>LiveData</code>是一种具有生命周期感知能力并且可观察的数据存储类，同时我们也知道，通常情况下，我们不会不会在生命周期拥有者，例如<code>Activity</code>或者<code>Fragment</code>中去创建<code>LiveData</code>对象，那么我们到底应该在什么地方去创建它的实例对象呢？这就引出了我们今天的主角——<code>ViewModel</code>。</p><p><code>ViewModel</code>意思就是视图模型，设计它的初衷就是以注重生命周期的方式存储和管理界面相关的数据。<strong><code>ViewModel</code>让数据可以在发生屏幕旋转等配置更改后继续存留，而在界面销毁的时候则会正常的跟着销毁</strong>，这可以说是<code>ViewModel</code>最大的特点。在日常开发中，一般将<code>ViewModel</code>和<code>LiveData</code>搭配起来使用。</p><span id="more"></span><h2 id="viewmodel的设计初衷">ViewModel的设计初衷</h2><p>我们都知道，像<code>Activity</code>和<code>Fragment</code>这样的界面控制器的生命周期是由<code>Android</code>系统管理的，在某些场景下(如屏幕旋转)，系统会销毁和重新创建界面控制器，这样存储在其中的任何和界面相关的数据就都会丢失。例如在<code>Activity</code>中包含一个用户列表，当屏幕旋转时，该<code>Activity</code>会被系统销毁并重新创建，新创建的<code>Activity</code>必须重新提取用户列表。当然，对于简单的数据，我们可以使用<code>onSaveInstanceCreate()</code>方法保存在<code>Bundle</code>中，并且在<code>onCreate()</code>回调方法中将它们恢复。但是这个方法仅适合可以序列化再反序列化的少量数据，而不适合数量较大的数据(如图像)，那如果我们有大量的数据需要在<code>Activity</code>被重建之后恢复，应该怎么办？</p><p>再者，在<code>Activity</code>和<code>Fragment</code>中可能需要进行一些耗时异步调用，对于这些异步调用，界面控制器需要管理它们，这样可以确保在界面被销毁后，可以清理这些调用以避免内存泄露。但是管理这些异步调用需要大量的维护工作，那么有没有一种更便捷且高效的方法来管理这些异步调用呢？</p><p>带着这样的疑问，<code>ViewModel</code>被设计出来，它负责为界面准备数据，用于解决上面我们遇到的问题。</p><h2 id="viewmodel的基本使用">ViewModel的基本使用</h2><p>首先是添加<code>ViewModel</code>的依赖，先将Google Maven代码库添加到项目中，然后再将依赖项添加到模块的<code>build.gradle</code>文件中。</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//project目录下的build.gradle文件添加Google Maven</span></span><br><span class="line">repositories &#123;</span><br><span class="line">        google()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//module目录下的build.gradle文件添加ViewModel的依赖(for Kotlin)</span></span><br><span class="line">implementation <span class="string">&quot;androidx.lifecycle:lifecycle-viewmodel-ktx:2.0.0&quot;</span></span><br></pre></td></tr></table></figure><p><code>ViewModel</code>一般是和<code>LiveData</code>搭配在一起来使用：</p><ul><li>首先自定义一个继承自<code>ViewModel</code>的子类。</li><li>在这个子类中可以实现获取界面数据的逻辑，并将这些数据封装为<code>LiveData</code>。</li><li>在<code>Activity</code>或者<code>Fragment</code>中使用<code>ViewModelProvider</code>获取这个子类的实例对象。</li><li>最后使用子类的实例对象获取暴露的<code>LiveData</code>，并开始观察<code>LiveData</code>数据更新界面。</li></ul><p>我们用代码来实现一个自己的<code>ViewModel</code>，首先自定义一个<code>ViewModel</code>:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//继承自ViewModel</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyViewModel</span> : <span class="type">ViewModel</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> message: MutableLiveData&lt;String&gt;</span><br><span class="line">    <span class="comment">//需要将LiveData数据暴露给使用者</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getMessage</span><span class="params">()</span></span>: MutableLiveData&lt;String&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (!::message.isInitialized) &#123;</span><br><span class="line">            message = MutableLiveData()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> message</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//模拟一个耗时的过程，更新Livedata的数据</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">requestMessage</span><span class="params">()</span></span> &#123;</span><br><span class="line">        Thread &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1</span> * <span class="number">1000</span>)</span><br><span class="line">            message.postValue(<span class="string">&quot;Tom and Jerry&quot;</span>)</span><br><span class="line">        &#125;.start()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，我们在<code>Activity</code>中使用这个<code>ViewModel</code>:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyActivity</span> : <span class="type">AppCompatActivity</span></span>() &#123;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">val</span> TAG = <span class="string">&quot;MyActivity&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//这里使用了lazy代理，最终会调用ViewModelProvider的get方法，获取到MyViewModel的实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> viewModel: MyViewModel <span class="keyword">by</span> viewModels()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        Log.e(TAG,<span class="string">&quot;on created.&quot;</span>)</span><br><span class="line">        setContentView(R.layout.activity_my)</span><br><span class="line"></span><br><span class="line">        <span class="comment">//点击按钮开始请求message</span></span><br><span class="line">        myButton.setOnClickListener &#123;</span><br><span class="line">            viewModel.requestMessage()</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//添加message的观察者，一旦有更新就显示更新</span></span><br><span class="line">        viewModel.getMessage().observe(<span class="keyword">this</span>) &#123;</span><br><span class="line">            myTextView.text = it</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onStart</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onStart()</span><br><span class="line">        Log.e(TAG,<span class="string">&quot;on started.&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onResume</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onResume()</span><br><span class="line">        Log.e(TAG,<span class="string">&quot;on resumed.&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onPause</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onPause()</span><br><span class="line">        Log.e(TAG,<span class="string">&quot;on paused.&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onStop</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onStop()</span><br><span class="line">        Log.e(TAG,<span class="string">&quot;on stopped.&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onDestroy</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onDestroy()</span><br><span class="line">        Log.e(TAG,<span class="string">&quot;on destroyed.&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码模拟了一个获取信息并显示的过程，我们自定义了一个<code>ViewModel</code>的子类<code>MyViewModel</code>，并且在其内部定义了一个<code>LiveData</code>类型的成员变量<code>message</code>，然后通过<code>getMessage()</code>方法将这个<code>LiveData</code>暴露给调用者，我们还定义了一个<code>requestMessage()</code>方法来模拟<code>message</code>的更新。在<code>Activity</code>中我们获取到<code>MyViewModel</code>的实例(代码中是通过代理的方式)，然后通过它进而获取到<code>LiveData</code>的实例，并为这个<code>LiveData</code>实例添加了观察者。通过这样的操作，我们就让<code>ViewModel</code>可以管理我们界面有关的数据了，我们看一下效果：</p><p><imgsrc="https://gitee.com/sachil/blog-pictures/raw/master/image/MyViewModel.gif" /></p><p>我们注意到，当我们旋转屏幕的时候，<code>Activity</code>会被销毁和重建，在重建后数据确实得到了恢复，所以我们可以总结到：<strong><code>ViewModel</code>的生命周期会比<code>LifecycleOwner</code>实例的生命周期更长</strong>，这里借用一张官方的图片来说明，当屏幕发生旋转的时候，<code>Activity</code>生命周期的变化以及对应的<code>ViewModel</code>的生命周期：</p><figure><imgsrc="https://gitee.com/sachil/blog-pictures/raw/master/image/viewmodel-lifecycle.png"alt="viewmodel-lifecycle" /><figcaption aria-hidden="true">viewmodel-lifecycle</figcaption></figure><p>所以我们要特别注意一下：<strong>在<code>ViewModel</code>中决不能引用视图、<code>Lifecycle</code>或者可能存储对<code>Activity</code>的引用的任何类</strong>，原因很简单，防止内存泄露。</p><p>我们还可以通过使用<code>ViewModel</code>来实现多个<code>Fragment</code>之间的数据共享：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SharedViewModel</span> : <span class="type">ViewModel</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> message: MutableLiveData&lt;String&gt;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getMessage</span><span class="params">()</span></span>: MutableLiveData&lt;String&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (!::message.isInitialized) &#123;</span><br><span class="line">            message = MutableLiveData()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> message</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">sendMessage</span><span class="params">()</span></span>&#123;</span><br><span class="line">        message.value = <span class="string">&quot;Hello,world&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//第一个Fragment</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FirstFragment</span> : <span class="type">Fragment</span></span>()&#123;</span><br><span class="line">    <span class="comment">//获取到SharedViewModel的实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> viewModel:SharedViewModel <span class="keyword">by</span> activityViewModels()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onViewCreated</span><span class="params">(view: <span class="type">View</span>, savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onViewCreated(view, savedInstanceState)</span><br><span class="line">        <span class="comment">//发送数据</span></span><br><span class="line">        button_first.setOnClickListener &#123;</span><br><span class="line">            viewModel.sendMessage()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//第二个Fragment</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SecondFragment</span> : <span class="type">Fragment</span></span>() &#123;</span><br><span class="line">    <span class="comment">//获取到SharedViewModel的实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> viewModel: SharedViewModel <span class="keyword">by</span> activityViewModels()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onViewCreated</span><span class="params">(view: <span class="type">View</span>, savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onViewCreated(view, savedInstanceState)</span><br><span class="line">        <span class="comment">//观察数据，并接收更新，注意这里LifecycleOwner参数传入的是它的Activity</span></span><br><span class="line">        viewModel.getMessage().observe(requireActivity()) &#123; message -&gt;</span><br><span class="line">            Log.e(<span class="string">&quot;SecondFragment&quot;</span>, <span class="string">&quot;Received:<span class="variable">$message</span>&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上面代码中的两个<code>Fragment</code>都会检索包含它们的<code>Activity</code>，当这两个<code>Fragment</code>各自获取<code>ViewModelProvider</code>的时候它们会收到相同的<code>SharedViewModel</code>实例。使用<code>ViewModel</code>来共享<code>Fragment</code>之间的数据有很多优势：</p><ul><li><code>Activity</code>不需要任何操作，也不需要对数据共享有任何了解。</li><li>除了<code>ViewModel</code>约定之外，<code>Fragment</code>之间不需要相互了解。若其中一个消失，另外一个仍然能够继续正常工作。</li><li>每个<code>Fragment</code>都有自己的生命周期，不受另外一个<code>Fragment</code>生命周期的影响。如果一个<code>Fragment</code>替换另一个<code>Fragment</code>,界面将继续正常工作。</li></ul><h2 id="viewmodel的基本原理">ViewModel的基本原理</h2><h3 id="viewmodelprovider">ViewModelProvider</h3><p>我们在<code>Activity</code>或者<code>Fragment</code>中都是通过创建<code>ViewModelProvider</code>实例再调用它的<code>get()</code>方法来获取到<code>ViewModel</code>实例的，所以我们首先来看一下<code>ViewModelProvider</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//平时最常使用这个构造函数来创建ViewModelProvider实例</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ViewModelProvider</span><span class="params">(<span class="meta">@NonNull</span> ViewModelStoreOwner owner)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(owner.getViewModelStore(), owner <span class="keyword">instanceof</span> HasDefaultViewModelProviderFactory</span><br><span class="line">        ? ((HasDefaultViewModelProviderFactory) owner).getDefaultViewModelProviderFactory()</span><br><span class="line">    : NewInstanceFactory.getInstance());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ViewModelProvider</span><span class="params">(<span class="meta">@NonNull</span> ViewModelStoreOwner owner, <span class="meta">@NonNull</span> Factory factory)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(owner.getViewModelStore(), factory);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ViewModelProvider</span><span class="params">(<span class="meta">@NonNull</span> ViewModelStore store, <span class="meta">@NonNull</span> Factory factory)</span> </span>&#123;</span><br><span class="line">    mFactory = factory;</span><br><span class="line">    mViewModelStore = store;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以看到，<code>ViewModelProvider</code>定义了3个构造函数，我们平时最常使用到的是第一个，但是最终会调用第三个构造函数，我们看到创建<code>ViewModelProvider</code>实例需要一个<code>ViewModelStore</code>对象和一个<code>Factory</code>对象。从名字上我们就可以猜测：<code>ViewModelStoreOwner</code>就是<code>ViewModel</code>的拥有者，<code>ViewModelStore</code>就是<code>ViewModel</code>存储器，<code>Factory</code>就是<code>ViewModel</code>的构造工厂。另外就是<code>ComponentActivity</code>和<code>Fragment</code>实现了<code>ViewModelStoreOwner</code>接口和<code>HasDefaultViewModelProviderFactory</code>接口，所以它们可以获取到<code>ViewModelStore</code>实例和<code>Factory</code>实例。</p><p>我们再来看一下它的<code>get()</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line"><span class="meta">@NonNull</span></span><br><span class="line"><span class="meta">@MainThread</span></span><br><span class="line"><span class="keyword">public</span> &lt;T extends ViewModel&gt; <span class="function">T <span class="title">get</span><span class="params">(<span class="meta">@NonNull</span> String key, <span class="meta">@NonNull</span> Class&lt;T&gt; modelClass)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//先尝试从ViewModelStore中获取，看ViewModel是否已经存在</span></span><br><span class="line">    ViewModel viewModel = mViewModelStore.get(key);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (modelClass.isInstance(viewModel)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mFactory <span class="keyword">instanceof</span> OnRequeryFactory) &#123;</span><br><span class="line">            ((OnRequeryFactory) mFactory).onRequery(viewModel);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (T) viewModel;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//noinspection StatementWithEmptyBody</span></span><br><span class="line">        <span class="keyword">if</span> (viewModel != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// <span class="doctag">TODO:</span> log a warning.</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果ViewModelStore中没有对应的ViewModel，则创建一个</span></span><br><span class="line">    <span class="keyword">if</span> (mFactory <span class="keyword">instanceof</span> KeyedFactory) &#123;</span><br><span class="line">        viewModel = ((KeyedFactory) (mFactory)).create(key, modelClass);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        viewModel = (mFactory).create(modelClass);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//然后将ViewModel存入ViewModelStore</span></span><br><span class="line">    mViewModelStore.put(key, viewModel);</span><br><span class="line">    <span class="keyword">return</span> (T) viewModel;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>get()</code>方法先尝试从<code>mViewModelStore</code>中获取对应的<code>ViewModel</code>实例，如果没有获取到，则会调用<code>mFactory</code>的<code>create()</code>方法来创建对应的<code>ViewModel</code>实例，最后将新创建的<code>ViewModel</code>实例存入<code>mViewModelStore</code>中。所以我们第一次获取<code>ViewModel</code>时会调用<code>mFactory</code>来创建，后续的就是从<code>mViewModelStore</code>中直接返回。</p><h3 id="viewmodelstore">ViewModelStore</h3><p><code>ViewModelProvider</code>在创建的时候需要传入<code>ViewModelStore</code>对象，被用来存储<code>ViewModel</code>实例，那么这个<code>ViewModelStore</code>是如何得到的，又是怎样存储<code>ViewModel</code>实例的呢？我们先看一下<code>ViewModelStore</code>的定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ViewModelStore</span> </span>&#123;</span><br><span class="line">    <span class="comment">//定义一个Hashmap来存储ViewModel实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> HashMap&lt;String, ViewModel&gt; mMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(String key, ViewModel viewModel)</span> </span>&#123;</span><br><span class="line">        ViewModel oldViewModel = mMap.put(key, viewModel);</span><br><span class="line">        <span class="keyword">if</span> (oldViewModel != <span class="keyword">null</span>) &#123;</span><br><span class="line">            oldViewModel.onCleared();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">final</span> ViewModel <span class="title">get</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mMap.get(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Set&lt;String&gt; <span class="title">keys</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HashSet&lt;&gt;(mMap.keySet());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//在界面销毁的时候回被调用，遍历所有ViewModel并销毁它们</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (ViewModel vm : mMap.values()) &#123;</span><br><span class="line">            vm.clear();</span><br><span class="line">        &#125;</span><br><span class="line">        mMap.clear();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，<code>ViewModelStore</code>内部是使用一个<code>HashMap</code>来存储<code>ViewModel</code>实例的，同时我们还注意到它的<code>clear()</code>方法，该方法在界面销毁的时候会被调用，在方法的内部会遍历所存储的所有<code>ViewModel</code>的实例，并调用<code>ViewModel</code>的<code>clear()</code>方法，这样就可以保证<code>ViewModel</code>也随之销毁了。</p><p>我们再来看一下<code>ViewModelStore</code>实例是如何获取到的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ViewModelStoreOwner</span> </span>&#123;</span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    <span class="function">ViewModelStore <span class="title">getViewModelStore</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ViewModelStoreOwner</code>接口提供了一个<code>getViewModelStore()</code>方法来获取<code>ViewModelStore</code>的实例，由于<code>ComponentActivity</code>实现了该接口，所以我们看一下在<code>ComponentActivity</code>中是入伙获取到的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ViewModelStore <span class="title">getViewModelStore</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (getApplication() == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Your activity is not yet attached to the &quot;</span></span><br><span class="line">                + <span class="string">&quot;Application instance. You can&#x27;t request ViewModel before onCreate call.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果mViewModelStore为空，则调用getLastNonConfigurationInstance()方法获取</span></span><br><span class="line">    <span class="keyword">if</span> (mViewModelStore == <span class="keyword">null</span>) &#123;</span><br><span class="line">        NonConfigurationInstances nc =</span><br><span class="line">                (NonConfigurationInstances) getLastNonConfigurationInstance();</span><br><span class="line">        <span class="keyword">if</span> (nc != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// Restore the ViewModelStore from NonConfigurationInstances</span></span><br><span class="line">            mViewModelStore = nc.viewModelStore;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果没有获取到就新创建一个ViewModelStore，同时赋值给mViewModelStore</span></span><br><span class="line">        <span class="keyword">if</span> (mViewModelStore == <span class="keyword">null</span>) &#123;</span><br><span class="line">            mViewModelStore = <span class="keyword">new</span> ViewModelStore();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mViewModelStore;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们看到<code>getViewModelStore()</code>方法会先尝试调用<code>getLastNonConfigurationInstance()</code>方法来获取实例，如果没有获取到，再新创建一个。那我们再看一下<code>getLastNonConfigurationInstance()</code>方法，这个方法是在<code>Activity</code>中定义的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Activity.java</span></span><br><span class="line"><span class="meta">@UnsupportedAppUsage</span></span><br><span class="line"><span class="comment">/* package */</span> NonConfigurationInstances mLastNonConfigurationInstances;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonConfigurationInstances</span> </span>&#123;</span><br><span class="line">    Object activity;</span><br><span class="line">    HashMap&lt;String, Object&gt; children;</span><br><span class="line">    FragmentManagerNonConfig fragments;</span><br><span class="line">    ArrayMap&lt;String, LoaderManager&gt; loaders;</span><br><span class="line">    VoiceInteractor voiceInteractor;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getLastNonConfigurationInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mLastNonConfigurationInstances != <span class="keyword">null</span></span><br><span class="line">    ? mLastNonConfigurationInstances.activity : <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到该方法就是尝试返回类型为<code>NonConfigurationInstances</code>的实例<code>mLastNonConfigurationInstances</code>中的<code>activity</code>变量，而这个<code>mLastNonConfigurationInstances</code>会在<code>Activity</code>的<code>onAttach()</code>方法中被传入的参数赋值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@UnsupportedAppUsage</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">attach</span><span class="params">(Context context, ActivityThread aThread,</span></span></span><br><span class="line"><span class="function"><span class="params">Instrumentation instr, IBinder token, <span class="keyword">int</span> ident,</span></span></span><br><span class="line"><span class="function"><span class="params">Application application, Intent intent, ActivityInfo info,</span></span></span><br><span class="line"><span class="function"><span class="params">CharSequence title, Activity parent, String id,</span></span></span><br><span class="line"><span class="function"><span class="params">NonConfigurationInstances lastNonConfigurationInstances,</span></span></span><br><span class="line"><span class="function"><span class="params">Configuration config, String referrer, IVoiceInteractor voiceInteractor,</span></span></span><br><span class="line"><span class="function"><span class="params">Window window, ActivityConfigCallback activityConfigCallback, IBinder assistToken)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//在这里被传入的参数赋值</span></span><br><span class="line">    mLastNonConfigurationInstances = lastNonConfigurationInstances;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们再来看一下<code>ComponentActivity</code>的<code>onRetainNonConfigurationInstance()</code>方法，该方法在<code>Activity</code>因为配置改变而需要销毁重建前会被调用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ComponentActivity.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonConfigurationInstances</span> </span>&#123;</span><br><span class="line">    Object custom;</span><br><span class="line">    ViewModelStore viewModelStore;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Object <span class="title">onRetainNonConfigurationInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Object custom = onRetainCustomNonConfigurationInstance();</span><br><span class="line"></span><br><span class="line">    ViewModelStore viewModelStore = mViewModelStore;</span><br><span class="line">    <span class="keyword">if</span> (viewModelStore == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// No one called getViewModelStore(), so see if there was an existing</span></span><br><span class="line">        <span class="comment">// ViewModelStore from our last NonConfigurationInstance</span></span><br><span class="line">        NonConfigurationInstances nc =</span><br><span class="line">        (NonConfigurationInstances) getLastNonConfigurationInstance();</span><br><span class="line">        <span class="keyword">if</span> (nc != <span class="keyword">null</span>) &#123;</span><br><span class="line">            viewModelStore = nc.viewModelStore;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (viewModelStore == <span class="keyword">null</span> &amp;&amp; custom == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    NonConfigurationInstances nci = <span class="keyword">new</span> NonConfigurationInstances();</span><br><span class="line">    nci.custom = custom;</span><br><span class="line">    nci.viewModelStore = viewModelStore;</span><br><span class="line">    <span class="keyword">return</span> nci;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到在<code>ComponentActivity</code>内部也定义了一个名字和<code>Activity</code>内部一样的类<code>NonConfigurationInstances</code>,并在<code>onRetainNonConfigurationInstance()</code>方法中创建了一个它的实例，并用这个实例来保存<code>ViewModelStore</code>实例，意思就是当因配置改变而需要重建<code>Activity</code>时，会将原来的<code>ViewModelStore</code>保存起来。这个方法会被<code>Activity</code>的<code>retainNonConfigurationInstances()</code>方法调用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Activity.java</span></span><br><span class="line"><span class="function">NonConfigurationInstances <span class="title">retainNonConfigurationInstances</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//调用ComponentActivity中的onRetainNonConfigurationInstance()方法</span></span><br><span class="line">    Object activity = onRetainNonConfigurationInstance();</span><br><span class="line">    ...</span><br><span class="line">     <span class="comment">//创建一个NonConfigurationInstances实例</span></span><br><span class="line">    NonConfigurationInstances nci = <span class="keyword">new</span> NonConfigurationInstances();</span><br><span class="line">    <span class="comment">//将ComponentActivity中的NonConfigurationInstances实例保存到activity变量</span></span><br><span class="line">    nci.activity = activity;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> nci;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过上面的分析我们可以明白，<code>ComponentActivity</code>第一次调用<code>getViewModelStore()</code>方法创建创建一个<code>ViewModelStore</code>实例，当<code>ComponentActivity</code>因为配置改变而销毁重建前，会将这个<code>ViewModelStore</code>实例封装成一个<code>ComponentActivity</code>的<code>NonConfigurationInstances</code>实例，再将这个<code>ComponentActivity</code>的<code>NonConfigurationInstances</code>实例封装成一个<code>Activity</code>的<code>NonConfigurationInstances</code>实例,最后这个<code>Activity</code>的<code>NonConfigurationInstances</code>实例被系统保存起来。当<code>ComponentActivity</code>销毁重建时，系统会将保存起来的这个<code>Activity</code>的<code>NonConfigurationInstances</code>实例通过<code>attach()</code>方法传入，并赋值给<code>activity</code>的<code>mLastNonConfigurationInstances</code>成员变量，这时再次调用<code>ComponentActivity</code>的<code>getViewModelStore()</code>方法时，就会通过这个<code>mLastNonConfigurationInstances</code>获取到原来所创建的那个<code>ViewModelStore</code>实例。</p><p>这样就明白了当<code>Activity</code>因配置改变而销毁重建后，<code>ViewModel</code>依然存在的原理了。</p><h3 id="构造工厂factory">构造工厂Factory</h3><p>我们回过头再来看一下创建<code>ViewModelProvider</code>时的另一个参数<code>factory</code>，它是一个定义在<code>ViewModelProvider</code>内部的接口，提供一个<code>create()</code>方法来创建<code>ViewModel</code>的实例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Implementations of &#123;<span class="doctag">@code</span> Factory&#125; interface are responsible to instantiate ViewModels.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates a new instance of the given &#123;<span class="doctag">@code</span> Class&#125;.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> modelClass a &#123;<span class="doctag">@code</span> Class&#125; whose instance is requested</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;T&gt;        The type parameter for the ViewModel.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> a newly created ViewModel</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    &lt;T extends ViewModel&gt; <span class="function">T <span class="title">create</span><span class="params">(<span class="meta">@NonNull</span> Class&lt;T&gt; modelClass)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>ComponentActivity</code>中则是通过实现<code>HasDefaultViewModelProviderFactory</code>接口，并重写该接口的<code>getDefaultViewModelProviderFactory()</code>方法来获取一个<code>Factory</code>的实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@NonNull</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> ViewModelProvider.<span class="function">Factory <span class="title">getDefaultViewModelProviderFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (getApplication() == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Your activity is not yet attached to the &quot;</span></span><br><span class="line">                + <span class="string">&quot;Application instance. You can&#x27;t request ViewModel before onCreate call.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mDefaultFactory == <span class="keyword">null</span>) &#123;</span><br><span class="line">        mDefaultFactory = <span class="keyword">new</span> SavedStateViewModelFactory(</span><br><span class="line">                getApplication(),</span><br><span class="line">        <span class="keyword">this</span>,</span><br><span class="line">        getIntent() != <span class="keyword">null</span> ? getIntent().getExtras() : <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mDefaultFactory;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法利用<code>Application</code>、当前<code>ComponentActivity</code>实例和<code>Intent</code>中的数据创建了一个<code>SavedStateViewModelFactory</code>的实例，并返回。我们接着看一下<code>SavedStateViewModelFactory</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">SavedStateViewModelFactory</span> <span class="keyword">extends</span> <span class="title">ViewModelProvider</span>.<span class="title">KeyedFactory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Application mApplication;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ViewModelProvider.AndroidViewModelFactory mFactory;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Bundle mDefaultArgs;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Lifecycle mLifecycle;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> SavedStateRegistry mSavedStateRegistry;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SavedStateViewModelFactory</span><span class="params">(<span class="meta">@NonNull</span> Application application,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="meta">@NonNull</span> SavedStateRegistryOwner owner)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(application, owner, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@SuppressLint(&quot;LambdaLast&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SavedStateViewModelFactory</span><span class="params">(<span class="meta">@NonNull</span> Application application,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="meta">@NonNull</span> SavedStateRegistryOwner owner,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="meta">@Nullable</span> Bundle defaultArgs)</span> </span>&#123;</span><br><span class="line">        mSavedStateRegistry = owner.getSavedStateRegistry();</span><br><span class="line">        mLifecycle = owner.getLifecycle();</span><br><span class="line">        mDefaultArgs = defaultArgs;</span><br><span class="line">        mApplication = application;</span><br><span class="line">        mFactory = ViewModelProvider.AndroidViewModelFactory.getInstance(application);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T extends ViewModel&gt; <span class="function">T <span class="title">create</span><span class="params">(<span class="meta">@NonNull</span> String key, <span class="meta">@NonNull</span> Class&lt;T&gt; modelClass)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> isAndroidViewModel = AndroidViewModel.class.isAssignableFrom(modelClass);</span><br><span class="line">        Constructor&lt;T&gt; constructor;</span><br><span class="line">        <span class="keyword">if</span> (isAndroidViewModel) &#123;</span><br><span class="line">            constructor = findMatchingConstructor(modelClass, ANDROID_VIEWMODEL_SIGNATURE);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            constructor = findMatchingConstructor(modelClass, VIEWMODEL_SIGNATURE);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// doesn&#x27;t need SavedStateHandle</span></span><br><span class="line">        <span class="keyword">if</span> (constructor == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> mFactory.create(modelClass);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        SavedStateHandleController controller = SavedStateHandleController.create(</span><br><span class="line">                mSavedStateRegistry, mLifecycle, key, mDefaultArgs);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            T viewmodel;</span><br><span class="line">            <span class="keyword">if</span> (isAndroidViewModel) &#123;</span><br><span class="line">                viewmodel = constructor.newInstance(mApplication, controller.getHandle());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                viewmodel = constructor.newInstance(controller.getHandle());</span><br><span class="line">            &#125;</span><br><span class="line">            viewmodel.setTagIfAbsent(TAG_SAVED_STATE_HANDLE_CONTROLLER, controller);</span><br><span class="line">            <span class="keyword">return</span> viewmodel;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;Failed to access &quot;</span> + modelClass, e);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InstantiationException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;A &quot;</span> + modelClass + <span class="string">&quot; cannot be instantiated.&quot;</span>, e);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;An exception happened in constructor of &quot;</span></span><br><span class="line">                    + modelClass, e.getCause());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们重点看一下它的<code>create()</code>方法，该方法支持创建三种类型的<code>ViewModel</code>实例，它们分别是<code>AndroidViewModel</code>、支持SavedState的<code>ViewModel</code>和普通的<code>ViewModel</code>，看一下普通的<code>ViewModel</code>的创建，可以看到它是通过<code>mFactory</code>来创建的，而<code>mFracory</code>是<code>AndroidViewModelFactory</code>的实例，所以我们来看一下它的<code>create()</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@NonNull</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;T extends ViewModel&gt; <span class="function">T <span class="title">create</span><span class="params">(<span class="meta">@NonNull</span> Class&lt;T&gt; modelClass)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (AndroidViewModel.class.isAssignableFrom(modelClass)) &#123;</span><br><span class="line">        <span class="comment">//noinspection TryWithIdenticalCatches</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> modelClass.getConstructor(Application.class).newInstance(mApplication);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;Cannot create an instance of &quot;</span> + modelClass, e);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;Cannot create an instance of &quot;</span> + modelClass, e);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InstantiationException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;Cannot create an instance of &quot;</span> + modelClass, e);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;Cannot create an instance of &quot;</span> + modelClass, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.create(modelClass);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在该方法内部先判断创建的<code>ViewModel</code>是否是<code>AndroidViewModel</code>，如果是的话就利用反射传入<code>application</code>创建，如果不是则调用<code>AndroidViewModelFactory</code>的父类来创建，<code>AndroidViewModelFactory</code>的父类是<code>NewInstanceFactory</code>，所以我们再来看一下<code>NewInstanceFactory</code>的<code>create()</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@NonNull</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;T extends ViewModel&gt; <span class="function">T <span class="title">create</span><span class="params">(<span class="meta">@NonNull</span> Class&lt;T&gt; modelClass)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//noinspection TryWithIdenticalCatches</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> modelClass.newInstance();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InstantiationException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;Cannot create an instance of &quot;</span> + modelClass, e);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;Cannot create an instance of &quot;</span> + modelClass, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到在方法的内部直接利用反射来创建<code>ViewModel</code>的实例。</p><p>结合上面的分析我们可以明白：<code>SavedStateViewModelFactory</code>作为<code>ComponentActivity</code>和<code>Fragment</code>的对象，在<code>NewInstanceFactory</code>的基础上又提供了对<code>AndroidViewModel</code>和SavedState的<code>ViewModel</code>的创建，但是在创建普通<code>ViewModel</code>的时候，仍然使用的是<code>NewInstanceFactory</code>的<code>create()</code>方法来创建。</p><p>至此，<code>ViewModel</code>的基本原理我们也就明白了。</p><hr /><p>参考文档：</p><p><ahref="https://developer.android.com/topic/libraries/architecture/viewmodel">官方文档</a></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;jetpack之viewmodel&quot;&gt;Jetpack之ViewModel&lt;/h1&gt;
&lt;p&gt;&lt;img
src=&quot;https://gitee.com/sachil/blog-pictures/raw/master/image/ViewModel.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;在上一篇文章：&lt;a
href=&quot;https://sachil.xyz/posts/7f4751ab/&quot;&gt;Jetpack之LiveData&lt;/a&gt;中，我们已经学习到&lt;code&gt;LiveData&lt;/code&gt;是一种具有生命周期感知能力并且可观察的数据存储类，同时我们也知道，通常情况下，我们不会不会在生命周期拥有者，例如&lt;code&gt;Activity&lt;/code&gt;或者&lt;code&gt;Fragment&lt;/code&gt;中去创建&lt;code&gt;LiveData&lt;/code&gt;对象，那么我们到底应该在什么地方去创建它的实例对象呢？这就引出了我们今天的主角——&lt;code&gt;ViewModel&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ViewModel&lt;/code&gt;意思就是视图模型，设计它的初衷就是以注重生命周期的方式存储和管理界面相关的数据。&lt;strong&gt;&lt;code&gt;ViewModel&lt;/code&gt;让数据可以在发生屏幕旋转等配置更改后继续存留，而在界面销毁的时候则会正常的跟着销毁&lt;/strong&gt;，这可以说是&lt;code&gt;ViewModel&lt;/code&gt;最大的特点。在日常开发中，一般将&lt;code&gt;ViewModel&lt;/code&gt;和&lt;code&gt;LiveData&lt;/code&gt;搭配起来使用。&lt;/p&gt;</summary>
    
    
    
    <category term="Jetpack" scheme="https://sachil.xyz/categories/Jetpack/"/>
    
    
    <category term="Android" scheme="https://sachil.xyz/tags/Android/"/>
    
    <category term="Jetpack" scheme="https://sachil.xyz/tags/Jetpack/"/>
    
  </entry>
  
  <entry>
    <title>Jetpack之LiveData</title>
    <link href="https://sachil.xyz/posts/7f4751ab/"/>
    <id>https://sachil.xyz/posts/7f4751ab/</id>
    <published>2019-04-17T11:40:35.000Z</published>
    <updated>2023-06-20T15:46:03.207Z</updated>
    
    <content type="html"><![CDATA[<h1 id="jetpack之livedata">Jetpack之LiveData</h1><p><imgsrc="https://gitee.com/sachil/blog-pictures/raw/master/image/livedata.png" /></p><p>在文章<ahref="https://sachil.xyz/posts/550ac800/">Jetpack之Lifecycle</a>中，我们已经学习了一个基础的组件：<code>Lifecycle</code>，并已经明白它是一个生命周期感知型组件，用来响应<code>Activity</code>和<code>Fragment</code>的生命周期状态的变化。今天我们来学习一下<code>Architecture</code>中基于<code>Lifecycle</code>的另一个组件——<code>Livedata</code>。</p><h2 id="livedata是什么">LiveData是什么？</h2><p><code>LiveData</code>是一种可观察的数据存储类，它具有生命周期感知能力，意思就是它遵循像<code>Activity</code>和<code>Fragment</code>这样的生命周期拥有者的生命周期，这种感知能力可以确保<code>LiveData</code>只更新处于活跃生命周期状态的应用组件观察者。</p><p><code>LiveData</code>将生命周期状态中的<code>STARTED</code>和<code>RESUMED</code>认为是活跃状态，将其它的生命周期状态如：<code>INITIALZED</code>、<code>CREATED</code>和<code>DESTROYED</code>被认为是非活跃状态。<code>LiveData</code>仍然使用的是观察者模式，只有当观察者的声明周期处于活跃状态时，才会收到来自<code>LiveData</code>的数据更新，而生命周期处于非活跃状态的观察者则不会收到数据更新。这样的设计方式很符合日常的逻辑，想象一下如果我们使用一个界面来显示数据，当这个界面不在前台时，即使这个数据有更新，我们也不需要马上刷新界面，因为这样做意义不大。</p><span id="more"></span><h2 id="livedata的作用">LiveData的作用</h2><p>使用<code>LiveData</code>可以给我们带来这些好处：</p><ul><li><strong>确保界面符合数据状态</strong>，当数据发生变化时，<code>LiveData</code>会通知观察者，你可以在观察者中来更新界面。</li><li><strong>不会发生内存泄露</strong>，观察者会在<code>LifecycleOwner</code>生命周期状态变为<code>DESTROYED</code>后自动删除。</li><li><strong>不会因为生命周期拥有者停止而崩溃</strong>，如果观察者处于非活跃状态，那么它将不会收到<code>LiveData</code>的数据更新。</li><li><strong>不在需要手动处理生命周期</strong>，<code>LiveData</code>可以感知生命周期的变化，所以不用手动的解除观察，它可以自动管理这些操作。</li><li><strong>数据始终保持最新状态</strong>，当观察者的生命周期状态从非活跃状态变为活跃状态时，它会收到<code>LiveData</code>最新的数据更新。</li></ul><h2 id="livedata的基本使用">LiveData的基本使用</h2><p>要想在我们的工程中使用<code>LiveData</code>，第一步当然是添加依赖，首先您必须将GoogleMaven代码库添加到项目中，然后再在模块的<code>build.gradle</code>文件中添加所需工作的依赖项：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//project目录下的build.gradle文件添加Google Maven</span></span><br><span class="line">repositories &#123;</span><br><span class="line">        google()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//module目录下的build.gradle文件添加LiveData的依赖(for Kotlin)</span></span><br><span class="line">implementation <span class="string">&quot;androidx.lifecycle:lifecycle-livedata-ktx:2.0.0&quot;</span></span><br></pre></td></tr></table></figure><p>接下来我们就可以开始使用<code>LiveData</code>了，使用的方式一般是这样的：</p><ul><li>创建一个<code>LiveData</code>对象，一般情况下我们使用它的子类<code>MutableLiveData</code>来创建这个对象，并指定数据类型。</li><li>创建一个<code>Observer</code>对象，也就是创建一个观察者，并重写它的<code>onChanged()</code>方法，这个方法是用于接收数据更新从而来更新界面的。</li><li>调用已创建好的<code>LiveData</code>对象的<code>observe()</code>方法，并传入一个<code>LifecycleOwner</code>对象和一个<code>Observer</code>对象作为参数</li><li>当数据发生改变时，使用<code>LiveData</code>的<code>setValue()</code>方法或者<code>postValue()</code>(用于子线程)方法来通知<code>Observer</code>数据已更新。</li></ul><p>我们看一下最简单的使用：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> : <span class="type">AppCompatActivity</span></span>() &#123;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">val</span> TAG = <span class="string">&quot;MainActivity&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建一个LiveData的对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> liveData = MutableLiveData&lt;String&gt;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        Log.e(TAG, <span class="string">&quot;onCreate&quot;</span>)</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_main)</span><br><span class="line">        setSupportActionBar(findViewById(R.id.toolbar))</span><br><span class="line">        <span class="comment">//创建一个Observer(即观察者)对象，重写它的onChanged()方法</span></span><br><span class="line">        <span class="keyword">val</span> observer: (String) -&gt; <span class="built_in">Unit</span> = &#123;</span><br><span class="line">            Log.e(TAG,<span class="string">&quot;new value is:<span class="variable">$it</span>&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将liveData、生命周期拥有者以及观察者都关联起来</span></span><br><span class="line">        liveData.observe(<span class="keyword">this</span>,observer)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onStart</span><span class="params">()</span></span> &#123;</span><br><span class="line">        Log.e(TAG, <span class="string">&quot;onStart&quot;</span>)</span><br><span class="line">        <span class="keyword">super</span>.onStart()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onResume</span><span class="params">()</span></span> &#123;</span><br><span class="line">        Log.e(TAG, <span class="string">&quot;onResume&quot;</span>)</span><br><span class="line">        <span class="comment">//更新liveData中的数据，这样Observer就可以收到这个数据更新。</span></span><br><span class="line">        <span class="comment">//注意，这时候Observer是处于活跃状态的</span></span><br><span class="line">        liveData.value = <span class="string">&quot;Hello world!&quot;</span></span><br><span class="line">        <span class="keyword">super</span>.onResume()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onPause</span><span class="params">()</span></span> &#123;</span><br><span class="line">        Log.e(TAG, <span class="string">&quot;onPause&quot;</span>)</span><br><span class="line">        <span class="keyword">super</span>.onPause()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onStop</span><span class="params">()</span></span> &#123;</span><br><span class="line">        Log.e(TAG, <span class="string">&quot;onStop&quot;</span>)</span><br><span class="line">        <span class="keyword">super</span>.onStop()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onDestroy</span><span class="params">()</span></span> &#123;</span><br><span class="line">        Log.e(TAG, <span class="string">&quot;onDestroy&quot;</span>)</span><br><span class="line">        <span class="keyword">super</span>.onDestroy()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码很容易理解，不过在平时日常开发中我们不会这样使用，我们一般不会在<code>Activity</code>或者<code>Fragment</code>中去创建<code>LiveData</code>对象，一是因为这样可以避免<code>Activity</code>或者<code>Fragment</code>过于庞大，这些界面控制器只负责显示数据，而不负责存储数据，再者就是如果当配置发生改变(如屏幕旋转)后，可以让数据继续存在并用来恢复界面。</p><p>我们还可以从上面的代码做一些思考，现在我们已经知道<code>LifeCycle</code>和<code>LiveData</code>都是采用的是观察者模式，在学习<code>LifeCycle</code>的时候我们已经清楚，我们自定义的<code>LifecycleObserver</code>对象就是观察者，而像<code>Activity</code>和<code>Fragment</code>这样实现了<code>LifecycleOwner</code>接口的组件就是被观察者，<code>LifecycleObserver</code>对象观察的是<code>LifecycleOwner</code>对象的生命周期状态的变化。而在<code>LiveData</code>中观察者和被观察者又分别指的是谁呢？从上面的代码中我们应该可以想到<code>Observer</code>对象就是观察者，<code>LiveData</code>就是被观察者，<code>Observer</code>观察的是<code>LiveData</code>中数据的变化。但是如果我们查看<code>Observer</code>的源码可以发现，它只是一个拥有一个<code>onChanged()</code>方法的接口，所以它不应该有生命周期，那我们前面所提到的“观察者的生命周期”是怎么回事？其实就是<code>LiveData</code>的<code>observe()</code>方法，这个方法同时传入一个<code>LifecycleOwner</code>对象和一个<code>Observer</code>对象，这样就让这个<code>Observer</code>对象依附在了这个<code>LifecycleOwner</code>对象之上，也就是说<code>Observer</code>的生命周期就是<code>LifecycleOwner</code>的生命周期。</p><h2 id="livedata的其它用法">LiveData的其它用法</h2><p><code>LiveData</code>除了最基本的使用方式之外，我们还可以定义一个<code>LiveData</code>的子类来扩展它的用法：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyLiveData</span> <span class="keyword">private</span> <span class="keyword">constructor</span></span>() : LiveData&lt;String&gt;() &#123;</span><br><span class="line">    <span class="comment">//单例模式</span></span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="meta">@Volatile</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">var</span> instance: MyLiveData? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">getInstance</span><span class="params">()</span></span>: MyLiveData = instance ?: synchronized(<span class="keyword">this</span>) &#123;</span><br><span class="line">            instance ?: MyLiveData().also &#123; instance = it &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在LiveData的活跃的观察者数量从0变为1时，会被调用</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onActive</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">//do something</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在LiveData的活跃的观察者数量从1变为0时，会被调用</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onInactive</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以重写它的<code>onActive()</code>方法和<code>onInactive()</code>方法，<code>onActive()</code>方法会在<code>LiveData</code>的活跃的观察者从无到有的时候被调用，而<code>onInactive()</code>方法则会在它活跃的观察者从有到无的时候被调用，我们可以在这两个方法中实现一些自己的逻辑。我们还可以将<code>LiveData</code>定义成单例模式，这样就可以在多个<code>Activity</code>或者<code>Fragment</code>之间共享数据了。</p><p>另外<code>LiveData</code>还为我们提供了一个<code>Transformations</code>类，它可以被用来转换<code>LiveData</code>，例如你可以是使用<code>map()</code>方法在将<code>LiveData</code>中存储的数据分发给观察者之前对数据进行更改，还可以使用<code>switchMap()</code>方法将原<code>LiveData</code>转变为新的<code>LiveData</code>，如果你熟悉<code>Rxjava</code>，那么你对这两个方法就会感到非常熟悉。</p><p><code>LiveData</code>还提供过了一个它的子类<code>MediatorLiveData</code>，被用来合并多个<code>LiveData</code>对象，只要其中任何一个<code>LiveData</code>对象发生改变，就会触发<code>MediatorLiveData</code>对象的观察者。</p><h2 id="livedata的工作原理">LiveData的工作原理</h2><p>能够使用<code>LiveData</code>是最基本的要求，我们在使用的同时还需要去了解它的原理，这样我们才能更加从容的使用<code>LiveData</code>。</p><h3 id="observe方法">observe()方法</h3><p>我们首先来看一下<code>LiveData</code>的<code>observe()</code>方法，这个方法会让<code>LiveData</code>、<code>LifecycleOwner</code>和<code>Observer</code>三者之间产生联系：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">observe</span><span class="params">(<span class="meta">@NonNull</span> LifecycleOwner owner, <span class="meta">@NonNull</span> Observer&lt;? <span class="keyword">super</span> T&gt; observer)</span> </span>&#123;</span><br><span class="line">    assertMainThread(<span class="string">&quot;observe&quot;</span>);</span><br><span class="line">    <span class="comment">//如果生命周期拥有者的状态已经是DESTORYED，则</span></span><br><span class="line">    <span class="keyword">if</span> (owner.getLifecycle().getCurrentState() == DESTROYED) &#123;</span><br><span class="line">        <span class="comment">// ignore</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将LifecycleOwner和Observer封装成一个LifecycleBoundObserver</span></span><br><span class="line">    LifecycleBoundObserver wrapper = <span class="keyword">new</span> LifecycleBoundObserver(owner, observer);</span><br><span class="line">    <span class="comment">//将这个封装好的LifecycleBoundObserver添加到mObservers双向链表中</span></span><br><span class="line">    ObserverWrapper existing = mObservers.putIfAbsent(observer, wrapper);</span><br><span class="line">    <span class="comment">//如果已经存在的Observer所绑定的LifecycleOwner和这一次传入的LifecycleOwner不一致</span></span><br><span class="line">    <span class="comment">//则报错。意思就是同一个Observer不能绑定不同的lifecycleOwner</span></span><br><span class="line">    <span class="keyword">if</span> (existing != <span class="keyword">null</span> &amp;&amp; !existing.isAttachedTo(owner)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Cannot add the same observer&quot;</span></span><br><span class="line">                + <span class="string">&quot; with different lifecycles&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果已经存在就直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (existing != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//这里调用的是Lifecycle中的方法，让这个LifecycleBoundObserver观察LifecycleOwner</span></span><br><span class="line">    <span class="comment">//的生命周期状态的变化</span></span><br><span class="line">    owner.getLifecycle().addObserver(wrapper);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的代码中我们可以看到，<code>observe()</code>方法首先判断传入的生命周期拥有者的生命周期状态是否处于<code>DESTORYED</code>状态，如果是就直接返回，然后会将传入的<code>LifecycleOwner</code>对象和<code>Observer</code>对象封装为一个<code>LifecycleBoundObserver</code>对象，并添加到<code>mObservers</code>双向链表中。接着就进行了一些判断，如果在在添加的时候，已经存在相同<code>Observer</code>的节点，并且这个已存在的<code>Observer</code>所绑定的<code>LifecycleOwner</code>和这次不一样，就会报错。也就是说不能给同一个<code>Observer</code>绑定不同的<code>LifecycleOwner</code>，这其实很好理解，因为<code>Observer</code>的生命周期是依附在<code>LifecycleOwner</code>上来实现的，如果绑定了不同的<code>LifecycleOwner</code>，<code>Observer</code>的生命周期应该遵循哪一个<code>LifecycleOwner</code>呢，这就有冲突，当然这里是后绑定的<code>LifecycleOwner</code>是无效的，但是调用者可能会产生疑惑，所以这里直接报错。最后就是调用<code>Lifecycle</code>的<code>addObserver()</code>方法，让这个新添加的<code>LifecycleBoundObserver</code>观察<code>LifecycleOwner</code>的生命周期状态的变化。</p><h3 id="lifecycleboundobserver">LifecycleBoundObserver</h3><p>接着我们来看一下<code>LifecycleBoundObserver</code>这个类，它是<code>LiveData</code>中定义的一个内部类，这是它的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LifecycleBoundObserver</span> <span class="keyword">extends</span> <span class="title">ObserverWrapper</span> <span class="keyword">implements</span> <span class="title">LifecycleEventObserver</span> </span>&#123;</span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    <span class="keyword">final</span> LifecycleOwner mOwner;</span><br><span class="line"></span><br><span class="line">    LifecycleBoundObserver(<span class="meta">@NonNull</span> LifecycleOwner owner, Observer&lt;? <span class="keyword">super</span> T&gt; observer) &#123;</span><br><span class="line">        <span class="keyword">super</span>(observer);</span><br><span class="line">        mOwner = owner;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断LifecycleOwner的生命周期状态是否大于等于STARTED</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">shouldBeActive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mOwner.getLifecycle().getCurrentState().isAtLeast(STARTED);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当LifecycleOwner的生命周期状态发生改变时，这个方法就会被调用</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStateChanged</span><span class="params">(<span class="meta">@NonNull</span> LifecycleOwner source,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="meta">@NonNull</span> Lifecycle.Event event)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//如果生命周期状态是DESTROYED，则删除观察者Observer</span></span><br><span class="line">        <span class="keyword">if</span> (mOwner.getLifecycle().getCurrentState() == DESTROYED) &#123;</span><br><span class="line">            removeObserver(mObserver);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//这个方法在父类中实现</span></span><br><span class="line">        activeStateChanged(shouldBeActive());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isAttachedTo</span><span class="params">(LifecycleOwner owner)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mOwner == owner;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这里取消对LifecycleOwner生命周期状态变化的观察</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">detachObserver</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mOwner.getLifecycle().removeObserver(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以看到<code>LifecycleBoundObserver</code>继承自<code>ObserverWrapper</code>，并且同时实现了<code>LifecycleEventObserver</code>接口，这个接口是<code>LifecycleObserver</code>接口的子类，在<code>LifecycleEventObserver</code>中定义了<code>onStateChanged()</code>方法(一种似曾相识的感觉啊！)，这样<code>LifecycleBoundObserver</code>就可以观察<code>LifecycleOwner</code>的生命周期了(就像<code>observe()</code>方法中那样)。<code>LifecycleBoundObserver</code>重写了<code>onStateChanged()</code>方法，并且还重写了父类<code>ObserverWrapper</code>中的一些方法，具体的说明可以看上面代码的注释。</p><h3 id="observerwrapper">ObserverWrapper</h3><p>我们再来看一下父类<code>ObserverWrapper</code>,它也是<code>LiveData</code>中的一个内部类，并且是一个抽象类，这是它的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ObserverWrapper</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Observer&lt;? <span class="keyword">super</span> T&gt; mObserver;</span><br><span class="line">    <span class="comment">//标记是否处于活跃状态</span></span><br><span class="line">    <span class="keyword">boolean</span> mActive;</span><br><span class="line">    <span class="comment">//用来记录数据的新旧程度</span></span><br><span class="line">    <span class="keyword">int</span> mLastVersion = START_VERSION;</span><br><span class="line"></span><br><span class="line">    ObserverWrapper(Observer&lt;? <span class="keyword">super</span> T&gt; observer) &#123;</span><br><span class="line">        mObserver = observer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">shouldBeActive</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isAttachedTo</span><span class="params">(LifecycleOwner owner)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">detachObserver</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">activeStateChanged</span><span class="params">(<span class="keyword">boolean</span> newActive)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//如果活跃状态未发生变化，则直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (newActive == mActive) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//更新状态</span></span><br><span class="line">        mActive = newActive;</span><br><span class="line">        <span class="comment">//mActiveCount为0意思就是没有活跃的观察者</span></span><br><span class="line">        <span class="keyword">boolean</span> wasInactive = LiveData.<span class="keyword">this</span>.mActiveCount == <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//如果观察者从非活跃状态变为活跃状态，则mActiveCount加1，反之减1</span></span><br><span class="line">        LiveData.<span class="keyword">this</span>.mActiveCount += mActive ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//当LiveData的活跃的观察者个数0变为1时，调用onActive()方法</span></span><br><span class="line">        <span class="keyword">if</span> (wasInactive &amp;&amp; mActive) &#123;</span><br><span class="line">            <span class="comment">//默认是空方法，我们在自定义LiveData时可以重写</span></span><br><span class="line">            onActive();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//当LiveData的活跃的观察者个数从1变为0时，调用onInactive()方法</span></span><br><span class="line">        <span class="keyword">if</span> (LiveData.<span class="keyword">this</span>.mActiveCount == <span class="number">0</span> &amp;&amp; !mActive) &#123;</span><br><span class="line">            <span class="comment">//默认是空方法，我们在自定义LiveData时可以重写</span></span><br><span class="line">            onInactive();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//当这个观察者从非活跃状态变为活跃状态时，向它发送数据更新</span></span><br><span class="line">        <span class="keyword">if</span> (mActive) &#123;</span><br><span class="line">            dispatchingValue(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们重点关注一下<code>activeStateChanged()</code>方法，这个方法会在<code>LifecycleOwner</code>生命周期状态发生变化时被调用，它的主要目的其实就是当观察者的生命周期状态从非活跃状态变为活跃状态时，让<code>LiveData</code>向这个观察者发送数据更新(即调用<code>dispatchingValue()</code>方法)，这样我们界面从后台转到前台时就可以显示最新的数据。</p><h3 id="dispatchingvalue方法">dispatchingValue方法</h3><p>我们接下来分析一下<code>dispatchingValue()</code>方法，这个方法是用来分发数据的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dispatchingValue</span><span class="params">(<span class="meta">@Nullable</span> ObserverWrapper initiator)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//如果正在分发数据，则返回</span></span><br><span class="line">    <span class="keyword">if</span> (mDispatchingValue) &#123;</span><br><span class="line">        mDispatchInvalidated = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    mDispatchingValue = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        mDispatchInvalidated = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">//这里是当观察者从非活跃状态变为活跃状态时调用，只向这一个观察者分发数据</span></span><br><span class="line">        <span class="keyword">if</span> (initiator != <span class="keyword">null</span>) &#123;</span><br><span class="line">            considerNotify(initiator);</span><br><span class="line">            initiator = <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//这里是数据更新时调用，遍历所有观察者，向它们分别分发数据</span></span><br><span class="line">            <span class="keyword">for</span> (Iterator&lt;Map.Entry&lt;Observer&lt;? <span class="keyword">super</span> T&gt;, ObserverWrapper&gt;&gt; iterator =</span><br><span class="line">            mObservers.iteratorWithAdditions(); iterator.hasNext(); ) &#123;</span><br><span class="line">                considerNotify(iterator.next().getValue());</span><br><span class="line">                <span class="keyword">if</span> (mDispatchInvalidated) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (mDispatchInvalidated);</span><br><span class="line">    mDispatchingValue = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们看到在<code>dispatchingValue()</code>方法中分了两种情况来分发数据，一个是当观察者从非活跃状态变为活跃状态时，我们只需向这个观察者分发数据就可以了；另一个是当使用<code>setValue()</code>方法或者<code>postValue()</code>方法更新了数据时，则需要遍历所有的观察者，向它们分别分发数据。两种情况都调用了<code>considerNotify()</code>方法，我们来看一下这个方法的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">considerNotify</span><span class="params">(ObserverWrapper observer)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//如果观察者不处于活跃的状态，则直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (!observer.mActive) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果这个时候LifecycleOwner的生命周期状态正好变为非活跃了</span></span><br><span class="line">    <span class="comment">//同步一下这个观察者的生命周期状态，然后返回</span></span><br><span class="line">    <span class="keyword">if</span> (!observer.shouldBeActive()) &#123;</span><br><span class="line">        observer.activeStateChanged(<span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果观察者的数据已经是最新的了，也直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (observer.mLastVersion &gt;= mVersion) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    observer.mLastVersion = mVersion;</span><br><span class="line">    <span class="comment">//分发数据到Observer的onChanged()方法</span></span><br><span class="line">    observer.mObserver.onChanged((T) mData);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>逻辑还是比较清晰的，看注释很容易理解。</p><p>通过上面的分析，我们就可以比较清楚的理解<code>LiveData</code>的工作原理了，是不是感觉比<code>Lifecycle</code>容易了许多？</p><hr /><p>参考文档：</p><p><ahref="https://developer.android.com/topic/libraries/architecture/livedata">LiveData官方文档</a></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;jetpack之livedata&quot;&gt;Jetpack之LiveData&lt;/h1&gt;
&lt;p&gt;&lt;img
src=&quot;https://gitee.com/sachil/blog-pictures/raw/master/image/livedata.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;在文章&lt;a
href=&quot;https://sachil.xyz/posts/550ac800/&quot;&gt;Jetpack之Lifecycle&lt;/a&gt;中，我们已经学习了一个基础的组件：&lt;code&gt;Lifecycle&lt;/code&gt;，并已经明白它是一个生命周期感知型组件，用来响应&lt;code&gt;Activity&lt;/code&gt;和&lt;code&gt;Fragment&lt;/code&gt;的生命周期状态的变化。今天我们来学习一下&lt;code&gt;Architecture&lt;/code&gt;中基于&lt;code&gt;Lifecycle&lt;/code&gt;的另一个组件——&lt;code&gt;Livedata&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&quot;livedata是什么&quot;&gt;LiveData是什么？&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;LiveData&lt;/code&gt;是一种可观察的数据存储类，它具有生命周期感知能力，意思就是它遵循像&lt;code&gt;Activity&lt;/code&gt;和&lt;code&gt;Fragment&lt;/code&gt;这样的生命周期拥有者的生命周期，这种感知能力可以确保&lt;code&gt;LiveData&lt;/code&gt;只更新处于活跃生命周期状态的应用组件观察者。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;LiveData&lt;/code&gt;将生命周期状态中的&lt;code&gt;STARTED&lt;/code&gt;和&lt;code&gt;RESUMED&lt;/code&gt;认为是活跃状态，将其它的生命周期状态如：&lt;code&gt;INITIALZED&lt;/code&gt;、&lt;code&gt;CREATED&lt;/code&gt;和&lt;code&gt;DESTROYED&lt;/code&gt;被认为是非活跃状态。&lt;code&gt;LiveData&lt;/code&gt;仍然使用的是观察者模式，只有当观察者的声明周期处于活跃状态时，才会收到来自&lt;code&gt;LiveData&lt;/code&gt;的数据更新，而生命周期处于非活跃状态的观察者则不会收到数据更新。这样的设计方式很符合日常的逻辑，想象一下如果我们使用一个界面来显示数据，当这个界面不在前台时，即使这个数据有更新，我们也不需要马上刷新界面，因为这样做意义不大。&lt;/p&gt;</summary>
    
    
    
    <category term="Jetpack" scheme="https://sachil.xyz/categories/Jetpack/"/>
    
    
    <category term="Android" scheme="https://sachil.xyz/tags/Android/"/>
    
    <category term="Jetpack" scheme="https://sachil.xyz/tags/Jetpack/"/>
    
  </entry>
  
  <entry>
    <title>Jetpack之Lifecycle</title>
    <link href="https://sachil.xyz/posts/550ac800/"/>
    <id>https://sachil.xyz/posts/550ac800/</id>
    <published>2019-04-07T06:28:41.000Z</published>
    <updated>2023-06-20T15:46:03.207Z</updated>
    
    <content type="html"><![CDATA[<h1 id="jetpack之lifecycle">Jetpack之Lifecycle</h1><p><imgsrc="https://gitee.com/sachil/blog-pictures/raw/master/image/JetPack.png" /></p><h2 id="jetpack套件">Jetpack套件</h2><p><code>Jetpack</code>翻译成中文就是喷气背包的意思，它是<code>Android</code>提供的一个由多个库组成的套件，可以帮助开发者遵循最佳的做法，减少样板代码并编写可在各种<code>Android</code>版本和设备中一致运行的代码，但是<code>Jetpack</code>并不包含在<code>Android</code>的SDK中，它是一个独立的套件。<code>Jetpack</code>的名称和它带来的意义还挺配的，<code>Android</code>机器人穿上<code>Jetpack</code>之后，简直就可以直接起飞了。</p><p><code>Jetpack</code>包含许多各种各样的库，它们按照各自功能的不同，被划分为<code>Architecture</code>、<code>UI</code>、<code>Foundation</code>和<code>Behavior</code>四个类别，就像下图中展示的那样。</p><p><imgsrc="https://gitee.com/sachil/blog-pictures/raw/master/image/Jetpack_building.png" /></p><p>其中在我们平时的开发过程中，最关心的可能就是<code>Architecture</code>部分了，因为它包含了一些我们耳熟能详的库，例如：<code>Lifecycle</code>、<code>ViewModel</code>、<code>LiveData</code>和<code>DataBinding</code>等。<code>Architecture</code>其实是<code>Jetpack</code>中最精华的部分，如果我们想要熟练的掌握<code>Jetpack</code>，就必须重点学习<code>Architecture</code>所包含的内容。现在，我们就来了解一下<code>Architecture</code>中的基础之作：<code>Lifecycle</code>。</p><span id="more"></span><h2 id="lifecycle的使用">Lifecycle的使用</h2><h3 id="为什么需要lifecycle">为什么需要Lifecycle</h3><p><code>Lifecycle</code>就是生命周期的意思，我们都知道在<code>Android</code>中的一些组件，例如<code>Activity</code>和<code>Fragment</code>是有生命周期变化的，这些组件的生命周期是由操作系统来管理的，它们是<code>Android</code>工作原理的核心，我们在日常的开发过程中必须去遵循它们。比如我们的初始化工作可能需要在<code>onCreate</code>中去做，而另外一些工作可能需要在<code>onResume</code>中去做，最后可能还有一些清理工作需要在<code>onDestroy</code>中去做。如果我们不遵循这些生命周期，可能就会出现一些意想不到的现象，甚至可能引发内存泄露和应用崩溃这样的严重后果。</p><p>通常我们会将相应的操作放到不同的生命周期回调方法中去调用，以响应生命周期变化所带来的不同状态。虽然这样开起来并没有什么问题，但是在实际的应用开发中，这样会在各个生命周期回调方法中放置大量的代码，这不仅会让<code>Activity</code>和<code>Fragment</code>变得十分臃肿，还会让代码维护变得艰难。</p><p>同时还有一个更为棘手的问题，那就是无法保证组件在<code>Activity</code>和<code>Fragment</code>停止之后不再执行启动，这个问题在我们需要执行长时间运行的操作时(例如在<code>onStart</code>中执行某种耗时操作)显得尤为突出，这会导致组件的存留时间比所需的时间要长，这样可能就会导致内存泄露的问题，例如下面代码所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FirstActivity</span> : <span class="type">AppCompatActivity</span></span>() &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> worker: Worker</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        worker = Worker(<span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onStart</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onStart()</span><br><span class="line">        <span class="comment">//如果在准备工作的时候，我们已经退出了这个activity，那么worker仍然会继续启动工作</span></span><br><span class="line">        <span class="comment">//同时由于worker持有这个activity的引用，这样就造成了内存泄露</span></span><br><span class="line">        worker.startWork()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onResume</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onResume()</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onPause</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onPause()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onStop</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onStop()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onDestroy</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onDestroy()</span><br><span class="line">        worker.stopWork()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span></span>(<span class="keyword">val</span> context: Context) &#123;</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">startWork</span><span class="params">()</span></span> &#123;</span><br><span class="line">            Thread &#123;</span><br><span class="line">                Log.e(<span class="string">&quot;Worker&quot;</span>, <span class="string">&quot;preparing...&quot;</span>)</span><br><span class="line">                <span class="comment">//这里模拟一个耗时的操作</span></span><br><span class="line">                Thread.sleep(<span class="number">5000</span>)</span><br><span class="line">                <span class="comment">//doRealWork仍然会在FirstActivity停止之后执行</span></span><br><span class="line">                doRealWork()</span><br><span class="line">            &#125;.start()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">stopWork</span><span class="params">()</span></span> &#123;</span><br><span class="line">            Log.e(<span class="string">&quot;Worker&quot;</span>, <span class="string">&quot;Stop working.&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">doRealWork</span><span class="params">()</span></span> &#123;</span><br><span class="line">            Log.e(<span class="string">&quot;Worker&quot;</span>, <span class="string">&quot;Start working.&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以在我们平时的开发过程中存在这样两个问题：</p><ul><li><code>Activity</code>和<code>Framgnet</code>的生命周期回调方法中有大量的代码，难以维护。</li><li>无法保证组件在<code>Activity</code>和<code>Fragment</code>停止之后不再执行启动。</li></ul><p><code>Lifecycle</code>的出现就是为了解决这两个问题，它是一个生命周期感知型组件，用于存储<code>Activity</code>和<code>Framgnet</code>的生命周期状态的信息，以响应<code>Activity</code>和<code>Framgnet</code>的生命周期的状态的变化，最终帮助你以弹性和隔离的方式来解决这些问题。</p><h3 id="基本的使用方式">基本的使用方式</h3><p>使用之前你需要添加<code>Lifecycle</code>的依赖，首先您必须将GoogleMaven代码库添加到项目中，然后再在模块的<code>build.gradle</code>文件中添加所需工作的依赖项：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//project目录下的build.gradle文件添加Google Maven</span></span><br><span class="line">repositories &#123;</span><br><span class="line">        google()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//module目录下的build.gradle文件添加Lifecycle的依赖(for Kotlin)</span></span><br><span class="line">implementation <span class="string">&quot;androidx.Lifecycle:Lifecycle-runtime-ktx:2.0.0&quot;</span></span><br></pre></td></tr></table></figure><p>接着就可以正常使用<code>Lifecycle</code>了，它的使用方式也是比较简单的：</p><ul><li>首先我们需要自定义一个类来实现<code>LifecycleObserver</code>接口。</li><li>然后在这个类中我们可以定义一些用<code>@OnLifecycleEvent</code>注解的方法，当<code>Activity</code>或者<code>Fragment</code>的生命周期发生变化的时候，这些方法就会被调用。</li><li>最后我们在<code>Activity</code>或者<code>Fragment</code>中使用<code>getLifecycle()</code>方法得到<code>Lifecycle</code>对象，再调用该对象的<code>addObserver()</code>方法并传入我们刚才自定义类的实例。</li></ul><p>这样我们就使用了<code>Lifecycle</code>来感知<code>Activity</code>和<code>Fragment</code>的生命周期，可以参考下面的代码：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FirstActivity</span> : <span class="type">AppCompatActivity</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        <span class="comment">//获取到Lifecycle对象并调用addObserver方法，然后把Worker对象作为参数传递过去</span></span><br><span class="line">        Lifecycle.addObserver(Worker(<span class="keyword">this</span>))</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//定义一个类来实现LifecycleObserver接口</span></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span></span>(<span class="keyword">val</span> context: Context) : LifecycleObserver &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//为对应的方法添加OnLifecycleEvent注解，startWork会在onStart回调中调用</span></span><br><span class="line">        <span class="meta">@OnLifecycleEvent(Lifecycle.Event.ON_START)</span></span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">startWork</span><span class="params">(owner: <span class="type">LifecycleOwner</span>)</span></span> &#123;</span><br><span class="line">            Thread &#123;</span><br><span class="line">                Thread.sleep(<span class="number">5000</span>)</span><br><span class="line">                <span class="comment">//检查当前生命周期状态，当前生命周期状态至少是STARTED才会执行真正的工作</span></span><br><span class="line">                <span class="keyword">if</span> (owner.lifecycle.currentState.isAtLeast(Lifecycle.State.STARTED)) &#123;</span><br><span class="line">                    doRealWork()</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;.start()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//stopWork会在onDestroy回调中调用</span></span><br><span class="line">        <span class="meta">@OnLifecycleEvent(Lifecycle.Event.ON_DESTROY)</span></span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">stopWork</span><span class="params">()</span></span> &#123;</span><br><span class="line">            Log.e(<span class="string">&quot;Worker&quot;</span>, <span class="string">&quot;Stop working.&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">doRealWork</span><span class="params">()</span></span> &#123;</span><br><span class="line">            Log.e(<span class="string">&quot;Worker&quot;</span>, <span class="string">&quot;Start working.&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的代码中我们至少可以看到，有了<code>Lifecycle</code>我们就不必再将相应的代码放到对应的生命周期回调方法中了，这样<code>Activity</code>或者<code>Framgnet</code>就会变得更加清爽，更加容易维护。其实还不止这些，<code>Lifecycle</code>还可以对当前生命周期状态进行检查，保证在<code>FirstActivity</code>停止之后将不会执行<code>doRealWork()</code>方法。这样我们刚才所面临的问题就全都被解决啦。</p><h3 id="自定义生命周期对象">自定义生命周期对象</h3><p><code>getLifecycle()</code>方法是在<code>LifecycleOwner</code>接口中定义的，它返回一个<code>Lifecycle</code>对象，其定义方式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">LifecycleOwner</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the Lifecycle of the provider.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> The Lifecycle of the provider.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    <span class="function">Lifecycle <span class="title">getLifecycle</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们之所以能够在<code>Activity</code>和<code>Framgnet</code>中直接调用<code>getLifecycle()</code>方法，是因为在它们的父类实现了<code>LifecycleOwner</code>接口，</p><p>如果我们想要自己定义的类也具有生命周期，那么我们也需要继承这个接口，并重写它的<code>getLifecycle()</code>方法，然后在这个方法中返回一个<code>LifecycleRegistry</code>实例，就像下面代码所展示的那样：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实现LifecycleOwner接口</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomActivity</span></span>() : LifecycleOwner &#123;</span><br><span class="line">    <span class="comment">//创建一个LifecycleRegistry对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> lifecycleRegistry: LifecycleRegistry = LifecycleRegistry(<span class="keyword">this</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在不同的生命周期方法中去调用LifecycleRegistry的handleLifecycleEvent方法</span></span><br><span class="line">    <span class="comment">//并将生命周期事件作为它参数传递过去</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">onCrate</span><span class="params">()</span></span> &#123;</span><br><span class="line">        lifecycleRegistry.handleLifecycleEvent(Lifecycle.Event.ON_CREATE)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">onStart</span><span class="params">()</span></span> &#123;</span><br><span class="line">        lifecycleRegistry.handleLifecycleEvent(Lifecycle.Event.ON_START)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">onResume</span><span class="params">()</span></span> &#123;</span><br><span class="line">        lifecycleRegistry.handleLifecycleEvent(Lifecycle.Event.ON_RESUME)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">onPause</span><span class="params">()</span></span> &#123;</span><br><span class="line">        lifecycleRegistry.handleLifecycleEvent(Lifecycle.Event.ON_PAUSE)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">onStop</span><span class="params">()</span></span> &#123;</span><br><span class="line">        lifecycleRegistry.handleLifecycleEvent(Lifecycle.Event.ON_STOP)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">onDestroy</span><span class="params">()</span></span> &#123;</span><br><span class="line">        lifecycleRegistry.handleLifecycleEvent(Lifecycle.Event.ON_DESTROY)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重写getLifecycle方法，并返回所创建的LifecycleRegistry对象</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getLifecycle</span><span class="params">()</span></span>: Lifecycle = lifecycleRegistry</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中的<code>CustomActivity</code>实现了<code>LifecycleOwner</code>接口，重写了<code>getLifecycle()</code>方法，并返回了一个<code>LifecycleRegistry</code>的实例，<code>LifecycleRegisty</code>是<code>Lifecycle</code>这个抽象类的子类，是它的一个具体实现。然后在<code>CustomActivity</code>中定义了一些生命周期方法，在这些方法中会调用<code>LifecycleRegisty</code>的<code>handleLifecycleEvent()</code>方法，并将不同的生命周期事件作为参数进行传递，这样我们就自定义了一个拥有生命周期的对象。</p><h2 id="lifecycle的工作原理">Lifecycle的工作原理</h2><p><code>Lifecycle</code>使用起来是比较简单的，但是我们在使用的同时更需要更深入的了解<code>Lifecycle</code>的工作原理。从上面对<code>Lifecycle</code>的使用我们可以了解到它使用的是观察者模式，被观察者就是拥有生命周期的对象，即实现了<code>LifecycleOwner</code>接口的对象，观察者就是实现了<code>LifecycleOberver</code>接口的对象，当被观察者的生命周期的状态发生改变时，就会遍历所有的观察者，并将这个状态的变化通知到感兴趣的观察者。</p><h3 id="抽象类lifecycle">抽象类Lifecycle</h3><p>我们先来看一下<code>Lifecycle</code>这个类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Lifecycle</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)</span></span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    AtomicReference&lt;Object&gt; mInternalScopeRef = <span class="keyword">new</span> AtomicReference&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@MainThread</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">addObserver</span><span class="params">(<span class="meta">@NonNull</span> LifecycleObserver observer)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@MainThread</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">removeObserver</span><span class="params">(<span class="meta">@NonNull</span> LifecycleObserver observer)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@MainThread</span></span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> State <span class="title">getCurrentState</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;WeakerAccess&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">Event</span> </span>&#123;</span><br><span class="line">        ON_CREATE,</span><br><span class="line">        ON_START,</span><br><span class="line">        ON_RESUME,</span><br><span class="line">        ON_PAUSE,</span><br><span class="line">        ON_STOP,</span><br><span class="line">        ON_DESTROY,</span><br><span class="line">        ON_ANY</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;WeakerAccess&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">State</span> </span>&#123;</span><br><span class="line">        DESTROYED,</span><br><span class="line">        INITIALIZED,</span><br><span class="line">        CREATED,</span><br><span class="line">        STARTED,</span><br><span class="line">        RESUMED;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAtLeast</span><span class="params">(<span class="meta">@NonNull</span> State state)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> compareTo(state) &gt;= <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以看到<code>Lifecycle</code>是一个抽象类，在这个类中定义了两个枚举类：<code>Event</code>和<code>State</code>，它们都是和生命周期息息相关的，<code>Event</code>表示生命周期中的事件，对应<code>Activity</code>和<code>Fragment</code>中的回调事件(ON_ANY表示任何事件)；<code>State</code>表示生命周期的状态，它们之间的关系可以借用官方文档中的一张图来说明：</p><p><imgsrc="https://gitee.com/sachil/blog-pictures/raw/master/image/event_state.png" /></p><p>我们可以将状态看作一个个节点，而事件就是这些节点之间的边，不同的状态是通过不同的事件串联起来的。</p><p>这里我们还需要注意一下不同的<code>Event</code>事件在<code>Activity</code>或者<code>Fragment</code>中触发的时机的不同，它们之间是有区别的：<code>ON_CREATE</code>、<code>ON_START</code>和<code>ON_RESUME</code>会在生命周期拥有者所对应的回调方法之后触发，而<code>ON_PAUSE</code>、<code>ON_STOP</code>和<code>ON_DESTROY</code>会在生命周期拥有者所对应的回调方法之前调用。同时还需要注意当一个生命周期拥有者添加了多个<code>LifecycleObserver</code>对象时，这些事件的触发顺序。通过下面的代码可以更深刻的了解到：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> : <span class="type">AppCompatActivity</span></span>() &#123;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">val</span> TAG = <span class="string">&quot;MainActivity&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        Log.e(TAG, <span class="string">&quot;onCreate&quot;</span>)</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        lifecycle.addObserver(Worker(<span class="keyword">this</span>))</span><br><span class="line">        lifecycle.addObserver(Executor(<span class="keyword">this</span>))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onStart</span><span class="params">()</span></span> &#123;</span><br><span class="line">        Log.e(TAG, <span class="string">&quot;onStart&quot;</span>)</span><br><span class="line">        <span class="keyword">super</span>.onStart()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onResume</span><span class="params">()</span></span> &#123;</span><br><span class="line">        Log.e(TAG, <span class="string">&quot;onResume&quot;</span>)</span><br><span class="line">        <span class="keyword">super</span>.onResume()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onPause</span><span class="params">()</span></span> &#123;</span><br><span class="line">        Log.e(TAG, <span class="string">&quot;onPause&quot;</span>)</span><br><span class="line">        <span class="keyword">super</span>.onPause()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onStop</span><span class="params">()</span></span> &#123;</span><br><span class="line">        Log.e(TAG, <span class="string">&quot;onStop&quot;</span>)</span><br><span class="line">        <span class="keyword">super</span>.onStop()</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onDestroy</span><span class="params">()</span></span> &#123;</span><br><span class="line">        Log.e(TAG, <span class="string">&quot;onDestroy&quot;</span>)</span><br><span class="line">        <span class="keyword">super</span>.onDestroy()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span></span>(<span class="keyword">val</span> context: Context) : LifecycleObserver &#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@OnLifecycleEvent(Lifecycle.Event.ON_START)</span></span><br><span class="line">        <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">startWork</span><span class="params">()</span></span> &#123;</span><br><span class="line">            Log.e(<span class="string">&quot;Worker&quot;</span>, <span class="string">&quot;Start working.&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@OnLifecycleEvent(Lifecycle.Event.ON_STOP)</span></span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">stopWork</span><span class="params">()</span></span> &#123;</span><br><span class="line">            Log.e(<span class="string">&quot;Worker&quot;</span>, <span class="string">&quot;Stop working.&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Executor</span></span>(<span class="keyword">val</span> context: Context) : LifecycleObserver &#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@OnLifecycleEvent(Lifecycle.Event.ON_START)</span></span><br><span class="line">        <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">startExecute</span><span class="params">()</span></span> &#123;</span><br><span class="line">            Log.e(<span class="string">&quot;Executor&quot;</span>, <span class="string">&quot;Start Executing.&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@OnLifecycleEvent(Lifecycle.Event.ON_STOP)</span></span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">stopExecute</span><span class="params">()</span></span> &#123;</span><br><span class="line">            Log.e(<span class="string">&quot;Executor&quot;</span>, <span class="string">&quot;Stop Executing.&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">输出结果：</span></span><br><span class="line"><span class="comment"> E/MainActivity: onStart</span></span><br><span class="line"><span class="comment"> E/Worker: Start working.</span></span><br><span class="line"><span class="comment"> E/Executor: Start Executing.</span></span><br><span class="line"><span class="comment"> E/MainActivity: onResume</span></span><br><span class="line"><span class="comment"> E/MainActivity: onPause</span></span><br><span class="line"><span class="comment">E/Executor: Stop Executing.</span></span><br><span class="line"><span class="comment">E/Worker: Stop working.</span></span><br><span class="line"><span class="comment">E/MainActivity: onStop</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>从上面输出结果我们可以看到，<strong>对于<code>ON_CREATE</code>、<code>ON_START</code>和<code>ON_RESUME</code>，它们会按照添加<code>LifecycleObserver</code>的顺序分发，即先添加的先分发；而对于<code>ON_PAUSE</code>、<code>ON_STOP</code>和<code>ON_DESTROY</code>，它们则是相反的，即后添加的先分发</strong>。</p><h3 id="componentactivity">ComponentActivity</h3><p>在<code>Activity</code>中可以直接使用<code>getLifecycle()</code>方法的原因是在<code>ComponentActivity</code>中实现了<code>LifecycleOwner</code>接口并重写了这个方法，但是在<code>ComponentActivity</code>中，并没有直接分发生命周期事件，它使用了一个没有布局的<code>ReportFragment</code>来帮它分发声明周期事件，之所以能够这样做的原因是因为<code>fragment</code>的生命周期是依附在<code>Activity</code>上的，这样做的好处就是可以将这部分的分发逻辑剥离出来，从而让<code>ComponentActivity</code>更加清爽。我们可以看一下代码(省去了那些不相关的部分)：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ComponentActivity</span> <span class="keyword">extends</span> <span class="title">androidx</span>.<span class="title">core</span>.<span class="title">app</span>.<span class="title">ComponentActivity</span> <span class="keyword">implements</span></span></span><br><span class="line"><span class="class">        <span class="title">LifecycleOwner</span>,</span></span><br><span class="line"><span class="class">        <span class="title">ViewModelStoreOwner</span>,</span></span><br><span class="line"><span class="class">        <span class="title">SavedStateRegistryOwner</span>,</span></span><br><span class="line"><span class="class">        <span class="title">OnBackPressedDispatcherOwner</span> </span>&#123;</span><br><span class="line">            </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> LifecycleRegistry mLifecycleRegistry = <span class="keyword">new</span> LifecycleRegistry(<span class="keyword">this</span>);</span><br><span class="line">            </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(<span class="meta">@Nullable</span> Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        mSavedStateRegistryController.performRestore(savedInstanceState);</span><br><span class="line">        <span class="comment">//这里调用了ReportFragment的injectIfNeededIn方法</span></span><br><span class="line">        ReportFragment.injectIfNeededIn(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (mContentLayoutId != <span class="number">0</span>) &#123;</span><br><span class="line">            setContentView(mContentLayoutId);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="reportfragment">ReportFragment</h3><p>现在我们知道了<code>ReportFragment</code>才是那个真正分发声明周期事件的实体，我们再来看一下它的代码(省去了那些不相关的部分)：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReportFragment</span> <span class="keyword">extends</span> <span class="title">Fragment</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String REPORT_FRAGMENT_TAG = <span class="string">&quot;androidx.lifecycle&quot;</span></span><br><span class="line">            + <span class="string">&quot;.LifecycleDispatcher.report_fragment_tag&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这里就是将ReportFragment与对应的Activity关联起来，即将它添加到对应的Activity上</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">injectIfNeededIn</span><span class="params">(Activity activity)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ProcessLifecycleOwner should always correctly work and some activities may not extend</span></span><br><span class="line">        <span class="comment">// FragmentActivity from support lib, so we use framework fragments for activities</span></span><br><span class="line">        android.app.FragmentManager manager = activity.getFragmentManager();</span><br><span class="line">        <span class="keyword">if</span> (manager.findFragmentByTag(REPORT_FRAGMENT_TAG) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            manager.beginTransaction().add(<span class="keyword">new</span> ReportFragment(), REPORT_FRAGMENT_TAG).commit();</span><br><span class="line">            <span class="comment">// Hopefully, we are the first to make a transaction.</span></span><br><span class="line">            manager.executePendingTransactions();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onActivityCreated</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onActivityCreated(savedInstanceState);</span><br><span class="line">        <span class="comment">//调用dispatch方法，分发生命周期事件</span></span><br><span class="line">        dispatch(Lifecycle.Event.ON_CREATE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onStart();</span><br><span class="line">        dispatch(Lifecycle.Event.ON_START);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResume</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onResume();</span><br><span class="line">        dispatch(Lifecycle.Event.ON_RESUME);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onPause</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onPause();</span><br><span class="line">        dispatch(Lifecycle.Event.ON_PAUSE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onStop();</span><br><span class="line">        dispatch(Lifecycle.Event.ON_STOP);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onDestroy();</span><br><span class="line">        dispatch(Lifecycle.Event.ON_DESTROY);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这里将会分发生命周期事件</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dispatch</span><span class="params">(Lifecycle.Event event)</span> </span>&#123;</span><br><span class="line">        Activity activity = getActivity();</span><br><span class="line">        <span class="keyword">if</span> (activity <span class="keyword">instanceof</span> LifecycleRegistryOwner) &#123;</span><br><span class="line">            ((LifecycleRegistryOwner) activity).getLifecycle().handleLifecycleEvent(event);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (activity <span class="keyword">instanceof</span> LifecycleOwner) &#123;</span><br><span class="line">            <span class="comment">//获取到Activity中的Lifecycle对象</span></span><br><span class="line">            Lifecycle lifecycle = ((LifecycleOwner) activity).getLifecycle();</span><br><span class="line">            <span class="keyword">if</span> (lifecycle <span class="keyword">instanceof</span> LifecycleRegistry) &#123;</span><br><span class="line">                <span class="comment">//调用这个Lifecycle对象的handleLifecycleEvent开始分发事件</span></span><br><span class="line">                ((LifecycleRegistry) lifecycle).handleLifecycleEvent(event);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从代码中我们可以看到，<code>ReportFragment</code>会被添加到对应的<code>Activity</code>中，并在<code>ReportFragment</code>的生命周期回调方法中调用<code>dispatch()</code>方法分发对应的生命周期事件，在<code>dispatch()</code>方法中会获取到<code>Activity</code>中定义的<code>Lifecycle</code>对象，实际上是一个<code>LifecycleRegistry</code>对象，然后调用该<code>LifecycleRegistry</code>对象的<code>handleLifecycleEvent()</code>方法来实际分发生命周期事件，其实我们自定义生命周期是一样的。</p><h3 id="lifecycleregistry">LifecycleRegistry</h3><p>我们可以看到，真正处理生命周期事件的是<code>LifecycleRegistry</code>这个类，现在我们就来深入了解一下这个类。</p><h4 id="成员变量">成员变量</h4><p>首先我们先看一下它所定义的成员变量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Invariant: at any moment of time for observer1 &amp; observer2:</span></span><br><span class="line"><span class="comment"> * if addition_order(observer1) &lt; addition_order(observer2), then</span></span><br><span class="line"><span class="comment"> * state(observer1) &gt;= state(observer2),</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> FastSafeIterableMap&lt;LifecycleObserver, ObserverWithState&gt; mObserverMap =</span><br><span class="line">        <span class="keyword">new</span> FastSafeIterableMap&lt;&gt;();</span><br><span class="line"><span class="keyword">private</span> State mState;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> WeakReference&lt;LifecycleOwner&gt; mLifecycleOwner;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> mAddingObserverCounter = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> mHandlingEvent = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> mNewEventOccurred = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">private</span> ArrayList&lt;State&gt; mParentStates = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br></pre></td></tr></table></figure><ul><li><p><code>mObserverMap</code>,它是一个<code>FastSafeIterableMap</code>类型的<code>map</code>，它的特点就是在遍历的过程中可以安全的添加和删除元素，它的<code>key</code>是一个<code>LifecycleObserver</code>对象，也就是观察者，<code>value</code>是一个<code>ObserverWithState</code>对象，这是一个对观察者对象的封装。</p></li><li><p><code>mState</code>,记录<code>LifecycleOwner</code>对象，也就是被观察者当前的生命周期的状态</p></li><li><p><code>mLifecycleOwner</code>,这是一个被观察者的弱引用，这样可以保证即使<code>Lifecycle</code>发生了泄露，也可以保证被观察者不会泄露。</p></li><li><p><code>mAddingObserverCounter</code>、<code>mHandlingEvent</code>、<code>mNewEventOccurred</code>和<code>mParentStates</code>，这四个成员变量是用于当生命周期事件发生嵌套(后文会解释)的时候，可以维护<code>LifecycleRegistry</code>的状态。</p></li></ul><p>我们可以看到<code>mObserverMap</code>上有一段注释说明，<strong>意思就是<code>mObserverMap</code>中有这样一个规则：在任何时候，如果<code>observer1</code>早于<code>observer2</code>被添加到该<code>map</code>中，那么<code>observer1</code>的生命周期状态肯定是大于等于<code>observer2</code>的</strong>。生命周期状态的大小很容易比较，看<code>State</code>的定义就可以知道：<code>DESTROYED</code>&lt;<code>INITIALIZED</code>&lt;<code>CREATED</code>&lt;<code>STARTED</code>&lt;<code>RESUMED</code>。</p><p>那么<code>LifecycleObserver</code>的添加次序肯定就是这个<code>FastSafeIterableMap</code>类型的<code>mObserverMap</code>来维护的，那么它是如何做的呢？查看源码我们就可以知道，<code>FastSafeIterableMap</code>是<code>SafeIterableMap</code>的子类，在<code>SafeIterableMap</code>的内部又自定义了<code>Entry</code>的实现，这个<code>Entry</code>中定义了<code>mPrevious</code>和<code>mNext</code>两个成员变量，这就是一个双向链表，同时<code>SafeIterableMap</code>中定义了<code>mStart</code>和<code>mEnd</code>两个成员变量，一个指向链表的表头，一个指向链表的表尾，当添加新的<code>LifecycleObserver</code>时，它会被添加到链表的表尾，<strong>这样<code>mObserverMap</code>就用一个双向链表维护了<code>LifecycleObserver</code>的有序性</strong>。</p><h4 id="observerwithstate">ObserverWithState</h4><p>我们再来看一下<code>ObserverWithState</code>这个类，它是<code>LifecycleRegistry</code>的静态内部类，是对<code>LifecycleObserver</code>的一种封装，我们先一下它的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ObserverWithState</span> </span>&#123;</span><br><span class="line">    <span class="comment">//用于记录这个LifecycleObserver已经回调的生命周期状态，防止重复调用</span></span><br><span class="line">    State mState;</span><br><span class="line">    LifecycleEventObserver mLifecycleObserver;</span><br><span class="line"></span><br><span class="line">    ObserverWithState(LifecycleObserver observer, State initialState) &#123;</span><br><span class="line">        mLifecycleObserver = Lifecycling.lifecycleEventObserver(observer);</span><br><span class="line">        mState = initialState;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dispatchEvent</span><span class="params">(LifecycleOwner owner, Event event)</span> </span>&#123;</span><br><span class="line">        State newState = getStateAfter(event);</span><br><span class="line">        <span class="comment">//将生命周期状态更新为旧状态和新状态中较小的那个</span></span><br><span class="line">        <span class="comment">//目的是为了维护LifecycleObserver的有序性</span></span><br><span class="line">        mState = min(mState, newState);</span><br><span class="line">        mLifecycleObserver.onStateChanged(owner, event);</span><br><span class="line">        mState = newState;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到在<code>ObserverWithState</code>的构造函数中会调用<code>Lifecycling</code>的<code>lifecycleEventObserver()</code>方法来具体封装<code>LifecycleObserver</code>,这个方法会去判断传入的<code>LifecycleObserver</code>对象的具体类型，并根据类型的不同来封装为具体的<code>LifecycleEventObserver</code>对象，一般情况下我们的<code>LifecycleObserver</code>会被封装为一个<code>ReflectiveGenericLifecycleObserver</code>对象。</p><p>然后<code>dispatchEvent()</code>被用来具体的分发生命周期事件，方法的内部会根据生命周期事件获取到对应的生命周期状态，然后再调用<code>LifecycleEventObserver</code>的<code>onStateChanged()</code>方法。同时我们注意到<code>ObserverWithState</code>定义了一个<code>mState</code>，它可以用来记录这个<code>LifecycleObserver</code>已经回调到的生命周期状态，可以防止重复调用。</p><p>所以用<code>ObserverWithState</code>来封装<code>LifecycleObserver</code>的目的就是：</p><ol type="1"><li>可以记录<code>LifecycleObserver</code>已经回调的生命周期状态，防止重复调用。</li><li>让<code>LifecycleObserver</code>对象统一为<code>LifecycleEventObserver</code>对象，这样分发事件的接口就一致了，都是调用<code>onStateChanged()</code>方法。</li></ol><h4 id="添加lifecycleobserver">添加LifecycleObserver</h4><p><code>LifecycleObserver</code>调用其<code>addObserver()</code>方法来添加<code>LifecycleObserver</code>，<code>addObserver()</code>方法定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addObserver</span><span class="params">(<span class="meta">@NonNull</span> LifecycleObserver observer)</span> </span>&#123;</span><br><span class="line">    State initialState = mState == DESTROYED ? DESTROYED : INITIALIZED;</span><br><span class="line">    <span class="comment">//将新添加的LifecycleObserver对象封装为ObserverWithState对象</span></span><br><span class="line">    ObserverWithState statefulObserver = <span class="keyword">new</span> ObserverWithState(observer, initialState);</span><br><span class="line">    <span class="comment">//将这个新的ObserverWithState对象添加到双向链表中</span></span><br><span class="line">    ObserverWithState previous = mObserverMap.putIfAbsent(observer, statefulObserver);</span><br><span class="line">    <span class="comment">//如果新的ObserverWithState对象已经存在，则返回</span></span><br><span class="line">    <span class="keyword">if</span> (previous != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    LifecycleOwner lifecycleOwner = mLifecycleOwner.get();</span><br><span class="line">    <span class="comment">//如果生命周期拥有者已不存在，则直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (lifecycleOwner == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// it is null we should be destroyed. Fallback quickly</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//下面这些代码的意思就是通过while循环，将这个新添加的`LifecycleObserver`的生命周期状态一步步的</span></span><br><span class="line">    <span class="comment">//更新到最新的生命周期状态</span></span><br><span class="line">    <span class="keyword">boolean</span> isReentrance = mAddingObserverCounter != <span class="number">0</span> || mHandlingEvent;</span><br><span class="line">    State targetState = calculateTargetState(observer);</span><br><span class="line">    mAddingObserverCounter++;</span><br><span class="line">    <span class="keyword">while</span> ((statefulObserver.mState.compareTo(targetState) &lt; <span class="number">0</span></span><br><span class="line">                &amp;&amp; mObserverMap.contains(observer))) &#123;</span><br><span class="line">        pushParentState(statefulObserver.mState);</span><br><span class="line">        statefulObserver.dispatchEvent(lifecycleOwner, upEvent(statefulObserver.mState));</span><br><span class="line">        popParentState();</span><br><span class="line">        <span class="comment">// mState / subling may have been changed recalculate</span></span><br><span class="line">        targetState = calculateTargetState(observer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//开始同步生命周期状态</span></span><br><span class="line">    <span class="keyword">if</span> (!isReentrance) &#123;</span><br><span class="line">        <span class="comment">// we do sync only on the top level.</span></span><br><span class="line">        sync();</span><br><span class="line">    &#125;</span><br><span class="line">    mAddingObserverCounter--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从代码中可以看到，<code>addObserver()</code>方法进行了这些操作：</p><ol type="1"><li>将新添加的<code>LifecycleObserver</code>对象封装为<code>ObserverWithState</code>对象，并添加到<code>mObserverMap</code>所维护的链表中。</li><li>判断这个新添加的<code>ObserverWithState</code>对象是否已经存在，若已经存在则直接返回，同时判断生命周期拥有者<code>LifecycleOwner</code>是否存在，若不存在也直接返回</li><li>将这个新添加的观察者的生命周期状态一步一步的同步到最新的生命周期状态，也就是说虽然这个新的观察者添加得晚，但是它仍然可以连续的接收到从<code>INITIALIZED</code>到当前状态之间的所有状态。</li><li>调用<code>sync()</code>方法同步所有观察者的生命周期状态。</li></ol><h4 id="分发生命周期事件">分发生命周期事件</h4><p>从前面我们了解到，<code>LifecycleRegistry</code>分发生命周期事件是通过<code>handleLifecycleEvent()</code>方法来完成的，我们看一下它的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleLifecycleEvent</span><span class="params">(<span class="meta">@NonNull</span> Lifecycle.Event event)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//根据当前生命周期事件计算经过这个事件后的生命周期状态</span></span><br><span class="line">    State next = getStateAfter(event);</span><br><span class="line">    moveToState(next);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">moveToState</span><span class="params">(State next)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mState == next) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    mState = next;</span><br><span class="line">    <span class="keyword">if</span> (mHandlingEvent || mAddingObserverCounter != <span class="number">0</span>) &#123;</span><br><span class="line">        mNewEventOccurred = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">// we will figure out what to do on upper level.</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    mHandlingEvent = <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">//同步所有观察者的生命周期状态</span></span><br><span class="line">    sync();</span><br><span class="line">    mHandlingEvent = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其调用了<code>getStateAfter()</code>方法和<code>moveToState()</code>方法，前者是根据当前传递过来的生命周期事件计算出下一个生命周期状态，后者则主要调用了<code>sync()</code>方法来同步所有观察者的生命周期状态。</p><h4 id="同步状态sync">同步状态sync</h4><p>我们看到，添加新的<code>LifecycleObserver</code>和分发新产生的生命周期事件都会调用<code>sync()</code>方法，这个方法的作用就是将<code>mObserverMap</code>双向链表中的所有<code>LifecycleObserver</code>的生命周期状态同步到<code>LifecycleOwner</code>的最新状态。下面是它的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sync</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LifecycleOwner lifecycleOwner = mLifecycleOwner.get();</span><br><span class="line">    <span class="keyword">if</span> (lifecycleOwner == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;LifecycleOwner of this LifecycleRegistry is already&quot;</span></span><br><span class="line">                + <span class="string">&quot;garbage collected. It is too late to change lifecycle state.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断同步是否已经完成</span></span><br><span class="line">    <span class="keyword">while</span> (!isSynced()) &#123;</span><br><span class="line">        mNewEventOccurred = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">// no need to check eldest for nullability, because isSynced does it for us.</span></span><br><span class="line">        <span class="keyword">if</span> (mState.compareTo(mObserverMap.eldest().getValue().mState) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            backwardPass(lifecycleOwner);</span><br><span class="line">        &#125;</span><br><span class="line">        Entry&lt;LifecycleObserver, ObserverWithState&gt; newest = mObserverMap.newest();</span><br><span class="line">        <span class="keyword">if</span> (!mNewEventOccurred &amp;&amp; newest != <span class="keyword">null</span></span><br><span class="line">            &amp;&amp; mState.compareTo(newest.getValue().mState) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            forwardPass(lifecycleOwner);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    mNewEventOccurred = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过比较mObserverMap中最旧的观察者和最新的观察者的生命周期状态是否都</span></span><br><span class="line"><span class="comment">//与当前生命周期状态一致来判断同步是否已经完成</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isSynced</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mObserverMap.size() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    State eldestObserverState = mObserverMap.eldest().getValue().mState;</span><br><span class="line">    State newestObserverState = mObserverMap.newest().getValue().mState;</span><br><span class="line">    <span class="keyword">return</span> eldestObserverState == newestObserverState &amp;&amp; mState == newestObserverState;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>sync()</code>方法在一个<code>while</code>循环中不断的调用<code>isSynced()</code>方法来判断同步工作是否已经完成，<code>isSynced()</code>方法则是通过比较<code>mObserverMap</code>中最旧的观察者和最新的观察者的生命周期状态是否都等于当前的生命周期状态来判断同步是否已经完成的。若同步尚未完成，则会根据比较观察者的生命周期和当前生命周期的大小来调用<code>backwardPass()</code>方法或者<code>forwardPass()</code>方法以同步状态。</p><p><code>backwardPass()</code>方法和<code>forwardPass()</code>方法都是用来更新观察者生命周期状态的。不同的是，<code>backwardPass()</code>用于将<code>mObserverMap</code>中所有生命周期状态大于当前生命周期状态的观察者的生命周期状态更新到当前生命周期状态，<code>forwardPass()</code>用于将<code>mObserverMap</code>中所有生命周期状态小于当前生命周期状态的观察者的生命周期状态更新到当前状态。也就是说，状态按照<code>INITIALZED</code>-&gt;<code>CREATED</code>-&gt;<code>STARTED</code>-&gt;<code>RESUMED</code>方向变化，会调用<code>forwardPass()</code>方法，而按照<code>RESUMED</code>-&gt;<code>STARTED</code>-&gt;<code>CREATED</code>-&gt;<code>DESTROYED</code>方向变化，则会调用<code>backwardPass()</code>方法。</p><p><code>backwardPass()</code>方法和<code>forwardPass()</code>方法的实现是差不多的，那么我们来看一下它们的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backwardPass</span><span class="params">(LifecycleOwner lifecycleOwner)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//反向遍历mObserverMap中的观察者</span></span><br><span class="line">    Iterator&lt;Entry&lt;LifecycleObserver, ObserverWithState&gt;&gt; descendingIterator =</span><br><span class="line">    mObserverMap.descendingIterator();</span><br><span class="line">    <span class="keyword">while</span> (descendingIterator.hasNext() &amp;&amp; !mNewEventOccurred) &#123;</span><br><span class="line">        Entry&lt;LifecycleObserver, ObserverWithState&gt; entry = descendingIterator.next();</span><br><span class="line">        ObserverWithState observer = entry.getValue();</span><br><span class="line">        <span class="comment">//通过这个循环来逐步的更新观察的生命周期状态</span></span><br><span class="line">        <span class="keyword">while</span> ((observer.mState.compareTo(mState) &gt; <span class="number">0</span> &amp;&amp; !mNewEventOccurred</span><br><span class="line">                    &amp;&amp; mObserverMap.contains(entry.getKey()))) &#123;</span><br><span class="line">            <span class="comment">//记录这个观察者已回调状态的上一个生命周期事件</span></span><br><span class="line">            Event event = downEvent(observer.mState);</span><br><span class="line">            pushParentState(getStateAfter(event));</span><br><span class="line">            <span class="comment">//调用ObserverWithState方法分发生命周期事件</span></span><br><span class="line">            observer.dispatchEvent(lifecycleOwner, event);</span><br><span class="line">            popParentState();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">forwardPass</span><span class="params">(LifecycleOwner lifecycleOwner)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//正向遍历mObserverMap中的观察者</span></span><br><span class="line">    Iterator&lt;Entry&lt;LifecycleObserver, ObserverWithState&gt;&gt; ascendingIterator =</span><br><span class="line">    mObserverMap.iteratorWithAdditions();</span><br><span class="line">    <span class="keyword">while</span> (ascendingIterator.hasNext() &amp;&amp; !mNewEventOccurred) &#123;</span><br><span class="line">        Entry&lt;LifecycleObserver, ObserverWithState&gt; entry = ascendingIterator.next();</span><br><span class="line">        ObserverWithState observer = entry.getValue();</span><br><span class="line">        <span class="keyword">while</span> ((observer.mState.compareTo(mState) &lt; <span class="number">0</span> &amp;&amp; !mNewEventOccurred</span><br><span class="line">                    &amp;&amp; mObserverMap.contains(entry.getKey()))) &#123;</span><br><span class="line">            pushParentState(observer.mState);</span><br><span class="line">            <span class="comment">//调用ObserverWithState方法分发生命周期事件，传递的是这个观察者已回调状态的上一个生命周期事件</span></span><br><span class="line">            observer.dispatchEvent(lifecycleOwner, upEvent(observer.mState));</span><br><span class="line">            popParentState();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码逻辑还是比较简单的，就是遍历<code>mObserverMap</code>中的观察者，取出添加的<code>LifecycleObserver</code>(<code>forwardPass()</code>方法中是正向遍历，<code>backwardPass()</code>方法中是反向遍历)，然后通过一个循环来逐步的更新这个观察者的生命周期状态。注意调<code>backwardPass()</code>方法中用的<code>downEvent()</code>方法，意思就是获取传入的生命周期状态的上一个生命周期事件，而在<code>forwardPass()</code>方法中则调用的是<code>upEvent()</code>方法，意思就是获取传入的生命周期状态的下一个生命周期事件，最后再调用<code>ObserverWithState</code>的<code>dispatchEvent()</code>方法来分发声明周期事件，从而更新观察者的生命周期状态。</p><h4 id="生命周期事件嵌套时的处理">生命周期事件嵌套时的处理</h4><p>通过上面的解析，我们了解了<code>LifeCycleRegistry</code>同步生命周期状态的基本过程，我们也看到在同步的过程中会去更新一些标志位以及保存观察者的状态，现在我们来解释一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//当它大于0时，表示正在同步新添加的观察者的过程中</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> mAddingObserverCounter = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//表是是否正在进行同步</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> mHandlingEvent = <span class="keyword">false</span>;</span><br><span class="line"><span class="comment">//表示在同步状态的过程中，是否产生了新的生命周期事件，如果产生了新的生命周期事件</span></span><br><span class="line"><span class="comment">//则会中断当前的同步，再基于新的生命周期状态进行同步</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> mNewEventOccurred = <span class="keyword">false</span>;</span><br><span class="line"><span class="comment">//这是一个用于保存观察者的生命周期状态的栈，通过pushParentState()和popParentState()来进行入栈和出栈</span></span><br><span class="line"><span class="comment">//在backwardPass()方法和forwardPass()方法中，在执行观察者的回调方法前会将观察者的生命周期状态进行入栈</span></span><br><span class="line"><span class="comment">//然后在观察者回调方法执行完毕之后将观察者的生命周期状态进行出栈</span></span><br><span class="line"><span class="keyword">private</span> ArrayList&lt;State&gt; mParentStates = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br></pre></td></tr></table></figure><p><code>LifecycleRegistry</code>中为什么需要定义这么多的成员变量呢？其实主要是用来处理多个生命周期状态需要同步时所产生的冲突的，我们知道<code>LifecycleRegistry</code>被设计成只能在主线程中使用，所以这种冲突并不是多线程环境带来的，那么这种冲突到底是什么冲突呢？</p><p>我们想象一下：观察者<code>LifecycleObserver</code>中的回调方法很有可能是一个耗时的操作，如果在这个回调方法执行完毕之前，又产生了新的生命周期事件，或者又添加了一个新的观察者，这样就又会触发同步操作，这样就产生了冲突，所以这种冲突主要指的就是生命周期事件的嵌套。</p><p>所以在<code>LifecycleRegistry</code>中使用<code>mNewEventOccurred</code>来标记由产生了新的生命周期事件而引发的生命周期事件的嵌套，这种情况下会中断正在进行的同步过程。而使用<code>mParentStates</code>来处理由添加了一个新的观察者而引发的生命周期事件的嵌套，我们可以来看一下<code>mParentStates</code>是怎样做到的</p><p>在<code>addObserver()</code>方法中计算新添加的观察者的<code>targetState</code>时，调用了<code>calculateTargetState()</code>这个方法，我们先看一下它的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> State <span class="title">calculateTargetState</span><span class="params">(LifecycleObserver observer)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//从mObserverMap中获取当前这个观察者的前一个观察者赋值给previous</span></span><br><span class="line">    Entry&lt;LifecycleObserver, ObserverWithState&gt; previous = mObserverMap.ceil(observer);</span><br><span class="line"></span><br><span class="line">    State siblingState = previous != <span class="keyword">null</span> ? previous.getValue().mState : <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//从parentState栈的栈顶获取一个生命周期状态</span></span><br><span class="line">    State parentState = !mParentStates.isEmpty() ? mParentStates.get(mParentStates.size() - <span class="number">1</span>)</span><br><span class="line">    : <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//比较当前生命周期状态mState,前一个观察者的生命周期状态和parentState栈顶的生命周期状态，</span></span><br><span class="line">    <span class="comment">//返回三者中最小的那个生命周期状态</span></span><br><span class="line">    <span class="keyword">return</span> min(min(mState, siblingState), parentState);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法中<code>previous</code>就是新添加的这个观察者的前一个观察者，也就是在添加这个新的观察者之前，<code>mObserverMap</code>的双向链表中表尾的那个观察者，然后会比较当前生命周期状态、前一个观察者的生命周期状态和<code>mParentState</code>栈顶保存的生命周期状态，最终会返回它们三者中最小的生命周期状态。这样就可以保证新添加的观察者的生命周期状态不会大于已添加的观察者的生命周期状态。</p><p>看到这里其实还是比较疑惑，因为要做到上面描述的那种保证，只需要<code>previous</code>就可以做到，那么<code>mParentStates</code>到底有什么作用呢？我们知道在执行观察者的回调方法前，会将观察者的生命周期状态入栈保存，在回调方法执行完毕后，再将保存的观察者的生命周期状态出栈，所以在不发生生命周期事件嵌套的时候，这个<code>mParentStates</code>栈是空的，也就是说，在这种情况下，它是没用的。而在<code>calculateTargetState()</code>方法中，如果它不是空的，那肯定是发生了嵌套了，那么它的栈顶保存的就是<code>previous</code>所代表的这个新添加的观察者的前一个观察者的生命周期状态，也就是说，在<code>previous</code>依然存在的情况下，<code>mParentStates</code>栈仍然是没用的。那如果<code>previous</code>不存在了呢，例如像声明<code>mParentStates</code>时的注释中描述的那样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// we have to keep it for cases:</span></span><br><span class="line"><span class="comment">// void onStart() &#123;</span></span><br><span class="line"><span class="comment">//     mRegistry.removeObserver(this);</span></span><br><span class="line"><span class="comment">//     mRegistry.add(newObserver);</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">// newObserver should be brought only to CREATED state during the execution of</span></span><br><span class="line"><span class="comment">// this onStart method. our invariant with mObserverMap doesn&#x27;t help, because parent observer</span></span><br><span class="line"><span class="comment">// is no longer in the map.</span></span><br><span class="line"><span class="keyword">private</span> ArrayList&lt;State&gt; mParentStates = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br></pre></td></tr></table></figure><p>如果一个观察者在响应<code>ON_START</code>生命周期事件的回调中，先将自己从<code>mObserverMap</code>中删除，然后再添加一个新的观察者，添加这个新的观察者当然会调用<code>calculateTargetState()</code>方法，而如果这时候没有定义<code>mParentStates</code>的话，该方法就会返回当前生命周期状态(<code>mState</code>)和前一个观察者的生命周期状态二者中较小的那个，那如果<code>mObserverMap</code>中原本就只有这个已经被删除的观察者呢？也就是说这时候<code>mObserverMap</code>是空的，<code>previous</code>不存在(已经被删除了),那么<code>calculateTargetState()</code>方法返回的就是当前声明周期状态<code>STARTED</code>，并会使用这个<code>STARTED</code>来同步这个新添加的观察者的状态。但是需要注意的是，此时这个观察者(也就是这个被删除的观察者)的<code>ON_START</code>回调方法还没有结束，而新添加的观察者的<code>ON_START</code>回调方法就已经结束了，这显然违背了<code>LifecycleRegistry</code>的设计初衷，因为它的初衷是同步是要按照<code>mObserverMap</code>中观察者的顺序来执行了，所以<code>mParentStates</code>就是用来防止发生这样的异常情况的。</p><h4 id="删除lifecycleobserver">删除LifecycleObserver</h4><p>删除观察者非常简单，直接从<code>mObserverMap</code>中删除即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeObserver</span><span class="params">(<span class="meta">@NonNull</span> LifecycleObserver observer)</span> </span>&#123;</span><br><span class="line">    mObserverMap.remove(observer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3id="reflectivegenericlifecycleobserver"><code>ReflectiveGenericLifecycleObserver</code></h3><p>通过上面的分析，我们了解到，<code>LifecycleRegistry</code>在分发声明周期事件时，<code>backwardPass()</code>方法和<code>forwardPass()</code>方法调用的是<code>ObserverWithStae</code>的<code>dispatchEvent()</code>方法，通常情况下最终调用的是<code>ReflectiveGenericLifecycleObserver</code>的<code>onStateChanged()</code>方法，我们来看一下这个类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReflectiveGenericLifecycleObserver</span> <span class="keyword">implements</span> <span class="title">LifecycleEventObserver</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object mWrapped;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CallbackInfo mInfo;</span><br><span class="line"></span><br><span class="line">    ReflectiveGenericLifecycleObserver(Object wrapped) &#123;</span><br><span class="line">        mWrapped = wrapped;</span><br><span class="line">        mInfo = ClassesInfoCache.sInstance.getInfo(mWrapped.getClass());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStateChanged</span><span class="params">(LifecycleOwner source, Event event)</span> </span>&#123;</span><br><span class="line">        mInfo.invokeCallbacks(source, event, mWrapped);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在它的构造函数中会使用到<code>ClassesInfoCache</code>这个类的<code>getInfo()</code>方法，并返回一个<code>CallbackInfo</code>对象，通过查看源码我们可以了解到，这个方法就是通过反射的方式去搜集观察者的信息，这些信息包括了观察者所定义的回调方法，这个<code>CallbackInfo</code>就是用来承载这些信息的。在<code>onStateChanged()</code>方法中其实就是去调用观察者所定义的这些回调方法。</p><h2 id="小结">小结</h2><p>至此，我们就明白了<code>Lifecycle</code>感知生命周期变化的基本原理了，最后附上一张图来作为总结，以便加深一下印象。</p><p><imgsrc="https://gitee.com/sachil/blog-pictures/raw/master/image/lifeCycle.png" /></p><hr /><p>参考文档：</p><p><ahref="https://juejin.cn/post/6893870636733890574#heading-17">“终于懂了“系列：JetpackAAC完整解析（一）Lifecycle 完全掌握！</a></p><p><ahref="https://blog.csdn.net/quiet_olivier/article/details/103384146">Android架构组件（2）LifecycleRegistry源码分析</a></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;jetpack之lifecycle&quot;&gt;Jetpack之Lifecycle&lt;/h1&gt;
&lt;p&gt;&lt;img
src=&quot;https://gitee.com/sachil/blog-pictures/raw/master/image/JetPack.png&quot; /&gt;&lt;/p&gt;
&lt;h2 id=&quot;jetpack套件&quot;&gt;Jetpack套件&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;Jetpack&lt;/code&gt;翻译成中文就是喷气背包的意思，它是&lt;code&gt;Android&lt;/code&gt;提供的一个由多个库组成的套件，可以帮助开发者遵循最佳的做法，减少样板代码并编写可在各种&lt;code&gt;Android&lt;/code&gt;版本和设备中一致运行的代码，但是&lt;code&gt;Jetpack&lt;/code&gt;并不包含在&lt;code&gt;Android&lt;/code&gt;的SDK中，它是一个独立的套件。&lt;code&gt;Jetpack&lt;/code&gt;的名称和它带来的意义还挺配的，&lt;code&gt;Android&lt;/code&gt;机器人穿上&lt;code&gt;Jetpack&lt;/code&gt;之后，简直就可以直接起飞了。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Jetpack&lt;/code&gt;包含许多各种各样的库，它们按照各自功能的不同，被划分为&lt;code&gt;Architecture&lt;/code&gt;、&lt;code&gt;UI&lt;/code&gt;、&lt;code&gt;Foundation&lt;/code&gt;和&lt;code&gt;Behavior&lt;/code&gt;四个类别，就像下图中展示的那样。&lt;/p&gt;
&lt;p&gt;&lt;img
src=&quot;https://gitee.com/sachil/blog-pictures/raw/master/image/Jetpack_building.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;其中在我们平时的开发过程中，最关心的可能就是&lt;code&gt;Architecture&lt;/code&gt;部分了，因为它包含了一些我们耳熟能详的库，例如：&lt;code&gt;Lifecycle&lt;/code&gt;、&lt;code&gt;ViewModel&lt;/code&gt;、&lt;code&gt;LiveData&lt;/code&gt;和&lt;code&gt;DataBinding&lt;/code&gt;等。&lt;code&gt;Architecture&lt;/code&gt;其实是&lt;code&gt;Jetpack&lt;/code&gt;中最精华的部分，如果我们想要熟练的掌握&lt;code&gt;Jetpack&lt;/code&gt;，就必须重点学习&lt;code&gt;Architecture&lt;/code&gt;所包含的内容。现在，我们就来了解一下&lt;code&gt;Architecture&lt;/code&gt;中的基础之作：&lt;code&gt;Lifecycle&lt;/code&gt;。&lt;/p&gt;</summary>
    
    
    
    <category term="Jetpack" scheme="https://sachil.xyz/categories/Jetpack/"/>
    
    
    <category term="Android" scheme="https://sachil.xyz/tags/Android/"/>
    
    <category term="Jetpack" scheme="https://sachil.xyz/tags/Jetpack/"/>
    
  </entry>
  
  <entry>
    <title>Android实战-增量更新</title>
    <link href="https://sachil.xyz/posts/4225ce89/"/>
    <id>https://sachil.xyz/posts/4225ce89/</id>
    <published>2019-03-19T01:30:16.000Z</published>
    <updated>2023-06-20T15:46:03.207Z</updated>
    
    <content type="html"><![CDATA[<h1 id="android实战-增量更新">Android实战-增量更新</h1><p>增量更新是区别于全量更新而提出的。全量更新是指在应用更新时，每次都下载完整的安装包，进行覆盖安装。在Android早期，由于应用普遍比较小，因此为了简单便捷，普遍使用全量更新的方式，但是随着Android的发展，应用也变得越来越大，为了节省更新的时间，以及节省下载的流量，增量更新也就变得越来越普遍。</p><span id="more"></span><h2 id="增量更新的原理">增量更新的原理</h2><p>在发布新版本的apk时，使用差分算法，计算出与老版本apk的差异，两个版本之间的不同的部分，生成一个patch文件，在升级的时候，用户只需要下载这个patch文件，然后旧版本的app利用这个patch文件与自己的apk合成，从而得到新版本的apk文件，再进行安装，这样app就升级为新的版本了。</p><p>具体步骤一般是这样的：</p><ol type="1"><li>在发布新版本apk上传到服务器时，同时生成与以往每一个版本的patch文件，以便app端升级时使用。</li><li>app利用自己当前的版本信息向服务器查询升级服务，服务器一般会返回patch文件的下载地址，patch文件的MD5值，以及新版本APK的MD5值。</li><li>app下载patch文件，并校验patch文件的MD5值是否正确，如果准确无误，则利用patch文件与自己的apk文件进行合成，生成新的apk文件，然后校验生成的apk文件的MD5值是否正确，如果准确无误，则进行安装。</li></ol><h2 id="操作实践">操作实践</h2><p>增量升级的核心就是利用<code>diff/patch</code>算法来对新/旧apk进行<code>diff/patch</code>操作，当前主流的做法是利用<code>bsdiff</code>工具。</p><h3 id="服务器端配置">服务器端配置</h3><p>首先需要在服务器端安装<code>bsdiff</code>工具，由于该工具依赖<code>bzip2</code>库，所以需要先安装<code>bzip2</code>库文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install libbz2-dev <span class="comment">#ubuntu 18.04</span></span><br></pre></td></tr></table></figure><p>然后下载<ahref="https://github.com/mendsley/bsdiff/archive/v4.3.tar.gz">bsdiff工具</a>，当前版本为4.3，然后解压：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf bsdiff-4.3.tar.gz</span><br><span class="line"><span class="built_in">cd</span> bsdiff-4.3</span><br></pre></td></tr></table></figure><p>这里连主要包含两个c文件：bsdiff.c用于生成patch补丁文件，bspatch.c用于将patch文件与旧版本apk合成。我们需要修改一下makefile文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">CFLAGS          +=      -O3 -lbz2</span><br><span class="line">CC = gcc</span><br><span class="line"></span><br><span class="line">PREFIX          ?=      /usr/<span class="built_in">local</span></span><br><span class="line">INSTALL_PROGRAM ?=      <span class="variable">$&#123;INSTALL&#125;</span> -c -s -m 555</span><br><span class="line">INSTALL_MAN     ?=      <span class="variable">$&#123;INSTALL&#125;</span> -c -m 444</span><br><span class="line"></span><br><span class="line">all:            bsdiff bspatch</span><br><span class="line">bsdiff:         bsdiff.c</span><br><span class="line">        $(CC) bsdiff.c $(CFLAGS) -o bsdiff</span><br><span class="line">bspatch:        bspatch.c</span><br><span class="line">        $(CC) bspatch.c $(CFLAGS) -o bspatch</span><br><span class="line"></span><br><span class="line">install:</span><br><span class="line">        <span class="variable">$&#123;INSTALL_PROGRAM&#125;</span> bsdiff bspatch <span class="variable">$&#123;PREFIX&#125;</span>/bin</span><br><span class="line">        .ifndef WITHOUT_MAN</span><br><span class="line">        <span class="variable">$&#123;INSTALL_MAN&#125;</span> bsdiff.1 bspatch.1 <span class="variable">$&#123;PREFIX&#125;</span>/man/man1</span><br><span class="line">        .endif</span><br></pre></td></tr></table></figure><p>然后我们执行<code>make</code>命令，这时候会在目录下生成<code>bsdiff</code>和<code>bspatch</code>两个可执行文件。生成patch文件可以使以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bsdiff oldFile newFile patchFile</span><br></pre></td></tr></table></figure><p>这样服务器端，我们就得到了patch文件。</p><h3 id="客户端配置">客户端配置</h3><p>首先，我们先下载<ahref="ftp://sourceware.org/pub/bzip2/bzip2-1.0.6.tar.gz"><code>bzip2</code>源文件</a>并解压，然后在<code>Android Studio</code>中新建一个<code>C++ Native</code>工程，然后在<code>cpp</code>目录下，新建一个<code>bzip2</code>目录，然后将刚才<code>bzip2</code>解压后目录中的所有c文件和h文件拷贝到这个新建的目录中，然后将<code>bspatch.c</code>文件拷贝到<code>cpp</code>目录下，并删除自动生成的<code>native-lib.cpp</code>文件，最后我们修改一下<code>CMakeLists.txt</code>文件以及<code>bspatch.c</code>文件。</p><p><code>CMakeLists.txt</code>文件：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># For more information about using CMake with Android Studio, read the</span></span><br><span class="line"><span class="comment"># documentation: https://d.android.com/studio/projects/add-native-code.html</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Sets the minimum version of CMake required to build the native library.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.4</span>.<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Creates and names a library, sets it as either STATIC</span></span><br><span class="line"><span class="comment"># or SHARED, and provides the relative paths to its source code.</span></span><br><span class="line"><span class="comment"># You can define multiple libraries, and CMake builds them for you.</span></span><br><span class="line"><span class="comment"># Gradle automatically packages shared libraries with your APK.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">add_library</span>( <span class="comment"># Sets the name of the library.</span></span><br><span class="line">             bspatch</span><br><span class="line"></span><br><span class="line">             <span class="comment"># Sets the library as a shared library.</span></span><br><span class="line">             SHARED</span><br><span class="line"></span><br><span class="line">             <span class="comment"># Provides a relative path to your source file(s).</span></span><br><span class="line">             bspatch.c )</span><br><span class="line"></span><br><span class="line"><span class="comment"># Searches for a specified prebuilt library and stores the path as a</span></span><br><span class="line"><span class="comment"># variable. Because CMake includes system libraries in the search path by</span></span><br><span class="line"><span class="comment"># default, you only need to specify the name of the public NDK library</span></span><br><span class="line"><span class="comment"># you want to add. CMake verifies that the library exists before</span></span><br><span class="line"><span class="comment"># completing its build.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">find_library</span>( <span class="comment"># Sets the name of the path variable.</span></span><br><span class="line">              log-lib</span><br><span class="line"></span><br><span class="line">              <span class="comment"># Specifies the name of the NDK library that</span></span><br><span class="line">              <span class="comment"># you want CMake to locate.</span></span><br><span class="line">              log )</span><br><span class="line"></span><br><span class="line"><span class="comment"># Specifies libraries CMake should link to your target library. You</span></span><br><span class="line"><span class="comment"># can link multiple libraries, such as libraries you define in this</span></span><br><span class="line"><span class="comment"># build script, prebuilt third-party libraries, or system libraries.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">target_link_libraries</span>( <span class="comment"># Specifies the target library.</span></span><br><span class="line">                       bspatch</span><br><span class="line"></span><br><span class="line">                       <span class="comment"># Links the target library to the log library</span></span><br><span class="line">                       <span class="comment"># included in the NDK.</span></span><br><span class="line">                       <span class="variable">$&#123;log-lib&#125;</span> )</span><br></pre></td></tr></table></figure><p><code>bspatch.c</code>文件：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;err.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;jni.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;bzip2/bzlib.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;bzip2/bzlib.c&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;bzip2/crctable.c&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;bzip2/compress.c&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;bzip2/decompress.c&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;bzip2/randtable.c&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;bzip2/blocksort.c&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;bzip2/huffman.c&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">JNIEXPORT jint JNICALL <span class="title">Java_com_example_smartupdate_MainActivity_patch</span><span class="params">(JNIEnv *env,</span></span></span><br><span class="line"><span class="function"><span class="params">        jobject instance,</span></span></span><br><span class="line"><span class="function"><span class="params">        jstring oldAPKPath_,</span></span></span><br><span class="line"><span class="function"><span class="params">        jstring newAPKPath_,</span></span></span><br><span class="line"><span class="function"><span class="params">        jstring patchPath_)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *oldAPKPath = (*env)-&gt;GetStringUTFChars(env, oldAPKPath_, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *newAPKPath = (*env)-&gt;GetStringUTFChars(env, newAPKPath_, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *patchPath = (*env)-&gt;GetStringUTFChars(env, patchPath_, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> argc = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">char</span> *argv[<span class="number">4</span>];</span><br><span class="line">    argv[<span class="number">0</span>] = <span class="string">&quot;bspatch&quot;</span>;</span><br><span class="line">    argv[<span class="number">1</span>] = oldAPKPath;</span><br><span class="line">    argv[<span class="number">2</span>] = newAPKPath;</span><br><span class="line">    argv[<span class="number">3</span>] = patchPath;</span><br><span class="line">    <span class="keyword">int</span> ret = bspatch_main(argc, argv);</span><br><span class="line">    (*env)-&gt;ReleaseStringUTFChars(env, oldAPKPath_, oldAPKPath);</span><br><span class="line">    (*env)-&gt;ReleaseStringUTFChars(env, newAPKPath_, newAPKPath);</span><br><span class="line">    (*env)-&gt;ReleaseStringUTFChars(env, patchPath_, patchPath);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将原来的main函数，改名为bspatch_main函数，才能正常使用</span></span><br></pre></td></tr></table></figure><p>这样编译之后，我们就可以得到<code>libbspatch.so</code>动态库了，增量更新有一个前提就是，必须有一个可供打patch的apk文件，我们可以在代码中来获取自己app的apk路径。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="keyword">init</span> &#123;</span><br><span class="line">            System.loadLibrary(<span class="string">&quot;bspatch&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">external</span> <span class="function"><span class="keyword">fun</span> <span class="title">patch</span><span class="params">(oldAPKPath: <span class="type">String</span>, newAPKPath: <span class="type">String</span>, patchPath: <span class="type">String</span>)</span></span>: <span class="built_in">Int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//获取自己app的apk文件路径</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">getAPKPath</span><span class="params">()</span></span>:String?&#123;</span><br><span class="line">    <span class="keyword">val</span> intent = Intent(Intent.ACTION_MAIN, <span class="literal">null</span>)</span><br><span class="line">    intent.addCategory(Intent.CATEGORY_LAUNCHER)</span><br><span class="line">    <span class="keyword">val</span> infoList = packageManager.queryIntentActivities(intent, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">var</span> oldAPKPath:String? = <span class="literal">null</span></span><br><span class="line">    infoList.forEach &#123; app -&gt;</span><br><span class="line">        <span class="keyword">val</span> dir = app.activityInfo.applicationInfo.publicSourceDir</span><br><span class="line">        <span class="keyword">if</span> (dir.contains(packageName)) &#123;</span><br><span class="line">            oldAPKPath = dir</span><br><span class="line">            <span class="keyword">return</span><span class="symbol">@forEach</span></span><br><span class="line">        &#125;</span><br><span class="line">     &#125;</span><br><span class="line">    <span class="keyword">return</span> oldAPKPath</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，我们就可以调用<code>patch</code>方法生成新的apk文件(MD5值的校验本文暂不提及)，从而进行升级了。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;android实战-增量更新&quot;&gt;Android实战-增量更新&lt;/h1&gt;
&lt;p&gt;增量更新是区别于全量更新而提出的。全量更新是指在应用更新时，每次都下载完整的安装包，进行覆盖安装。在Android早期，由于应用普遍比较小，因此为了简单便捷，普遍使用全量更新的方式，但是随着Android的发展，应用也变得越来越大，为了节省更新的时间，以及节省下载的流量，增量更新也就变得越来越普遍。&lt;/p&gt;</summary>
    
    
    
    <category term="Android实战" scheme="https://sachil.xyz/categories/Android-Practice/"/>
    
    
    <category term="Android实战" scheme="https://sachil.xyz/tags/Android-Practice/"/>
    
    <category term="增量更新" scheme="https://sachil.xyz/tags/Incremental-Update/"/>
    
  </entry>
  
  <entry>
    <title>Android基础-Handler消息机制</title>
    <link href="https://sachil.xyz/posts/424bac86/"/>
    <id>https://sachil.xyz/posts/424bac86/</id>
    <published>2018-09-14T09:15:45.000Z</published>
    <updated>2023-06-20T15:46:03.207Z</updated>
    
    <content type="html"><![CDATA[<h1 id="android基础-handler消息机制">Android基础-Handler消息机制</h1><h2 id="设计handler的主要目的">设计Handler的主要目的</h2><p>Handler的主要用途有两点：</p><ul><li><strong>规划<code>Message</code>或者<code>Runnable</code>在某个时间点执行</strong></li><li><strong>在另外一个线程上执行代码</strong></li></ul><p>众所周知，Android默认是运行在主线程，即UI线程，但是我们不能将耗时的任务放在UI线程中执行，否则会造成ANR错误，所以我们会新建一个线程，将耗时的任务交由这个线程去完成。但是当任务完成返回结果需要刷新UI的时候，由于UI线程不是线程安全的，在多线程并发的情况下访问UI线程，可能会造成UI控件处于不可预期的状态，所以Android不允许在其它线程中直接刷新UI。这样Handler就孕育而生了，通过Handler可以将有关UI的操作切换到主线程中去执行。</p><span id="more"></span><h2 id="handler消息机制的主要构成">Handler消息机制的主要构成</h2><p>Handler消息机制主要由4部分组成：<code>Handler</code>、<code>MessageQueue</code>、<code>Looper</code>和<code>Message</code>。</p><h3 id="handler">Handler</h3><p><code>Handler</code>用来发送和处理线程对应的<code>MessageQueue</code>中存储的<code>Message</code>的，每个Handler实例对应一个线程以及一个该线程的消息队列。当你新建一个<code>Handler</code>时，它会绑定到创建它的线程以及该线程的消息队列，然后它会向该消息队列发送<code>Message</code>或者<code>Runnable</code>，并且在它们离开消息队列时执行它们。</p><h3 id="messagequeue">MessageQueue</h3><p><code>Handler</code>其实相当于一个甩手掌柜，发送消息的任务其实是交给<code>MessageQueue</code>来完成的。<strong><code>MessageQueue</code>采用单链表结构来存储<code>Message</code>，并且是按照<code>Message</code>的触发时间的先后顺序来排序的。</strong><code>MessageQueue</code>调用<code>enqueueMessage()</code>方法将<code>Message</code>存储起来，而取出<code>Message</code>则时调用<code>next()</code>方法，该方法是一个死循环，不断的轮询<code>MessageQueue</code>中是否有<code>Message</code>，当没有<code>Message</code>时，为了避免消耗CPU，该方法就会阻塞，直到有新的<code>Message</code>到来，或则退出。</p><h3 id="looper">Looper</h3><p>虽然<code>MessageQueue</code>提供了<code>Message</code>入队、出队的方法，但是它并不是自动取出消息，想要从<code>MessageQueue</code>中取出消息，则需要<code>Looper</code>来执行。<strong>创建<code>Handler</code>之前，必须先创建<code>Looper</code>，否则会发生异常</strong>，一般线程默认是不会创建<code>Looper</code>的，需要我们主动创建，而主线程已经默认为我们创建了<code>Looper</code>，所以我们可以直接在主线程中创建<code>Handler</code>。创建<code>Looper</code>可以通过<code>Looper.prepare()</code>方法，创建<code>Looper</code>实例的时候，同时会创建<code>MessageQueue</code>实例，并且关联到当前线程，每个线程的<code>Looper</code>是通过<code>ThreadLocal</code>存储的，保证其线程私有。</p><p>想要使<code>MessageQueue</code>运转起来，则需要调用<code>Looper.loop()</code>方法，这是一个死循环，不停的从<code>MessageQueue</code>中取出消息，取出消息后交由<code>Handler</code>来分发，分发之后回收<code>Message</code>到消息池，以便重复利用。取出消息调用的是<code>MessageQueue</code>的<code>next()</code>方法，而分发消息则调用的是<code>Handler</code>的<code>dispatchMessage()</code>方法，该方法会调用<code>Handler</code>的<code>HandleMessage（）</code>方法。</p><h3 id="message">Message</h3><p><code>Message</code>实际就是消息的载体，它包含一些重要的属性：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int what ：消息标识</span><br><span class="line">int arg1 : 可携带的 int 值</span><br><span class="line">int arg2 : 可携带的 int 值</span><br><span class="line">Object obj : 可携带内容</span><br><span class="line">long when : 超时时间</span><br><span class="line">Handler target : 处理消息的 Handler</span><br><span class="line">Runnable callback : 通过 post() 发送的消息会有此参数</span><br></pre></td></tr></table></figure><p>其中需要注意的是，<strong>在<code>Handler</code>发送<code>Message</code>时，它会将<code>Message</code>的<code>target</code>属性设置为<code>Handler</code>自己</strong>。</p><p>所以总结一下Handler的主要构成就是：</p><ul><li>Handler 被用来发送消息，但并不是真正的自己去发送。它持有MessageQueue 对象的引用，通过 MessageQueue 来将消息入队。</li><li>Handler 也持有 Looper 对象的引用，通过 <code>Looper.loop()</code>方法让消息队列循环起来。</li><li>Looper 持有 MessageQueue 对象应用，在 <code>loop()</code>方法中会调用 MessageQueue 的 <code>next()</code>方法来不停的取消息。</li><li><code>loop()</code> 方法中取出来的消息最后还是会调用 Handler 的<code>dispatchMessage()</code> 方法来进行分发和处理。</li></ul><h2 id="一些常见的问题">一些常见的问题</h2><ul><li><p><strong>一个线程能否创建多个Handler，Handler和Looper之间的对应关系是怎样的？</strong></p><p>一个线程可以创建多个<code>Handler</code>，但是一个线程只能有一个<code>Looper</code>，所以也只对应一个<code>MessageQueue</code>。</p></li><li><p><strong><code>Looper.loop()</code>是死循环，为什么它不会卡死主线程？</strong></p><p>其实两者并没有必然的联系，主线程中的<code>Looper.loop()</code>是让消息队列运作起来，一旦它退出了，程序也就退出了。它可能会阻塞主线程，但是只要消息循环没有阻塞，就不会引起ANR错误。造成ANR错误的不是主线程阻塞，而是主线程的<code>Looper</code>消息处理的时候发生了任务阻塞，无法响应及时刷新UI。</p></li><li><p><strong>Handler发生泄露的原因以及解决方法？</strong></p><p><code>Handler</code>允许发送延时消息，而在延时的期间用户关闭了<code>Activity</code>，由于<code>Message</code>持有<code>Handler</code>对象，而由于Java特性，内部类持有外部类的引用，所以<code>Handler</code>持有<code>Activity</code>，所以<code>Activity</code>就泄露了。解决方案是将<code>Handler</code>改为静态内部类，其内部持有<code>Activity</code>的<strong>弱引用</strong>，并且在<code>Activity</code>的<code>onDestory()</code>回调中调用<code>handler.removeCallbacksAndMessages()</code>方法，及时移除所有消息。</p></li><li><p><strong>Handler能够切换线程的最主要原因是什么？</strong></p><p>其实就是一句话，Handler实例是存储在<strong>堆区</strong>，这个区域对于同一进程的不同线程是共享的。所以可以在A线程访问B线程的Handler，并向这个Handler所持有的MessageQueue插入Message，而B线程通过自己的Looper的loop()方法，获取到Message，并通过Message的target调用该Handler的dispatchMessage()方法，进而调用handleMessage()回调方法。</p></li><li><p><strong>Handler的同步屏障机制</strong></p><p>同步屏障机制实际上是一个对消息队列MessageQueue附加优先级的机制，众所周知，MessageQueue是单链表结构，其中Message的排列顺序是按照Message的触发时间的先后顺序排列的。但是有的时候，一些事件需要立即得到处理，这就需要插队了。Handler可以发送<strong>同步信息</strong>和<strong>异步信息</strong>两种信息(我们平时主要用到的是前者)，开启同步屏障可以在MessageQueue的next()方法被调用时只处理异步信息，同步信息将会被无视。调用<code>postSyncBarrier()</code>开启同步屏障，关闭同步屏障可以调用<code>removeSyncBarrier()</code>(这两个方法不能在APP中调用)。同步屏障机制的实现原理是在MessageQueue的首部插入一条target为null的Message，这条message就相当于一个标志位，在<code>next()</code>方法中会去判断这个标志位，从而实现屏蔽同步信息的功能。</p></li><li><p><strong>MessageQueue中的IdleHandler</strong></p><p><code>IdleHandler</code>实际上是一个接口，其用处从本质上讲就是在MessageQueue空闲的时候做一些事情，它只有一个方法<code>boolean queueIdle()</code>，其返回值如果为<code>true</code>则表示下次空闲的时候仍会执行这条消息，为<code>false</code>的话则只会执行一次，在执行完毕后会移出这条消息。<code>queueIdle()</code>执行的时机一个是messageQueue中没有message或者message的执行事件还未到时，在实际开发中用到很少，因为它的执行时机很不确定，<code>queueIdle</code>方法执行的线程是Looper所在的线程，也就是messageQueue所绑定的线程。</p></li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;android基础-handler消息机制&quot;&gt;Android基础-Handler消息机制&lt;/h1&gt;
&lt;h2 id=&quot;设计handler的主要目的&quot;&gt;设计Handler的主要目的&lt;/h2&gt;
&lt;p&gt;Handler的主要用途有两点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;规划&lt;code&gt;Message&lt;/code&gt;或者&lt;code&gt;Runnable&lt;/code&gt;在某个时间点执行&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;在另外一个线程上执行代码&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;众所周知，Android默认是运行在主线程，即UI线程，但是我们不能将耗时的任务放在UI线程中执行，否则会造成ANR错误，所以我们会新建一个线程，将耗时的任务交由这个线程去完成。但是当任务完成返回结果需要刷新UI的时候，由于UI线程不是线程安全的，在多线程并发的情况下访问UI线程，可能会造成UI控件处于不可预期的状态，所以Android不允许在其它线程中直接刷新UI。这样Handler就孕育而生了，通过Handler可以将有关UI的操作切换到主线程中去执行。&lt;/p&gt;</summary>
    
    
    
    <category term="Android基础" scheme="https://sachil.xyz/categories/Android-Basis/"/>
    
    
    <category term="Android基础" scheme="https://sachil.xyz/tags/Android-Basis/"/>
    
    <category term="Handler" scheme="https://sachil.xyz/tags/Handler/"/>
    
  </entry>
  
  <entry>
    <title>Android基础-四大组件</title>
    <link href="https://sachil.xyz/posts/6ee7637c/"/>
    <id>https://sachil.xyz/posts/6ee7637c/</id>
    <published>2018-09-01T11:05:09.000Z</published>
    <updated>2023-06-20T15:46:03.207Z</updated>
    
    <content type="html"><![CDATA[<h1 id="android基础-四大组件">Android基础-四大组件</h1><h2 id="activity">Activity</h2><p>Activity用于向用户展示内容并且接受用户操作的界面，实际上等同于app与用户之间进行交互的接口。</p><h3 id="activity的生命周期">Activity的生命周期</h3><ul><li><p>onCreate()</p><p>在这个方法中进行初始化操作，比如加载布局，绑定事件，初始化数据等。</p></li><li><p>onRestart()</p><p>在Activity由停止状态转变为运行状态前调用。</p><span id="more"></span></li><li><p>onStart()</p><p>当Activity又不可见变为可见时调用，虽然此时Activity未出现在前台，不能与用户进行交互，但是它已经是可见的了。</p></li><li><p>onResume()</p><p>Activity出现在前台，并且可以和用户进行交互。<strong>此时Activity一定处于任务栈的栈顶，并且处于运行状态。</strong></p></li><li><p>onPause()</p><p>在系统准备启动或者恢复另一个Activity时调用。<strong>我们通常在这个方法中将一些极其消耗CPU的资源释放掉，并且保存一些关键数据，但是速度一定要快，否则会影响新的栈顶Activity的使用。</strong></p></li><li><p>onStop()</p><p>在Activity<strong>完全不可见时</strong>调用。<strong>与onPause()不同的是，如果启动的是一个对话框式的Activity或者背景透明的Activity，onPause()会被调用，而onStop()不会被调用。</strong></p></li><li><p>onDestory()</p><p>在Activity销毁前调用，该方法执行后，Activity即被销毁。</p></li></ul><p>这几种方法，除了<code>onRestart()</code>，其他都是两两成对的，所以我们可以将Activity划分为3个时期：</p><ul><li><p>完整生存期</p><p>在<code>onCreate()</code>和<code>onDestory（）</code>方法之间所经历的，就是完整生存期。</p></li><li><p>可见生存期</p><p>在<code>onStart（）</code>和<code>onStop()</code>方法之间所经历的，就是可见生存期。</p></li><li><p>前台生存期</p><p>在<code>onResume()</code>和<code>onPause()</code>之间所经历的，就是前台生存期。</p></li></ul><p>当Activity意外终止时，在<code>onStop()</code>方法调用之前，系统会调用<code>ononSaveInstanceState()</code>方法，用于保存Activity的状态，并在<code>onCreate()</code>方法调用后，在<code>onRestoreInstanceState()</code>方法中恢复状态。</p><h2 id="service">Service</h2><p>service是一种可在后台执行长时间运行操作而不提供界面的应用组件,可以执行一些耗时的任务。service在其托管的进程的UI线程运行，默认情况下，它既不创建线程，也不在单独的进程中运行，如果执行一些CPU密集型操作或者阻止性操作，请在service中开启线程来进行这些操作，否则会出现ANR错误。</p><h3 id="运行service的方式">运行Service的方式</h3><p>运行service有以下两种方式：</p><ul><li><p><strong>通过<code>startService()</code>启动</strong>,一旦启动，Service则可以在后台无限期运行，即使启动它的组件已经销毁也不受影响。如果想停止service运行，可以通过<code>stopSelf()</code>方法自行停止运行，或者通过其他组件调用<code>stopService()</code>方法停止运行。并且在不需要Service工作时，记得将其停止，否则service将一直运行。</p><p><code>startService()</code>方法会调用Service的<code>onStartCommand()</code>方法，这个方法的返回值有特殊意义：</p><ul><li><strong><code>START_NOT_STICKY</code></strong>，当 Service因内存不足而被系统 kill后，即使系统内存再次空闲时，系统也不会尝试重新创建此Service。这是最安全的选项。</li><li><strong><code>START_STICKY</code></strong>，当 Service因内存不足而被系统 kill后，一段时间后内存再次空闲时，系统将会尝试重新创建此Service，一旦创建成功后将回调 onStartCommand 方法，但其中的 Intent 将是null，除非有挂起的 Intent。比较适合媒体播放器或类似的服务</li><li><strong><code>START_REDELIVER_STICKY</code></strong>，当 Service因内存不足而被系统 kill 后，则会重建服务，并通过传递给服务的最后一个Intent 调用 onStartCommand()，任何挂起 Intent 均依次传递。与START_STICKY 不同的是，其中的传递的 Intent 将是非空，是最后一次调用startService() 中的 intent。比较适合文件加载或类似需要恢复的服务。</li></ul></li><li><p><strong>通过<code>bindService()</code>绑定</strong>,在其它组件中通过<code>bindService()</code>方法也可以运行Service，并且通过这种绑定方式，组件可以获取到Service实例，从而可以进行交互。<code>bindService()</code>方法会调用Service的<code>onBind()</code>回调，在回调中可以返回一个IBinder的实例，从而实现绑定。组件可以使用<code>unBindService()</code>方法解除与Service间的绑定，它会调用service的<code>onUnBind()</code>回调，需要注意的是：</p><ul><li><strong>当第一个组件调用<code>bindService()</code>方法时，会调用<code>onBind()</code>回调，然后后面的组件继续绑定Service，如果系统判断到Intent相同，则不再调用<code>onBind()</code>回调。</strong></li><li><strong>当所有组件都与该Service解绑后，Service的<code>onUnBind()</code>回调才会执行，然后Service才会销毁。</strong></li><li><strong><code>unBind()</code>回调可以返回<code>true</code>，然后再次绑定时会回调<code>onRebind()</code>方法（前提是该Service仍然存在）。</strong></li><li><strong>当有组件绑定到Service时，即使调用<code>stopService()</code>方法尝试停止Service也不会成功。</strong></li><li><strong>Service的<code>onCreate()</code>回调只会执行一次。</strong></li></ul></li></ul><h3 id="service的生命周期">Service的生命周期</h3><ul><li>通过<code>startService()</code>方式运行，<strong>启动Service-&gt;<code>onCreate()</code>-&gt;<code>onStartCommand</code>-&gt;Service正在运行-&gt;<code>onDestory()</code>-&gt;Service销毁</strong></li><li>通过<code>bindService</code>方式运行，<strong>绑定Service-&gt;<code>onCreate()</code>-&gt;<code>onBInd()</code>-&gt;Service正在运行-&gt;<code>onUnbind()</code>-&gt;<code>onDestory()</code>-&gt;Service销毁</strong></li></ul><h3 id="intentservice">IntentService</h3><p>IntentService是service的扩展类，它会为Service单独创建一个线程，并且创建一个工作队列，用于将intent逐一地传递给<code>onHandleIntent()</code>方法，所以它是串行的执行任务，不用担心多线程问题，它还会在执行完所有任务后自动地停止Service，不用手动调用停止的方法。需要注意的是：<strong>IntentService执行传递给<code>onStartCommand()</code>的Intent，所以需要调用<code>startService()</code>使其运行。</strong></p><h3 id="foregroundservice">ForegroundService</h3><p>ForegroundService(前台服务)是用户主动意识到的一种Service，因此在内存不足时，系统也不会考虑将其终止。<strong>ForegroundService必须为状态栏提供显示优先级为<code>PRIORTY_LOW</code>或更高的通知</strong>，以帮助用户知道应用正在执行的任务，除非停止Service或者将Service转为后台，否则无法清楚通知。</p><p><strong>从Android 9开始，使用ForegroundService必须请求<code>FOREGROUND_SERVICE</code>权限</strong>，启动ForegroundService可以使用<code>startForeground()</code>方法，<strong>该方法的整型ID不能为0</strong>，移除ForegroundService可以调用<code>stopForeground()</code>方法，<strong>该方法不会停止Service，而是将其从前台转为后台运行。</strong></p><p>跨进程调用可以使用<strong><code>Messenger</code></strong>和<strong><code>AIDL</code></strong>方式。</p><h2 id="broadcast">Broadcast</h2><p>广播(broadcast)是一个全局的监听器，可以监听整个系统或者整个app，能用于跨进程或者进程内通信，其采用观察者模式，基于消息的订阅/发布模型。这其中有3个角色：1.广播发送者，2.消息中心(Activity Manager Service)，3.广播接受者(BroadcastReceiver)。</p><h3 id="broadcast的注册">Broadcast的注册</h3><ul><li><p>静态注册，静态注册是指在AndroidManifest.xml中进行注册。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;receiver</span><br><span class="line">          <span class="comment">&lt;!-- Android7.0开始，如果为false，手机重启后未解锁前，广播访问的数据是FBE加密的，将不能启动  --&gt;</span></span><br><span class="line">      android:directBootAware=[&quot;true&quot; | &quot;false&quot;]</span><br><span class="line">      android:enabled=[&quot;true&quot; | &quot;false&quot;]</span><br><span class="line">      android:exported=[&quot;true&quot; | &quot;false&quot;]</span><br><span class="line">      android:icon=&quot;drawable resource&quot;</span><br><span class="line">      android:label=&quot;string resource&quot;</span><br><span class="line">      android:name=&quot;.MBroadcastReceiver&quot;</span><br><span class="line">      android:permission=&quot;string&quot;</span><br><span class="line">      android:process=&quot;string&quot; &gt;</span><br><span class="line">    <span class="tag">&lt;<span class="name">intent-filter</span> <span class="attr">android:icon</span>=<span class="string">&quot;drawable resource&quot;</span></span></span><br><span class="line"><span class="tag">              <span class="attr">android:label</span>=<span class="string">&quot;string resource&quot;</span></span></span><br><span class="line"><span class="tag">              <span class="attr">android:priority</span>=<span class="string">&quot;integer&quot;</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">&quot;android.net.conn.CONNECTIVITY_CHANGE&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">receiver</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>动态注册，动态注册是指在代码中通过<code>registerReceiver()</code>方法注册广播，如果是动态注册，则需要在组件的相应生命周期内使用<code>unregisterReceiver()</code>取消广播的注册。</p></li></ul><h3 id="broadcast的类型">Broadcast的类型</h3><p>按照不同的划分方法，可以将Broadcast划分为不同的类型。</p><ul><li><p><strong>自定义广播和系统广播</strong></p></li><li><p><strong>普通广播和有序广播</strong></p><p>普通广播以异步的方式发送给接收者，所有满足条件的接收者几乎可以同时收到广播，没有顺序之分，也不用想AMS返回处理结果。各接收者互不干扰，效率较高。</p><p>有序广播是以一种同步的方式向接收者发送广播的。广播接收者会根据开发者设定的优先级进行排序，AMS会先给最高优先级接收者发送广播，该接收器处理完广播后需要返回处理结果给AMS，然后再向次优先级接收者发送广播，依此类推。广播接收者可以把处理结果传递给是下一个接收者，也可以终止广播的传递。如果某个接收者超时或者终止了广播，那么后面的接收者也将无法再收到广播，所以效率会比较低。有序广播对比普通广播，有几个关键的地方需要注意：</p><ol type="1"><li><code>android:priority</code>用于设置接收器优先级。</li><li><code>getResultData()</code>获取广播数据。</li><li><code>setResultData()</code>向下一接收者传递数据。</li><li><code>abortBroadcast()</code>用于终止广播的传递。</li></ol></li><li><p><strong>全局广播和局部广播</strong>，从机制上看，如果发送广播的可以被其他app（以app进程为限）接收，那么该广播为全局广播；如果只能被app内部接收，那么该广播为局部广播。</p><p>全局广播在安全和性能方面存在一些问题，无疑增加了系统的负担，为了解决这方面的问题，可以通过设置“android:exported”，permission，setPackage等各种方式来限定接收范围，从而在安全和性能方面进行优化。</p><p>局部广播(Android v4兼容包提供<code>android.support.v4.content.LocalBroadcastManager</code>工具类用于实现局部广播。)，也叫做本地广播，局部广播有以下3点优势：</p><ul><li><strong>你所传播的数据不会离开当前你的app，所以无需担心会泄漏私人数据。</strong></li><li><strong>其他app无法发送广播到你的app，所以你无需担心这些广播导致的安全漏洞。</strong></li><li><strong>比起通过系统来实现发送的全局广播，这种方式更高效（不需要发送给整个系统）。</strong></li></ul><p>局部广播相对于全局广播来说更加高效的原因是，其内部实现并不是采用Binder机制，而是采用Handler机制，发送局部广播，其实就是向Handler发送了一个Message，但是其需要注意的地方有:</p><ul><li><strong>只能通过动态注册。</strong></li><li><strong>一定不要忘记前面提到的三个方法前加上<code>LocalBroadcastManager.getInstance(mContext)</code>，否则可能接收不到广播或者无法实现局部广播的效果。</strong></li></ul></li><li><p><strong>前台广播和后台广播</strong>，根据发送的广播被接收的优先级，可以将广播分为前台广播和后台广播。</p><p>前台广播是为了减少广播接收的延时(添加<code>Intent.FLAG_RECEIVER_FOREGROUND</code>这个flag，可以将广播设置为前台广播)，前台广播的ANR时间限制是10s。未设置这个flag的广播则是后台广播，后台广播的ANR时间限制是60s。</p></li><li><p><strong>并行广播和串行广播</strong>，根据接收和处理广播事件的方式是并行的还是串行的，可以把广播分为并行广播和串行广播。</p><p>并行广播，在代码中注册的普通广播。</p><p>串行广播，在文件清单中注册的普通广播，和有序广播。</p></li><li><p><strong>粘性广播和非粘性广播</strong>(Android5.0开始已经废弃掉)</p></li></ul><h3 id="broadcast-receiver的生命周期">Broadcast Receiver的生命周期</h3><p>广播接收器自然也有自己的生命周期。只是它的生命周期非常简单且非常短，只有onReceive一个回调方法，当收到广播产生onReceive回调开始，到onReceive方法执行完并return，广播接收器的生命周期便宣告结束。<strong>BroadcastReceiver默认运行在UI线程，所以不要运行耗时的操作，也不要在receiver中开启线程进行耗时操作，因为当onReceive()返回时，BroadcastReceiver的生命周期就已经结束了，系统随时可能进行回收，线程可能无法按照预期运行。解决办法是可以使用：jobService，goAsync，startService(最常使用)。</strong></p><h3 id="onreceive方法的上下文">onReceive()方法的上下文</h3><p>广播接收器的Context：</p><ul><li>局部广播：applicationContext实例</li><li>静态注册的广播：ReceiverRestrictedContext实例</li><li>动态注册的广播：组件(Activity,Service)的context实例</li></ul><h3id="不同android版本广播机制的重要变迁">不同Android版本广播机制的重要变迁</h3><ul><li>Android5.0，废弃掉粘性广播</li><li>Android7.0，不在发送<code>ACTION_NEW_PICTURE</code>和<code>ACTION_NEW_VIDEO</code>系统广播，同时<code>CONNECTIVITY_ACTION</code>只能动态注册才能接收到。</li><li>Android8.0，系统对清单声明的接收器施加了额外的限制，对于大多数隐式广播（没有明确针对您的应用的广播），您不能使用静态注册来声明接收器。</li><li>Android9.0，<code>NEWWORK_STATE_CHANGED_ACTION</code>广播不再接收有关用户位置或个人身份数据的信息，此外，通过WLAN 接收的系统广播不包含 SSID、BSSID、连接信息或扫描结果。</li></ul><h2 id="content-provider">Content Provider</h2>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;android基础-四大组件&quot;&gt;Android基础-四大组件&lt;/h1&gt;
&lt;h2 id=&quot;activity&quot;&gt;Activity&lt;/h2&gt;
&lt;p&gt;Activity用于向用户展示内容并且接受用户操作的界面，实际上等同于app与用户之间进行交互的接口。&lt;/p&gt;
&lt;h3 id=&quot;activity的生命周期&quot;&gt;Activity的生命周期&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;onCreate()&lt;/p&gt;
&lt;p&gt;在这个方法中进行初始化操作，比如加载布局，绑定事件，初始化数据等。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;onRestart()&lt;/p&gt;
&lt;p&gt;在Activity由停止状态转变为运行状态前调用。&lt;/p&gt;</summary>
    
    
    
    <category term="Android基础" scheme="https://sachil.xyz/categories/Android-Basis/"/>
    
    
    <category term="Android基础" scheme="https://sachil.xyz/tags/Android-Basis/"/>
    
    <category term="Activity" scheme="https://sachil.xyz/tags/Activity/"/>
    
    <category term="Service" scheme="https://sachil.xyz/tags/Service/"/>
    
    <category term="Broadcast" scheme="https://sachil.xyz/tags/Broadcast/"/>
    
    <category term="Content Provider" scheme="https://sachil.xyz/tags/Content-Provider/"/>
    
  </entry>
  
  <entry>
    <title>Android基础-Intent和Intent Filter的匹配规则</title>
    <link href="https://sachil.xyz/posts/f366cc9a/"/>
    <id>https://sachil.xyz/posts/f366cc9a/</id>
    <published>2018-08-31T12:34:23.000Z</published>
    <updated>2023-06-20T15:46:03.207Z</updated>
    
    <content type="html"><![CDATA[<h1id="android基础-intent和intent-filter的匹配规则">Android基础-Intent和IntentFilter的匹配规则</h1><p>当收到隐式 Intent 以启动 Activity 时，系统会根据以下三个方面将该Intent 与 Intent 过滤器进行比较，搜索该 Intent 的最佳 Activity：</p><ul><li>操作：action</li><li>类别：category</li><li>数据：data</li></ul><h2 id="操作action的匹配">操作(action)的匹配</h2><p>action的匹配规则是：<strong>intent中的action至少有一个与过滤器(intentfilter)中的action匹配，才能调用过滤器所在的组件，否则将无法命中。</strong>所以，intent或者Intentfilter中任意一个中不包含action，都无法通过测试。</p><span id="more"></span><h2 id="类别category的匹配">类别(category)的匹配</h2><p>category的匹配规则是：<strong>intent中的每一个category都必须与过滤器(intentfilter)中的category相匹配，否则无法命中。而相反的，intentfilter中的category可以超出intent中的category的数量，intent是可以通过测试的。</strong></p><h2 id="数据data的匹配">数据(data)的匹配</h2><p>data的匹配规则是：</p><ul><li><strong>如果过滤器(intentfilter)中未指定任何URI和MIME类型，只有不包含URI和MIME类型的intent才会通过测试。</strong></li><li><strong>如果intent中包含URI而不包含MIME类型，则只有当intentfilter中也不包含MIME类型，且intentfilter中的URI和intent中的URI相匹配时，intent才会通过测试。</strong></li><li><strong>如果intentfilter中只包含MIME类型而不包含URI，只有当intent中的MIME类型与intentfilter中的MIME类型相匹配，并且intent包含<code>content:</code>或者<code>file</code>的URI，intent才会通过测试。</strong></li><li><strong>如果intentfilter中同时包含MIME类型和URI，则intent也必须包含与之相匹配的MIME类型和URI，intent才会通过测试。</strong></li></ul><p>URI通常包含这些属性：scheme(架构)，host(主机)，port(端口)，path(路径)。URI的格式为：<code>&lt;scheme&gt;://&lt;host&gt;:&lt;port&gt;/path</code>，URI的匹配规则是：</p><ul><li>如果过滤器仅指定架构，则具有该架构的所有 URI 均与该过滤器匹配。</li><li>如果过滤器指定架构和权限，但未指定路径，则具有相同架构和权限的所有URI 都会通过过滤器，无论其路径如何均是如此。</li><li>如果过滤器指定架构、权限和路径，则仅具有相同架构、权限和路径的 URI才会通过过滤器。</li></ul><h2 id="注意事项">注意事项</h2><p>如果当前设备中没有能够匹配你发送到 startActivity() 的隐式Intent，则调用将会失败，且应用会崩溃。这时候需要调用Intent的resolveActivity()方法进行测试，若其返回结果不为null，则可以安全调用。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> intent = Intent(Intent.ACTION_EDIT)</span><br><span class="line">intent.addCategory(Intent.CATEGORY_APP_EMAIL)</span><br><span class="line"><span class="keyword">val</span> uri = Uri.parse(<span class="string">&quot;content://baidu.com&quot;</span>)</span><br><span class="line">intent.setDataAndType(uri,<span class="string">&quot;text/plain&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> (intent.resolveActivity(packageManager) != <span class="literal">null</span>) &#123;</span><br><span class="line">    Log.e(<span class="string">&quot;Test&quot;</span>,<span class="string">&quot;Start activity&quot;</span>)</span><br><span class="line">    startActivity(intent)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1
id=&quot;android基础-intent和intent-filter的匹配规则&quot;&gt;Android基础-Intent和Intent
Filter的匹配规则&lt;/h1&gt;
&lt;p&gt;当收到隐式 Intent 以启动 Activity 时，系统会根据以下三个方面将该
Intent 与 Intent 过滤器进行比较，搜索该 Intent 的最佳 Activity：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;操作：action&lt;/li&gt;
&lt;li&gt;类别：category&lt;/li&gt;
&lt;li&gt;数据：data&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;操作action的匹配&quot;&gt;操作(action)的匹配&lt;/h2&gt;
&lt;p&gt;action的匹配规则是：&lt;strong&gt;intent中的action至少有一个与过滤器(intent
filter)中的action匹配，才能调用过滤器所在的组件，否则将无法命中。&lt;/strong&gt;所以，intent或者Intent
filter中任意一个中不包含action，都无法通过测试。&lt;/p&gt;</summary>
    
    
    
    <category term="Android基础" scheme="https://sachil.xyz/categories/Android-Basis/"/>
    
    
    <category term="Android基础" scheme="https://sachil.xyz/tags/Android-Basis/"/>
    
    <category term="Intent" scheme="https://sachil.xyz/tags/Intent/"/>
    
  </entry>
  
  <entry>
    <title>Android基础-Activity的四种启动模式</title>
    <link href="https://sachil.xyz/posts/a3b77b7e/"/>
    <id>https://sachil.xyz/posts/a3b77b7e/</id>
    <published>2018-08-20T05:10:40.000Z</published>
    <updated>2023-06-20T15:46:03.207Z</updated>
    
    <content type="html"><![CDATA[<h1id="android基础-activity的四种启动模式">Android基础-Activity的四种启动模式</h1><p>我们都知道，Android为Activity提供了<code>standard</code>，<code>singleTop</code>,<code>singleTask</code>和<code>singleInstance</code>4种启动模式(LaunchMode)，以适应不同的启动场景。但是如果想要熟练的掌握这些启动模式，并非你想象的那么简单，这其中会遇到一些坑，而且有的这些坑是Android官方文档带来的，在实践的过程中你会发现，有的现象和官方文档描述的完全不同(简直是坑你没商量啊！)，还有的官方文档中根本就没提。现在我们从实践中出发，来认真学习一下这4种启动模式。</p><span id="more"></span><h2 id="什么是task和回退栈">什么是Task和回退栈</h2><p>Task被称之为任务，也就是我们在最近任务列表中看到的那一个个东西，就像这样：</p><p><img src = "https://gitee.com/sachil/blog-pictures/raw/master/image/launch-mode-task.png" width="300" ></p><p>当我们启动App时，App的默认Activity会被启动，并且这个Activity会被放进系统刚创建的一个Task中，我们可以在多个App间进行切换，其实更准确的说，我们是在多个Task间进行切换。每个Task都有一个自己的回退栈(BackStack)，它按顺序记录了用户打开的每一个Activity，这样当用户按返回键时，可以按照顺序依次关闭这些Activity，当返回栈中的最后一个Activity被关闭时，这个Task也就结束了。需要注意的是，这时候仍可以在最近任务列表中看到这个Task，但这个Task其实是结束了的，所以，<strong>在最近任务列表中看到的Task未必就是活着的</strong>。</p><h2 id="四种不同的启动模式">四种不同的启动模式</h2><p>为了更好的认识这四种启动模式的作用，以及区别它们之间又有什么不同，我们通过创建App1和App2两个App，并改变App2中SecondActivity的launchMode来研究这四种启动模式。</p><p>App1的activity_main.xml：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">androidx.constraintlayout.widget.ConstraintLayout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xmlns:app</span>=<span class="string">&quot;http://schemas.android.com/apk/res-auto&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  &lt;Button</span><br><span class="line">    android:id=&quot;@+id/mainButton&quot;</span><br><span class="line">    android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">    android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">    android:text=&quot;Open&quot;</span><br><span class="line">    app:layout_constraintBottom_toBottomOf=&quot;parent&quot;</span><br><span class="line">    app:layout_constraintLeft_toLeftOf=&quot;parent&quot;</span><br><span class="line">    app:layout_constraintRight_toRightOf=&quot;parent&quot;</span><br><span class="line">    app:layout_constraintTop_toTopOf=&quot;parent&quot; /&gt;</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">androidx.constraintlayout.widget.ConstraintLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><p>App1的MainActivity:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//App1的MainActivity</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> : <span class="type">AppCompatActivity</span></span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_main)</span><br><span class="line">        <span class="comment">//点击button启动App2的SecondActivity</span></span><br><span class="line">        findViewById&lt;Button&gt;(R.id.mainButton).setOnClickListener &#123;</span><br><span class="line">            <span class="keyword">val</span> intent = Intent()</span><br><span class="line">            intent.action = <span class="string">&quot;com.perry.target&quot;</span></span><br><span class="line">            startActivity(intent)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>App2的activity_main.xml：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">androidx.constraintlayout.widget.ConstraintLayout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xmlns:app</span>=<span class="string">&quot;http://schemas.android.com/apk/res-auto&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xmlns:tools</span>=<span class="string">&quot;http://schemas.android.com/tools&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">tools:context</span>=<span class="string">&quot;.MainActivity&quot;</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">  &lt;Button</span><br><span class="line">    android:id=&quot;@+id/mainButton&quot;</span><br><span class="line">    android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">    android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">    android:layout_marginTop=&quot;16dp&quot;</span><br><span class="line">    app:layout_constraintBottom_toBottomOf=&quot;parent&quot;</span><br><span class="line">    app:layout_constraintEnd_toEndOf=&quot;@id/mainTextView&quot;</span><br><span class="line">    app:layout_constraintStart_toStartOf=&quot;@id/mainTextView&quot;</span><br><span class="line">    app:layout_constraintTop_toBottomOf=&quot;@id/mainTextView&quot;</span><br><span class="line">    android:text=&quot;Jump to second&quot;/&gt;</span><br><span class="line"></span><br><span class="line">  &lt;TextView</span><br><span class="line">    android:id=&quot;@+id/mainTextView&quot;</span><br><span class="line">    android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">    android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">    android:text=&quot;Main Activity&quot;</span><br><span class="line">    app:layout_constraintBottom_toTopOf=&quot;@id/mainButton&quot;</span><br><span class="line">    app:layout_constraintLeft_toLeftOf=&quot;parent&quot;</span><br><span class="line">    app:layout_constraintRight_toRightOf=&quot;parent&quot;</span><br><span class="line">    app:layout_constraintTop_toTopOf=&quot;parent&quot;</span><br><span class="line">    app:layout_constraintVertical_chainStyle=&quot;packed&quot; /&gt;</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">androidx.constraintlayout.widget.ConstraintLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><p>App2的activity_second.xml：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">androidx.constraintlayout.widget.ConstraintLayout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xmlns:app</span>=<span class="string">&quot;http://schemas.android.com/apk/res-auto&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  &lt;Button</span><br><span class="line">    android:id=&quot;@+id/secondButton&quot;</span><br><span class="line">    android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">    android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">    android:layout_marginTop=&quot;16dp&quot;</span><br><span class="line">    android:text=&quot;Jump to Third&quot;</span><br><span class="line">    app:layout_constraintBottom_toBottomOf=&quot;parent&quot;</span><br><span class="line">    app:layout_constraintEnd_toEndOf=&quot;@id/secondTextView&quot;</span><br><span class="line">    app:layout_constraintStart_toStartOf=&quot;@id/secondTextView&quot;</span><br><span class="line">    app:layout_constraintTop_toBottomOf=&quot;@id/secondTextView&quot; /&gt;</span><br><span class="line"></span><br><span class="line">  &lt;TextView</span><br><span class="line">    android:id=&quot;@+id/secondTextView&quot;</span><br><span class="line">    android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">    android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">    android:text=&quot;Second Activity&quot;</span><br><span class="line">    app:layout_constraintBottom_toTopOf=&quot;@id/secondButton&quot;</span><br><span class="line">    app:layout_constraintLeft_toLeftOf=&quot;parent&quot;</span><br><span class="line">    app:layout_constraintRight_toRightOf=&quot;parent&quot;</span><br><span class="line">    app:layout_constraintTop_toTopOf=&quot;parent&quot;</span><br><span class="line">    app:layout_constraintVertical_chainStyle=&quot;packed&quot; /&gt;</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">androidx.constraintlayout.widget.ConstraintLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><p>App2的activity_third.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">androidx.constraintlayout.widget.ConstraintLayout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xmlns:app</span>=<span class="string">&quot;http://schemas.android.com/apk/res-auto&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  &lt;TextView</span><br><span class="line">    android:id=&quot;@+id/mainTextView&quot;</span><br><span class="line">    android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">    android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">    android:text=&quot;Third Activity&quot;</span><br><span class="line">    app:layout_constraintBottom_toBottomOf=&quot;parent&quot;</span><br><span class="line">    app:layout_constraintLeft_toLeftOf=&quot;parent&quot;</span><br><span class="line">    app:layout_constraintRight_toRightOf=&quot;parent&quot;</span><br><span class="line">    app:layout_constraintTop_toTopOf=&quot;parent&quot;</span><br><span class="line">    app:layout_constraintVertical_chainStyle=&quot;packed&quot; /&gt;</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">androidx.constraintlayout.widget.ConstraintLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><p>App2的MainActivity，SecondActivity和ThirdActivity：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//App2的MainActivity</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> : <span class="type">AppCompatActivity</span></span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_main)</span><br><span class="line">        <span class="comment">//点击button启动SecondActivity</span></span><br><span class="line">        findViewById&lt;Button&gt;(R.id.mainButton).setOnClickListener &#123;</span><br><span class="line">            startActivity(Intent(<span class="keyword">this</span>, SecondActivity::<span class="keyword">class</span>.java))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//App2的SecondActivity</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SecondActivity</span> : <span class="type">AppCompatActivity</span></span>() &#123;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">val</span> TAG = <span class="string">&quot;SecondActivity&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        Log.e(TAG,<span class="string">&quot;Activity on created.&quot;</span>)</span><br><span class="line">        setContentView(R.layout.activity_second)</span><br><span class="line">        <span class="comment">//点击button启动ThirdActivity</span></span><br><span class="line">        findViewById&lt;Button&gt;(R.id.secondButton).setOnClickListener &#123;</span><br><span class="line">            startActivity(Intent(<span class="keyword">this</span>, ThirdActivity::<span class="keyword">class</span>.java))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onNewIntent</span><span class="params">(intent: <span class="type">Intent</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onNewIntent(intent)</span><br><span class="line">        Log.e(TAG,<span class="string">&quot;Activity on new Intent.&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//App2的ThirdActivity</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThirdActivity</span> : <span class="type">AppCompatActivity</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_third)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>App2的AndroidManifest.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">manifest</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">package</span>=<span class="string">&quot;xyz.sachil.app2&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  &lt;application</span><br><span class="line">    android:allowBackup=&quot;true&quot;</span><br><span class="line">    android:icon=&quot;@mipmap/ic_launcher&quot;</span><br><span class="line">    android:label=&quot;@string/app_name&quot;</span><br><span class="line">    android:roundIcon=&quot;@mipmap/ic_launcher_round&quot;</span><br><span class="line">    android:supportsRtl=&quot;true&quot;</span><br><span class="line">    android:theme=&quot;@style/Theme.LaunchMode&quot;&gt;</span><br><span class="line">    <span class="tag">&lt;<span class="name">activity</span> <span class="attr">android:name</span>=<span class="string">&quot;.MainActivity&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">&quot;android.intent.action.MAIN&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">&quot;android.intent.category.LAUNCHER&quot;</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">activity</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    &lt;activity</span><br><span class="line">      android:exported=&quot;true&quot;</span><br><span class="line">      android:name=&quot;.SecondActivity&quot;</span><br><span class="line">      android:launchMode=&quot;standard&quot;&gt;</span><br><span class="line">      <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">&quot;com.perry.target&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">&quot;android.intent.category.DEFAULT&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">activity</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">activity</span> <span class="attr">android:name</span>=<span class="string">&quot;.ThirdActivity&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;/<span class="name">application</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">manifest</span>&gt;</span></span><br></pre></td></tr></table></figure><p>最常见的修改启动模式的方法就是在<code>AndroidManifest.xml</code>中进行修改：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">activity</span>  <span class="attr">android:launchMode</span>=<span class="string">&quot;standard|singleTop|singleTask|singleIntance&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><h3 id="standard">standard</h3><p>这是默认的启动模式，每次启动Activity时都会创建一个新的Activity，并放入Task的栈顶，当你在不同的Task中启动相同的Activity时，这个Activity会被创建出不同的实例，并分别放入不同的Task中，它们之间互不干扰。</p><p>例如我们将SecondActivity的启动模式修改为<code>standard</code>，启动App1的MainActivity，它被放入名为task1的Task中，然后点击button启动App2的SecondActivity，SecondActivity的实例会被创建，并被放入task1中。这时候将App1退到后台，然后启动App2，会创建App2的MainActivity，并放入名为task2的Task中，然后点击button启动SecondActivity，这时又会创建一个SenondActivity的实例，并将它放入task2中。task1中的SecondActivity和task2中的SecondActivity互不影响。</p><h3 id="singletop">singleTop</h3><p>它和<code>standard</code>一样，也是会直接把创建的Activity放入Task的栈顶，它们两者之间的区别是：<strong>如果启动Activity的时候，Task栈顶正好存在该Activity的实例，那么就不会调用<code>onCreate()</code>方法新建该Activity，而是直接调用该Activity的<code>onNewIntent()</code>方法对该Activity进行重用</strong>。</p><h3 id="singletask">singleTask</h3><p><code>singleTask</code>可以让Activity在被其它App启动的时候不会将该Activity放入启动它的Task中，而是会在属于它自己的Task中创建，并放入栈顶，然后将整个Task压在启动它的Task的上面。这样就可以保证，不管从哪个App启动，被标记了<code>singleTask</code>的Activity总是会被放入自己他Task中。细心的你可以发现，以这种方式打开的Activity的入场动画是应用䙦乱C切换的动画，而不是普通的Activity的入场动画，这也就是在刻意的提醒你，这是在进行跨任务操作。</p><p>例如我们将SecondActivity启动模式修改为<code>singleTask</code>，启动App1的MainActivity，它被放入名为task1的Task中，然后点击button启动App2的SecondActivity，SecondActivity的实例会被创建，并被放入task2中，并且会将task2叠在task1之上，如果这时候按返回键，将会执行task2中Activity的出栈，当task2回退栈被清空时(也就是task2结束时)，才会切回task1。这就是说，不仅是Task内部的Activity可以叠成栈，Task之间也可以叠成栈。但是，<strong>Task的叠加只适用于前台Task，一旦前台叠加的多个Task进入后台，它们之间的叠加关系就会被拆开</strong>。例如前面提到的task2结束时，将不再切回task1，而是直接返回桌面。有两种操作会让Task进入后台，一种是回到桌面，另一种是查看最近任务列表。</p><p>还有一点需要注意的是：<strong>在启动标记为<code>singleTask</code>的Activity时，如果该Activity在其Task中已经被创建，那么将会调用它的<code>onNewIntent()</code>方法进行重用，而不是调用<code>onCreate()</code>方法再新建一个。同时，如果该Activity不在其Task的栈顶，还会将其上面的其它Activity清空，以确保其出现在Task的栈顶</strong>。</p><p><code>singleTask</code>强调的是唯一性：使用该启动模式的Activity只会出现在某一个Task中，并且这个Task中只会有一个该Activity的实例。</p><h3 id="singleinstance">singleInstance</h3><p>它的行为逻辑和<code>singleTask</code>基本一致,但是它有更严格的限制：<strong>使用该启动模式的Activity所在的Task中只能有这一个Activity，Task中该Activity的下面和上面都不能有其它Activity的存在</strong>。前面我们提到<code>singleTask</code>强调唯一性，而<code>singleInstance</code>不仅强调唯一性，而且还强调独占性，它要独占整个Task。</p><p>在实际操作中，Activity在被启动后按返回键，<code>singleTask</code>标记的会在自己的Task中回退，而<code>singleInstance</code>标记的会直接返回启动的App(这其实很好理解，因为<code>singleInstance</code>的Task中只有一个Activity，一按返回键，这个Task就结束了)，稍候从桌面点开该Activity所在的App时，<code>singleTask</code>标记的Activity仍然在栈顶，而<code>singleInstance</code>标记的Activity却已经不见了，你以为它已经不存在了，但是当你使用<code>adb shell dumpsys activity</code>命令查看的时候，它却是存在的。前面我们提到，<strong>在最近任务列表里出现的Task不一定是活着的</strong>，这里还需要加上一句：<strong>在最近任务列表中未出现的Task也未必就是死的</strong>。</p><p>另外需要注意一下的是，在<code>singleInstance</code>模式下，如果存在任务栈task1(A-&gt;B-&gt;C)，C启动D(D为<code>singleInstance</code>模式)，则会创建任务栈task2(D)，然后D再启动C，这时任务栈task1为A-&gt;B-&gt;C-&gt;C，如果这时候按返回键，是不会返回到task2(D)的，而是任务栈task1回退(A-&gt;B-&gt;C)，只有当任务栈task1清空时再按返回，才会返回到任务栈task2(D)。</p><h2 id="intent的flag">Intent的flag</h2><p>在启动Activity时，可以在传送给<code>startActivity()</code>的Intent中添加相应的flag来修改Activity与其Task的默认关联，最常使用flag有以下几个：</p><ul><li><p><code>Intent.FLAG_ACTIVITY_SINGLE_TOP</code>，与使用<code>singleTop</code>所产生的行为相同。</p></li><li><p><code>Intent.FLAG_ACTIVITY_NEW_TASK</code>，如果在同一Task中单独使用，没有效果。如果是跨Task使用，如果该Activity的Task不存在，则创建该Task并新建该Activity的实例放入其中，如果该Activity的Task已经存在，则新建该Activity的实例放入该Task的栈顶。</p><p>如果搭配<code>Intent.FLAG_ACTIVITY_MULTIPLE_TASK</code>一起使用的话，产生的行为和<code>singleInstance</code>相似，不同的是标记为<code>singleInstance</code>的Activity会独占Task，而这里却不会。</p></li><li><p><code>Intent.FLAG_ACTIVITY_CLEAR_TOP</code>，单独使用时，如果要启动的Activity已经存在于Task中，并且该Activity的启动模式为<code>standard</code>，则会销毁该Activity以及它上面的Activity，并重新创建一个该Activity的实例放入Task栈顶。如果搭配<code>Intent.FLAG_ACTIVITY_SINGLE_TOP</code>使用或者将Activity的启动模式改为非<code>standard</code>，则只会销毁该Activity上面的其它Activity而不会销毁它自己，并调用<code>onNewIntent()</code>方法进行重用。</p><p>该flag常常搭配<code>Intent.FLAG_ACTIVITY_CLEAR_TOP</code>一起使用。</p></li></ul><h2 id="一些特殊情况">一些特殊情况</h2><h3 id="allowtaskreparenting">allowTaskReparenting</h3><p>默认情况下，Activity只会归属于某一个Task，不会在多个Task之间跳来跳去，但是<code>allowTaskReparenting</code>属性却可以改变这个行为，当它设置为<code>true</code>时，可以允许Activity回到它原本所属的Task中。</p><p>例如我们将SecondActivity的<code>allowTaskReparenting</code>属性设置为<code>true</code>，这时候启动App1的MainActivity，它会被放入task1中，点击button启动SecondActivity，Secondactivity会被放入task1的栈顶，然后回到桌面启动App2，你会看到原本在task1中的SecondActivity已经被挪到App2的task2的栈顶了，这时候再切回App1就看不到SecondActivity了。</p><p>另外我们需要注意的是，从App1中启动SecondActivity后，我们回到桌面，这时候我们不启动App2，而是点击App1的图标回到App1,你会发现SecondActivity也是不见了，这时候使用<code>adb shell dumpsys activity</code>命令可以发现，它已经被挪走了，在Android11的最近任务列表中你可以看到App1的Task和Secondactivity的Task两个Task，但是在Android7的最近任务列表中你只能看到App1的Task这一个Task。而如果在回到桌面后不是通过点击App1的图标回到App1,而是通过最近任务列表返回App1,你会看到SecondActivity仍然在App1的栈顶。(仅仅因为回到App1的方式不同，就可以决定SecondActivity是否被挪走，Android这种设计让我很迷惑啊。)</p><p><strong>关于这个属性的友情提醒，它在Android9和Android10上没有用</strong>。(可能是被改坏了，太坑了。)</p><h3 id="taskaffinity">taskAffinity</h3><p><code>taskAffinity</code>表示亲和性、相似性的意思，也就是表示Activity更倾向于属于哪一个Task。在Android上，一个App默认只有一个Task显示在最近任务列表中，这里的唯一性是通过<code>taskAffinity</code>来进行区分的。每一个Activity都有一个<code>taskAffinity</code>，就相当于对每一个Activity进行了分组，它的默认值是application的<code>taskAffinity</code>，而application中<code>taskAffinity</code>的默认值就是包名。</p><p>另外，每一个Task也有它的<code>taskAffinity</code>，它的值取自于Task栈底Activity的<code>taskAffinity</code>。默认情况下，一个App的所有Task的<code>taskAffinity</code>都是一样的，也就是App的包名，当我们启动一个Task时，它会从第一个入栈的Activity的<code>taskAffinity</code>得到自己的<code>taskAffinity</code>，当我们接着打开Activity的时候，<code>taskAffinity</code>就被忽略了，新的Activity会直接入栈。但是如果新的Activity被标记为<code>singleTask</code>时，Android就会去检查新的Activity的<code>taskAffinity</code>是否和当前Task的<code>taskAffinity</code>是一致的，如果一致则继续入栈操作，否则新的Activity会被放入和它拥有相同<code>taskAffinity</code>的Task中，如果没有这样的Task，就创建一个。所以，<strong><code>taskAffinity</code>搭配<code>standard</code>和<code>singleTop</code>是不起作用的，它需要搭配<code>singleTask</code>一起使用</strong>。</p><p>当你在你的App中启动一个标记为<code>singleTask</code>的Activity，如果这个Activity属于其它App，就会发生Task切换，而如果这个Activity属于自己的App，则直接将它放入当前Task的栈顶，这是因为该Activity的<code>taskAffinity</code>和Task的一样。而如果你再给该Activity设置一个独立的<code>taskAffinity</code>，你会发现，哪怕是同一个App，该Activity也会被放入其它的Task中，从而发生Task切换，而这时候正好该Activity的<code>taskAffinity</code>和其它App一致，那么这个Activity会被放入那个App的Task中(注意：这种现象在Android11上不会发生，这是因为Task的<code>taskAffinity</code>被加上了随机的前缀，这样即使这个Activity的<code>taskAffinity</code>设置为和其它App的一样，最终运行的时候，它们Task的<code>taskAffinity</code>还是会不一样。这样的更改，我想应该是处于安全的考虑)。如果这时候再从这个设置了独立<code>taskAffinity</code>的Activity中启动一个新的未设置<code>taskActivity</code>的Activity，那这个新的Activity会被放入哪个Task中呢？如果这个新的Activity被标记为<code>standard</code>或者<code>singleTop</code>，那么它就会被放到那个设置了独立<code>taskAffinity</code>的Activity的Task中，而如果被标记为<code>singleTask</code>，那么它就会被放到原本它就该属于的Task中。</p><p>当我们在查看最近任务列表的时候，不同的Task会被展示出来，但是前提条件就是，它们之间的<code>taskAffinity</code>是不一样的。在Android中，同一个<code>taskAffinity</code>可以创建出多个Task，但是它们只能有一个显示在最近任务别表中，这就是前面提到的那个被标记为<code>singleInstance</code>的Activity会从最近任务列表中消失的原因，因为它被具有相同<code>taskAffinity</code>的Task抢占了。</p><h2 id="总结">总结</h2><p>总的来说，<code>standard</code>和<code>singleTop</code>是直接将Activity叠加在当前的Task上，而<code>singleTask</code>和<code>singleInstance</code>则是两个"跨Task打开Activity"的规则，虽然不是一定跨Task，但是却表现出了强烈的跨Task意图。在平时的使用中，我们在App内部会多使用<code>standard</code>和<code>singleTop</code>，<code>singleInstance</code>会多用于开放给其它App一起使用的共享Activity，而<code>singleTask</code>这比较兼容，内部使用或者外部交互都可以使用。</p><hr /><p>参考文献：</p><p><ahref="https://rengwuxian.com/dang-wo-an-xia-home-jian-zai-qie-hui-lai-hui-fa-sheng-shen-me/">Android面试黑洞——当我按下 Home 键再切回来，会发生什么？</a></p>]]></content>
    
    
    <summary type="html">&lt;h1
id=&quot;android基础-activity的四种启动模式&quot;&gt;Android基础-Activity的四种启动模式&lt;/h1&gt;
&lt;p&gt;我们都知道，Android为Activity提供了&lt;code&gt;standard&lt;/code&gt;，&lt;code&gt;singleTop&lt;/code&gt;,&lt;code&gt;singleTask&lt;/code&gt;和&lt;code&gt;singleInstance&lt;/code&gt;4种启动模式(LaunchMode)，以适应不同的启动场景。但是如果想要熟练的掌握这些启动模式，并非你想象的那么简单，这其中会遇到一些坑，而且有的这些坑是Android官方文档带来的，在实践的过程中你会发现，有的现象和官方文档描述的完全不同(简直是坑你没商量啊！)，还有的官方文档中根本就没提。现在我们从实践中出发，来认真学习一下这4种启动模式。&lt;/p&gt;</summary>
    
    
    
    <category term="Android基础" scheme="https://sachil.xyz/categories/Android-Basis/"/>
    
    
    <category term="Android基础" scheme="https://sachil.xyz/tags/Android-Basis/"/>
    
    <category term="启动模式" scheme="https://sachil.xyz/tags/Launch-Mode/"/>
    
  </entry>
  
  <entry>
    <title>Android中的LruCache缓存</title>
    <link href="https://sachil.xyz/posts/a2b68561/"/>
    <id>https://sachil.xyz/posts/a2b68561/</id>
    <published>2018-07-23T03:26:54.000Z</published>
    <updated>2023-06-20T15:46:03.207Z</updated>
    
    <content type="html"><![CDATA[<h1 id="android中的lrucache缓存">Android中的LruCache缓存</h1><p>缓存机制是我们日常开发中常用的一种减少用户等待时间的手段，特别是在显示图片的时候，图片缓存会被频繁地使用，因为如果每次加载图片都是从网络上获取，由于网络的不稳定性，用户等待的时间就会很不确定，这样会影响用户体验，如果我们将图片缓存起来，加载的时候直接从缓存中获取，这样就可以减少用户的等待时间，从而提升用户体验。</p><p>目前主要的缓存策略是：当需要加载一张图片的时候，先尝试从内存中获取，如果内存中有，那么直接加载，否则尝试从本地文件中获取，如果本地文件中有，那么直接加载，否则将从网络上获取。<strong>这样的缓存策略通常被称之为三级缓存，即内存缓存、文件缓存和网络缓存</strong>。(其实我更愿意称之为二级缓存，因为，网络也算缓存吗？！)</p><p>缓存机制主要包含添加缓存、获取缓存和删除缓存这三种操作，前两种很好理解，至于为什么需要删除缓存？其实也容易理解，因为不管是内存缓存还是文件缓存，内存空间和磁盘空间的大小都是有限制的，你不能无限制的添加缓存，当缓存达到最大容量时，如果还想继续添加新的缓存，就不得不删除一些旧的缓存。</p><p>所以，LRU缓存算法就出现了，LRU(Least RecentlyUsed)算法即<strong>最近最少使用算法</strong>，其中心思想就是当缓存达到最大容量的时候，会优先删除那些近期最少使用的缓存，以便清理出缓存空间来添加新的缓存。Android从APILevel12开始为我们提供了一个名为<code>LruCache</code>的类，它实现了该算法，我们可以方便的使用它来进行内存缓存。</p><span id="more"></span><h2 id="lrucache的基本使用">LruCache的基本使用</h2><p><code>LruCache</code>使用起来是非常简单的，在创建它的对象的时候，我们会指定它的缓存空间的大小，在使用的时候通常会重写它的<code>sizeOf()</code>方法，以便得知每个缓存对象的缓存大小，需要注意的是这里两者的单位需要一致，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> maxMemory = Runtime.getRuntime().maxMemory() / <span class="number">16</span>;</span><br><span class="line"><span class="comment">//设定缓存的大小，这里使用的单位是KB</span></span><br><span class="line"><span class="keyword">int</span> cacheMemory = (<span class="keyword">int</span>) (maxMemory / <span class="number">1024</span>);</span><br><span class="line"><span class="comment">//用指定的缓存大小创建一个LruCache的对象用于缓存Bitmap</span></span><br><span class="line">LruCache&lt;String, Bitmap&gt; cache = <span class="keyword">new</span> LruCache&lt;String, Bitmap&gt;(cacheMemory) &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">sizeOf</span><span class="params">(<span class="meta">@NonNull</span> String key, <span class="meta">@NonNull</span> Bitmap value)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//重写了sizeof方法，返回每一个缓存的Bitmap的大小，单位也是KB</span></span><br><span class="line">        <span class="keyword">return</span> value.getByteCount() / <span class="number">1024</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//添加缓存</span></span><br><span class="line">cache.put(<span class="string">&quot;testBitmap&quot;</span>, Bitmap.createBitmap(<span class="number">100</span>, <span class="number">100</span>, Bitmap.Config.ARGB_8888));</span><br><span class="line"><span class="comment">//获取缓存</span></span><br><span class="line">Bitmap testBitmap = cache.get(<span class="string">&quot;testBitmap&quot;</span>);</span><br></pre></td></tr></table></figure><h2 id="lrucache的基本原理">LruCache的基本原理</h2><p><code>LruCache</code>的核心思想就是当缓存已满的时候，优先删除近期最少使用的缓存，所以就需要维护一个缓存对象的列表，以便知道哪些缓存对象是最近最少使用的。通过查看源码可以得知，<code>LruCache</code>的内部是使用一个<code>LinkedHashMap</code>来实现这个缓存对象的列表的，这是<code>LruCache</code>的构造方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LruCache</span><span class="params">(<span class="keyword">int</span> maxSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (maxSize &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;maxSize &lt;= 0&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.maxSize = maxSize;</span><br><span class="line">    <span class="comment">//在这里创建了一个LinkedHashMap对象，注意第三个参数是true</span></span><br><span class="line">    <span class="keyword">this</span>.map = <span class="keyword">new</span> LinkedHashMap&lt;K, V&gt;(<span class="number">0</span>, <span class="number">0.75f</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以如果我们想要更深入的了解<code>LruCache</code>的基本原理，我们就必须先了解<code>LinkedHashMap</code>的基本原理，这样我们再回到<code>LruCache</code>的时候，一切难题就将会迎刃而解。</p><h3 id="linkedhashmap的基本原理">LinkedHashMap的基本原理</h3><p>我们都知道<code>HashMap</code>是无序的，如果我们需要有序的存储键值对(key-value)，我们就需要用到<code>LinkedHashMap</code>，<code>LinkedHashMap</code>是<code>HashMap</code>的子类，如果不明白<code>HashMap</code>基本原理的，可以参考这篇文章：<ahref="https://sachil.xyz/posts/df0ab85e/">Java中的HashMap</a>。我们先来看一下<code>LinkedHashMap</code>的基本使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Map&lt;String, Integer&gt; map = <span class="keyword">new</span> LinkedHashMap&lt;&gt;();</span><br><span class="line">    map.put(<span class="string">&quot;one&quot;</span>, <span class="number">1</span>);</span><br><span class="line">    map.put(<span class="string">&quot;two&quot;</span>, <span class="number">2</span>);</span><br><span class="line">    map.put(<span class="string">&quot;three&quot;</span>, <span class="number">3</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//输出：key:one,value:1</span></span><br><span class="line"><span class="comment">//key:two,value:2</span></span><br><span class="line"><span class="comment">//key:three,value:3</span></span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;String, Integer&gt; entry : map.entrySet()) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;key:&quot;</span> + entry.getKey() + <span class="string">&quot;,value:&quot;</span> + entry.getValue());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从输出结果可以看到，输出顺序是和插入顺序是一致的，所以<code>LinkedHashMap</code>是有序的，而且默认就是插入顺序。</p><h4 id="构造函数">构造函数</h4><p><code>LinkedHashMap</code>是<code>HashMap</code>的子类，所以它们之间有很多相似之处，我们先来看一下它的构造函数。它一共有5个构造番薯，我们先看一下默认构造函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//JDK1.7</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedHashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//调用HashMap的构造方法</span></span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">    <span class="comment">//是否使用访问顺序，这里设置为false</span></span><br><span class="line">    accessOrder = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们看到，首先他会调用<code>HashMap</code>的构造函数，也就是根据初始的容量和负载因子去计算扩容阈值，以及初始化一个名为<code>table</code>的<code>Entry</code>数组，也就是哈希桶数组。然后将<code>accessOrder</code>设置为<code>false</code>，这个<code>accessOrder</code>是和存储顺序有关的，它用来标记是否使用访问顺序。在<code>LinkedHashMap</code>中有两种存储顺序：<strong>插入顺序</strong>和<strong>访问顺序</strong>，我们可以通过代码来检验一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//这里设置accessOrder为true，表示使用访问顺序</span></span><br><span class="line">    Map&lt;String, Integer&gt; map = <span class="keyword">new</span> LinkedHashMap&lt;&gt;(<span class="number">0</span>, <span class="number">0.75F</span>, <span class="keyword">true</span>);</span><br><span class="line">    map.put(<span class="string">&quot;one&quot;</span>, <span class="number">1</span>);</span><br><span class="line">    map.put(<span class="string">&quot;two&quot;</span>, <span class="number">2</span>);</span><br><span class="line">    map.put(<span class="string">&quot;three&quot;</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">     <span class="comment">//输出：key:one,value:1</span></span><br><span class="line"><span class="comment">//key:two,value:2</span></span><br><span class="line"><span class="comment">//key:three,value:3</span></span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;String, Integer&gt; entry : map.entrySet()) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;key:&quot;</span> + entry.getKey() + <span class="string">&quot;,value:&quot;</span> + entry.getValue());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    map.get(<span class="string">&quot;one&quot;</span>);</span><br><span class="line">    <span class="comment">//输出：key:two,value:2</span></span><br><span class="line"><span class="comment">//key:three,value:3</span></span><br><span class="line"><span class="comment">//key:one,value:1</span></span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;String, Integer&gt; entry : map.entrySet()) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;key:&quot;</span> + entry.getKey() + <span class="string">&quot;,value:&quot;</span> + entry.getValue());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们创建<code>LinkedHashMap</code>的同时将<code>accessOrder</code>设置为<code>true</code>时，就表示使用访问顺序，我们使用<code>get</code>方法会改变原有的插入顺序。</p><h4 id="顺序存储的原理">顺序存储的原理</h4><p><code>LinkedHashMap</code>之所以可以实现顺序存储，是因为在它的内部重新定义了一个静态内部类<code>Entry</code>，这个<code>Entry</code>继承自<code>HashMap</code>的<code>HashMap.Entry</code>，并做了新的扩展，我们可以看一下它的定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//JDK1.7</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">HashMap</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">//这里添加了两个属性：before指向前一个Entry，after指向下一个Entry</span></span><br><span class="line">    Entry&lt;K,V&gt; before, after;</span><br><span class="line"></span><br><span class="line">    Entry(<span class="keyword">int</span> hash, K key, V value, HashMap.Entry&lt;K,V&gt; next) &#123;</span><br><span class="line">        <span class="comment">//调用HashMap中Entry的构造函数</span></span><br><span class="line">        <span class="keyword">super</span>(hash, key, value, next);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addBefore</span><span class="params">(Entry&lt;K,V&gt; existingEntry)</span> </span>&#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">recordAccess</span><span class="params">(HashMap&lt;K,V&gt; m)</span> </span>&#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">recordRemoval</span><span class="params">(HashMap&lt;K,V&gt; m)</span> </span>&#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们看到，在<code>LinkedHashMap</code>中的<code>Entry</code>比<code>HashMap</code>中的<code>Entry</code>多了两个属性：<code>beforre</code>和<code>after</code>，<code>before</code>用于指向前一个<code>Entry</code>，<code>after</code>用于指向下一个<code>Entry</code>，正是由于添加了这两个关键的属性，<strong><code>LinkedHashMap</code>的内部就实现了一个双向链表</strong>。另外，由于它继承自<code>HashMap.Entry</code>，所以它仍然保留着用于维护单链表的<code>next</code>属性，所以在<code>LinkedHashMap</code>的<code>Entry</code>节点中包含着三个节点引用，<code>next</code>用于维护<code>table</code>数组（即哈希桶数组）中的<code>Entry</code>链表，而<code>before</code>和<code>after</code>用于维护双向链表。</p><p>在<code>HashMap</code>的构造函数中会调用<code>init()</code>方法，这个方法在<code>HashMap</code>是一个空方法，而在<code>LinkedHashMap</code>中重写了该方法,所以在创建<code>LinkedHashMap</code>对象的时候，就会调用该方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//JDK1.7</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建了一个头节点header，它就是双向链表的入口</span></span><br><span class="line">    header = <span class="keyword">new</span> Entry&lt;&gt;(-<span class="number">1</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">    <span class="comment">//将header节点的before和after都指向自己，也就是创建了一个只有header节点的双向链表</span></span><br><span class="line">    header.before = header.after = header;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样<code>LinkedHashMap</code>就创建了一个只有<code>header</code>节点的双向链表，<code>header</code>就是这个双向链表的入口。</p><h4 id="put方法">put方法</h4><p><code>LinkedHashMap</code>并没有重写<code>put()</code>方法，所以是和<code>HashMap</code>的<code>put()</code>方法是一样的，但是<code>LinkedHashMap</code>重写了<code>addEntry()</code>方法和<code>createEntry()</code>方法，以便实现双链表的相关逻辑。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//JDK1.7</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建新的Entry</span></span><br><span class="line">    createEntry(hash, key, value, bucketIndex);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Remove eldest entry if instructed, else grow capacity if appropriate</span></span><br><span class="line">    Entry&lt;K,V&gt; eldest = header.after;</span><br><span class="line">    <span class="comment">//这里removeEldestEntry返回值总是false，所以可以忽略</span></span><br><span class="line">    <span class="keyword">if</span> (removeEldestEntry(eldest)) &#123;</span><br><span class="line">        removeEntryForKey(eldest.key);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//键值对的数量大于扩容阈值时，就进行扩容操作</span></span><br><span class="line">        <span class="keyword">if</span> (size &gt;= threshold)</span><br><span class="line">            resize(<span class="number">2</span> * table.length);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</span><br><span class="line">    HashMap.Entry&lt;K,V&gt; old = table[bucketIndex];</span><br><span class="line">    Entry&lt;K,V&gt; e = <span class="keyword">new</span> Entry&lt;&gt;(hash, key, value, old);</span><br><span class="line">    <span class="comment">//这里是将新的Entry添加到table[bucketIndex]中Entry链表的表头</span></span><br><span class="line">    table[bucketIndex] = e;</span><br><span class="line">    <span class="comment">//这里是将新的Entry添加到双向链表中</span></span><br><span class="line">    e.addBefore(header);</span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从代码中可以得知，在创建新的<code>Entry</code>的时候，不仅需要将<code>Entry</code>添加到<code>HashMap</code>的<code>table</code>中去，还需要调用<code>Entry</code>的<code>addBefore()</code>方法，将<code>Entry</code>添加到双向链表中去。<code>LinkedHashMap</code>中<code>Entry</code>的<code>addBefore()</code>方法代码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//JDK1.7</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addBefore</span><span class="params">(Entry&lt;K,V&gt; existingEntry)</span> </span>&#123;</span><br><span class="line">    after  = existingEntry;</span><br><span class="line">    before = existingEntry.before;</span><br><span class="line">    before.after = <span class="keyword">this</span>;</span><br><span class="line">    after.before = <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><code>addBefore()</code>方法的作用就是将这个新创建的<code>Entry</code>添加到双向链表的表尾，并将这个双向链表变成双向循环链表，也就是<code>header</code>节点的<code>before</code>会指向双向链表表尾的节点，双向链表表尾节点的<code>after</code>会指向<code>header</code>节点</strong>。其过程如下图所示：</p><p><imgsrc="https://gitee.com/sachil/blog-pictures/raw/master/image/LinkedHashMap.png" /></p><p>这就是<code>LinkedHashMap</code>的<code>put</code>过程，基本上和<code>HashMap</code>的一致，只是添加了双向链表的操作逻辑。</p><h4 id="访问顺序的实现原理">访问顺序的实现原理</h4><p>访问顺序实现的基本原理其实就是双向链表的重新排序，在<code>LinkedHashMap</code>的<code>get()</code>方法中会去调用<code>Entry</code>的<code>recordAccess()</code>方法，由于<code>HashMap</code>是无序的，所以这个方法在<code>HashMap</code>是一个空方法，但是在<code>LinkedHashMap</code>的<code>Entry</code>中重写了该方法，来实现重新排序。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//JDK1.7</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Entry&lt;K,V&gt; e = (Entry&lt;K,V&gt;)getEntry(key);</span><br><span class="line">    <span class="keyword">if</span> (e == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//这里调用Entry的recordAccess方法来实现重新排序</span></span><br><span class="line">    e.recordAccess(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">return</span> e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">recordAccess</span><span class="params">(HashMap&lt;K,V&gt; m)</span> </span>&#123;</span><br><span class="line">    LinkedHashMap&lt;K,V&gt; lm = (LinkedHashMap&lt;K,V&gt;)m;</span><br><span class="line">    <span class="comment">//判断是否是访问顺序，因为插入顺序是不需要重新排序的</span></span><br><span class="line">    <span class="keyword">if</span> (lm.accessOrder) &#123;</span><br><span class="line">        lm.modCount++;</span><br><span class="line">        <span class="comment">//该Entry从双向链表中删除</span></span><br><span class="line">        remove();</span><br><span class="line">        <span class="comment">//然后再将它添加到双向链表的表尾</span></span><br><span class="line">        addBefore(lm.header);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//注意这里并没有将Entry从HashMap的单链表中删除，而只是将它从双向链表中删除而已</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    before.after = after;</span><br><span class="line">    after.before = before;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实其实现是非常简单的，就是将该<code>Entry</code>节点先从双向链表中删除，然后再将该节点添加到双向链表的表尾。注意，这里的删除并没有在<code>HashMap</code>中做实际的删除操作，而只是在双向链表中进行删除操作。这样就实现了<code>LinkedHashMap</code>的访问顺序。</p><h4 id="遍历linkedhashmap">遍历LinkedHashMap</h4><p><code>LinkedHashMap</code>是有序的，所以它的遍历逻辑也和<code>HashMap</code>的遍历逻辑是不相同的。<code>HashMap</code>的遍历逻辑是从<code>table</code>数组出发，依次遍历该数组中的<code>Entry</code>链表，所以遍历出的结果是无序的。而<code>LinkedHashMap</code>的遍历逻辑不是这样的，在<code>LinkedHashMap</code>内部定义了一个继承自<code>Iterator</code>的内部类<code>LinkedHashIterator</code>来实现遍历时的迭代逻辑：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//JDK1.7</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedHashIterator</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">//从双向链表的入口header节点出发</span></span><br><span class="line">    Entry&lt;K,V&gt; nextEntry    = header.after;</span><br><span class="line">    Entry&lt;K,V&gt; lastReturned = <span class="keyword">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果nextEntry就是header节点，就表示已经到双向链表的表尾了</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nextEntry != header;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (lastReturned == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">        <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line"></span><br><span class="line">        LinkedHashMap.<span class="keyword">this</span>.remove(lastReturned.key);</span><br><span class="line">        lastReturned = <span class="keyword">null</span>;</span><br><span class="line">        expectedModCount = modCount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Entry&lt;K,V&gt; <span class="title">nextEntry</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">        <span class="keyword">if</span> (nextEntry == header)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//就是依次从双向链表中获取Entry</span></span><br><span class="line">        Entry&lt;K,V&gt; e = lastReturned = nextEntry;</span><br><span class="line">        nextEntry = e.after;</span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从代码中可以知道，<code>LinkedHashMap</code>的遍历逻辑就是遍历双向链表，直到双向链表的表尾。所以这就是<code>LinkedHashMap</code>是有序的原因。</p><h2 id="lrucache中几个重要的方法">LruCache中几个重要的方法</h2><p>在明白了<code>LinkHashMap</code>的基本原理之后，我们回到<code>LruCache</code>。我们在它的构造函数中已经看到，它创建了一个<code>LinkedHashMap</code>对象，并且该<code>LinkedHashMap</code>对象的<code>accessOrder</code>被设置为<code>true</code>，<strong>所以<code>LruCache</code>使用的是访问顺序</strong>，即近期添加或者访问的元素会被添加到双向链表的末尾。这简直就和LRU算法的中心思想不谋而合，最近最少使用的元素会双向链表的表头，表尾则是新添加的或者最近使用过的元素，所以在删除缓存的时候，从双向链表的表头开始删除就可以了。</p><p><code>LurCache</code>中提供了几个很重要的方法，例如<code>put()</code>,<code>get()</code>,<code>trimToSize()</code>等。</p><h3 id="put方法-1">put方法</h3><p>我们先来看一下<code>LruCache</code>中<code>put</code>方法的实现，该方法用于添加缓存。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">put</span><span class="params">(<span class="meta">@NonNull</span> K key, <span class="meta">@NonNull</span> V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span> || value == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">&quot;key == null || value == null&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    V previous;</span><br><span class="line">    <span class="comment">//由于LinkedHashMap不是线程安全的，所以这里加上同步操作</span></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        putCount++;</span><br><span class="line">        <span class="comment">//safeSizeOf会调用我们重写的sizeOf方法，用来计算每一个缓存的大小</span></span><br><span class="line">        <span class="comment">//这里将新添加的缓存的大小加上</span></span><br><span class="line">        size += safeSizeOf(key, value);</span><br><span class="line">        <span class="comment">//将缓存放入LinkedHashMap中</span></span><br><span class="line">        previous = map.put(key, value);</span><br><span class="line">        <span class="comment">//如果缓存已经存在，那么需要减去原来缓存的大小</span></span><br><span class="line">        <span class="keyword">if</span> (previous != <span class="keyword">null</span>) &#123;</span><br><span class="line">            size -= safeSizeOf(key, previous);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//entryRemoved是一个空方法，这里忽略</span></span><br><span class="line">    <span class="keyword">if</span> (previous != <span class="keyword">null</span>) &#123;</span><br><span class="line">        entryRemoved(<span class="keyword">false</span>, key, previous, value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//开始清理缓存</span></span><br><span class="line">    trimToSize(maxSize);</span><br><span class="line">    <span class="keyword">return</span> previous;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>put()</code>方法很容易理解，就是将新添加的缓存存入<code>LinkedHashMap</code>，并且计算出新缓存的大小，然后让已经占用的缓存大小加上这个新缓存的大小，在然后判断这个缓存是否已经存在过，因为已经存在过就会用新的缓存覆盖旧的缓存，所以已经占用的缓存大小就需要再减去旧缓存的大小，最后开始执行<code>trimToSize()</code>方法来清理缓存。</p><h3 id="trimtosize方法">trimToSize方法</h3><p>从上面的分析我们可以知道，<code>LruCache</code>的核心方法就是<code>trimToSize()</code>方法，它用来清理缓存，下面我们看一下它的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">trimToSize</span><span class="params">(<span class="keyword">int</span> maxSize)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//开启一个死循环</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        K key;</span><br><span class="line">        V value;</span><br><span class="line">        <span class="comment">//同样的，为了线程安全，添加同步操作</span></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="comment">//如果已经占用的缓存大小size小于0,或者LinkedHashMap已经清空但是size不为0,则抛出异常</span></span><br><span class="line">            <span class="keyword">if</span> (size &lt; <span class="number">0</span> || (map.isEmpty() &amp;&amp; size != <span class="number">0</span>)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(getClass().getName()</span><br><span class="line">                        + <span class="string">&quot;.sizeOf() is reporting inconsistent results!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果已经占用的缓存大小不超过最大缓存的大小或者LinkedHashMap已经清空</span></span><br><span class="line">            <span class="comment">//就不再需要继续清理缓存，从而跳出循环</span></span><br><span class="line">            <span class="keyword">if</span> (size &lt;= maxSize || map.isEmpty()) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//每次循环都是从LinkedHashMap中的双向链表的表头获取缓存，这样可以确保这个缓存是最近最少使用的</span></span><br><span class="line">            Map.Entry&lt;K, V&gt; toEvict = map.entrySet().iterator().next();</span><br><span class="line">            key = toEvict.getKey();</span><br><span class="line">            value = toEvict.getValue();</span><br><span class="line">            <span class="comment">//从LinkedHashMap中删除这个缓存</span></span><br><span class="line">            map.remove(key);</span><br><span class="line">            <span class="comment">//已经占用的缓存大小需要减去这个已经清理的缓存的大小</span></span><br><span class="line">            size -= safeSizeOf(key, value);</span><br><span class="line">            evictionCount++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//空方法，可忽略</span></span><br><span class="line">        entryRemoved(<span class="keyword">true</span>, key, value, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>trimToSize()</code>方法也很容易理解，它会开启一个死循环不断的清理缓存，直到已占用的缓存大小不超过最大的缓存大小或者所有缓存已被清空。清理缓存是通过删除<code>LinkedHashMap</code>中的双向链表的表头来实现的，每次循环都会删除双向链表的表头，因为双向链表的表头正是存放的是最近最少使用的缓存，最后再重新计算已占用缓存的大小。</p><h3 id="get方法">get方法</h3><p>最后我们来看一下<code>LruCache</code>的<code>get()</code>方法，它用于获取缓存。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">get</span><span class="params">(<span class="meta">@NonNull</span> K key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">&quot;key == null&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    V mapValue;</span><br><span class="line">    <span class="comment">//同样的，为了线程安全，添加了同步操作</span></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="comment">//直接从LinkedHashMap中获取缓存</span></span><br><span class="line">        mapValue = map.get(key);</span><br><span class="line">        <span class="comment">//如果缓存存在，就直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (mapValue != <span class="keyword">null</span>) &#123;</span><br><span class="line">            hitCount++;</span><br><span class="line">            <span class="keyword">return</span> mapValue;</span><br><span class="line">        &#125;</span><br><span class="line">        missCount++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//否则，执行create方法，这个方法默认返回null</span></span><br><span class="line">    V createdValue = create(key);</span><br><span class="line">    <span class="comment">//所以，这里就直接返回了，返回值为null</span></span><br><span class="line">    <span class="keyword">if</span> (createdValue == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//下面的这些代码默认可以忽略</span></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        createCount++;</span><br><span class="line">        mapValue = map.put(key, createdValue);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mapValue != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// There was a conflict so undo that last put</span></span><br><span class="line">            map.put(key, mapValue);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            size += safeSizeOf(key, createdValue);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mapValue != <span class="keyword">null</span>) &#123;</span><br><span class="line">        entryRemoved(<span class="keyword">false</span>, key, createdValue, mapValue);</span><br><span class="line">        <span class="keyword">return</span> mapValue;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        trimToSize(maxSize);</span><br><span class="line">        <span class="keyword">return</span> createdValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>get()</code>方法很容易理解，如果缓存存在就返回缓存，否则就返回<code>null</code>，它直接使用了<code>LinkedHashMap</code>的<code>get()</code>方法来获取返回，从前面的内容我们知道，这个<code>LinkedHashMap</code>使用的是访问顺序，所以它的<code>get()</code>方法会将缓存重新插入到双向链表的末尾，这样缓存的位置就得到了更新，双向链表的表头就是存放的是最近最少使用的缓存，这满足<code>trimToSize()</code>方法的预期。</p><hr /><h2 id="小结">小结</h2><p>最后再来总结一下：</p><ul><li>LRU缓存算法即最近最少使用算法，Android中提供了一个该算法的实现<code>LruCache</code>，用来进行内存缓存。</li><li><code>LruCache</code>内部使用一个<code>LinkedHashMap</code>来维护缓存实例。</li><li><code>LinkedHashMap</code>是有序的，它有两种顺序：<strong>插入顺序</strong>和<strong>访问顺序</strong>，<code>LruCache</code>中的<code>LinkedHashMap</code>使用的是访问顺序。</li><li><code>LinkedHashMap</code>的有序是通过双向链表实现的(<code>JDK1.7</code>中是双向循环链表)，它将新的<code>Entry</code>添加到双向链表的表尾，如果是访问顺序，它还会将最近访问的<code>Entry</code>重新排列到双向链表的表尾，这样双向链表的表头就是最近最少访问的<code>Entry</code>。</li><li><code>LinkedHashMap</code>不是线程安全的，<code>LruCache</code>添加了同步操作，所以<code>LruCache</code>是线程安全的。</li><li><code>LruCache</code>的核心方法是<code>trimToSize()</code>方法，该方法不断地从<code>LinkedHashMap</code>中双向链表的表头删除缓存，直到已占用缓存的大小不超过最大缓存的大小或者所有缓存已经被清空。</li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;android中的lrucache缓存&quot;&gt;Android中的LruCache缓存&lt;/h1&gt;
&lt;p&gt;缓存机制是我们日常开发中常用的一种减少用户等待时间的手段，特别是在显示图片的时候，图片缓存会被频繁地使用，因为如果每次加载图片都是从网络上获取，由于网络的不稳定性，用户等待的时间就会很不确定，这样会影响用户体验，如果我们将图片缓存起来，加载的时候直接从缓存中获取，这样就可以减少用户的等待时间，从而提升用户体验。&lt;/p&gt;
&lt;p&gt;目前主要的缓存策略是：当需要加载一张图片的时候，先尝试从内存中获取，如果内存中有，那么直接加载，否则尝试从本地文件中获取，如果本地文件中有，那么直接加载，否则将从网络上获取。&lt;strong&gt;这样的缓存策略通常被称之为三级缓存，即内存缓存、文件缓存和网络缓存&lt;/strong&gt;。(其实我更愿意称之为二级缓存，因为，网络也算缓存吗？！)&lt;/p&gt;
&lt;p&gt;缓存机制主要包含添加缓存、获取缓存和删除缓存这三种操作，前两种很好理解，至于为什么需要删除缓存？其实也容易理解，因为不管是内存缓存还是文件缓存，内存空间和磁盘空间的大小都是有限制的，你不能无限制的添加缓存，当缓存达到最大容量时，如果还想继续添加新的缓存，就不得不删除一些旧的缓存。&lt;/p&gt;
&lt;p&gt;所以，LRU缓存算法就出现了，LRU(Least Recently
Used)算法即&lt;strong&gt;最近最少使用算法&lt;/strong&gt;，其中心思想就是当缓存达到最大容量的时候，会优先删除那些近期最少使用的缓存，以便清理出缓存空间来添加新的缓存。Android从API
Level
12开始为我们提供了一个名为&lt;code&gt;LruCache&lt;/code&gt;的类，它实现了该算法，我们可以方便的使用它来进行内存缓存。&lt;/p&gt;</summary>
    
    
    
    <category term="Android基础" scheme="https://sachil.xyz/categories/Android-Basis/"/>
    
    
    <category term="Android" scheme="https://sachil.xyz/tags/Android/"/>
    
    <category term="Lrucache" scheme="https://sachil.xyz/tags/Lrucache/"/>
    
    <category term="LinkedMap" scheme="https://sachil.xyz/tags/LinkedMap/"/>
    
  </entry>
  
</feed>
